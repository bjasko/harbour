// TOKEN.och oszt ly implement ci¢.
// Gener lva: 1999.06.10, 14:39:57, OBJCCC  v2.2.03
// Meta oszt ly defin¡ci¢: Van


#ifndef CA_OBJECT_N
#ifdef _STRICT_PARENT_
#ifdef _CA_CM_ONLY_
#include "OBJECT.och"
#else // _CA_CM_ONLY_
#define _CA_CM_ONLY_
#include "OBJECT.och"
#undef _CA_CM_ONLY_
#endif // _CA_CM_ONLY_
#else
#include "OBJECT.och"
#endif // _STRICT_PARENT_
#endif // CA_OBJECT_N

#ifndef _CA_CM_ONLY_
#ifndef _TOKEN_OCH_
#define _TOKEN_OCH_




#xtranslate TOKEN.<obj>:oinit            => (OBJGEN.(<obj>):(4))
#xtranslate TOKEN.<obj>:getclass         => (OBJGEN.(<obj>):(5))
#xtranslate TOKEN.<obj>:isclass          => (OBJGEN.(<obj>):(6))
#xtranslate TOKEN.<obj>:getattrib        => (OBJGEN.(<obj>):(7))
#xtranslate TOKEN.<obj>:setattrib        => (OBJGEN.(<obj>):(8))


#xtranslate TOKEN.<obj>:id               => <obj>\[CA_OBJECT_N+1\]
#xtranslate TOKEN.<obj>:str              => <obj>\[CA_OBJECT_N+2\]
#xtranslate TOKEN.<obj>:file             => <obj>\[CA_OBJECT_N+3\]
#xtranslate TOKEN.<obj>:line             => <obj>\[CA_OBJECT_N+4\]
#xtranslate TOKEN.<obj>:pos              => <obj>\[CA_OBJECT_N+5\]
#xtranslate TOKEN.<obj>:classify         => <obj>\[CA_OBJECT_N+6\]
#xtranslate TOKEN.<obj>:error            => <obj>\[CA_OBJECT_N+7\]
#xtranslate TOKEN.<obj>:eqtype           => <obj>\[CA_OBJECT_N+8\]

// Specifik lva: iserror()
// Specifik lva: errorstr()
// Specifik lva: printtostr()
// Specifik lva: getstr()
// Specifik lva: copytoken(id,str)
// ™r”k”lve: oinit(id,str,file,line,pos)

#xtranslate TOKEN.<obj>:iserror          => (OBJGEN.(<obj>):(CM_OBJECT_N+1))
#xtranslate TOKEN.<obj>:errorstr         => (OBJGEN.(<obj>):(CM_OBJECT_N+2))
#xtranslate TOKEN.<obj>:printtostr       => (OBJGEN.(<obj>):(CM_OBJECT_N+3))
#xtranslate TOKEN.<obj>:getstr           => (OBJGEN.(<obj>):(CM_OBJECT_N+4))
#xtranslate TOKEN.<obj>:copytoken        => (OBJGEN.(<obj>):(CM_OBJECT_N+5))
// ™r”k”lve: oinit(id,str,file,line,pos)

#endif // _TOKEN_OCH_
#endif // _CA_CM_ONLY_

#ifndef CA_TOKEN_N
#define CA_TOKEN_N             CA_OBJECT_N+8
#define CM_TOKEN_N             CM_OBJECT_N+5
#endif // CA_TOKEN_N

#ifndef _CA_CM_ONLY_
#ifndef _TOKENCLASS_OCH_
#define _TOKENCLASS_OCH_

**********************************************************************
#xtranslate C.TOKEN:<m> => (TOKENCLASS.clTOKEN():<m>)
#xtranslate C.TOKEN:self() => (clTOKEN())


#xtranslate TOKENCLASS.<obj>:parent           => <obj>\[CA_OBJECT_N+1\]
#xtranslate TOKENCLASS.<obj>:name             => <obj>\[CA_OBJECT_N+2\]
#xtranslate TOKENCLASS.<obj>:objsize          => <obj>\[CA_OBJECT_N+3\]
#xtranslate TOKENCLASS.<obj>:attribs          => <obj>\[CA_OBJECT_N+4\]
#xtranslate TOKENCLASS.<obj>:methods          => <obj>\[CA_OBJECT_N+5\]
#xtranslate TOKENCLASS.<obj>:classid          => <obj>\[CA_OBJECT_N+6\]
#xtranslate TOKENCLASS.<obj>:parentclassids   => <obj>\[CA_OBJECT_N+7\]
#xtranslate TOKENCLASS.<obj>:amblock          => <obj>\[CA_OBJECT_N+8\]
#xtranslate TOKENCLASS.<obj>:methodsblock     => <obj>\[CA_OBJECT_N+9\]
#xtranslate TOKENCLASS.<obj>:objmethodsimplement  => <obj>\[CA_OBJECT_N+10\]


#xtranslate TOKENCLASS.<obj>:oinit            => (OBJGEN.(<obj>):(4))
#xtranslate TOKENCLASS.<obj>:getclass         => (OBJGEN.(<obj>):(5))
#xtranslate TOKENCLASS.<obj>:isclass          => (OBJGEN.(<obj>):(6))
#xtranslate TOKENCLASS.<obj>:getattrib        => (OBJGEN.(<obj>):(7))
#xtranslate TOKENCLASS.<obj>:setattrib        => (OBJGEN.(<obj>):(8))
#xtranslate TOKENCLASS.<obj>:onew             => (OBJGEN.(<obj>):(CM_OBJECT_N+1))
#xtranslate TOKENCLASS.<obj>:ocreate          => (OBJGEN.(<obj>):(CM_OBJECT_N+2))
#xtranslate TOKENCLASS.<obj>:rawoinit         => (OBJGEN.(<obj>):(CM_OBJECT_N+3))
#xtranslate TOKENCLASS.<obj>:oinitclass       => (OBJGEN.(<obj>):(CM_OBJECT_N+4))
#xtranslate TOKENCLASS.<obj>:getmethodsimplement  => (OBJGEN.(<obj>):(CM_OBJECT_N+5))
#xtranslate TOKENCLASS.<obj>:attribidx        => (OBJGEN.(<obj>):(CM_OBJECT_N+6))
#xtranslate TOKENCLASS.<obj>:needclassid      => (OBJGEN.(<obj>):(CM_OBJECT_N+7))
#xtranslate TOKENCLASS.<obj>:isinheritfrom    => (OBJGEN.(<obj>):(CM_OBJECT_N+8))


#xtranslate TOKENCLASS.<obj>:errstrarray      => <obj>\[CA_BEHAVIOR_N+1\]
#xtranslate TOKENCLASS.<obj>:equivclass       => <obj>\[CA_BEHAVIOR_N+2\]

// ™r”k”lve: onew(id,str,file,line,pos)
// Specifik lva: onewerror(id,str,file,line,pos,error)
// ™r”k”lve: oinitclass()
// Specifik lva: copyfromtoken(t,id,str)
// Specifik lva: findclassify(str)

// ™r”k”lve: onew(id,str,file,line,pos)
#xtranslate TOKENCLASS.<obj>:onewerror        => (OBJGEN.(<obj>):(CM_BEHAVIOR_N+1))
// ™r”k”lve: oinitclass()
#xtranslate TOKENCLASS.<obj>:copyfromtoken    => (OBJGEN.(<obj>):(CM_BEHAVIOR_N+2))
#xtranslate TOKENCLASS.<obj>:findclassify     => (OBJGEN.(<obj>):(CM_BEHAVIOR_N+3))

#endif // _TOKENCLASS_OCH_
#endif // _CA_CM_ONLY_

#ifndef CA_TOKENCLASS_N
#define CA_TOKENCLASS_N             CA_BEHAVIOR_N+2
#define CM_TOKENCLASS_N             CM_BEHAVIOR_N+3
#endif // CA_TOKENCLASS_N


**********************************************************************
#ifdef _TOKEN_PRG_
#ifndef _TOKEN_PRG_OCH_
#define _TOKEN_PRG_OCH_


**********************************************************************
#xtranslate othis:<m> => TOKEN.(othis):<m>
#xtranslate thisclass:<m> => TOKENCLASS.(this:getClass()):<m>
#define CTHIS TOKEN


**********************************************************************
#xtranslate this:<m> => TOKEN.(this):<m>

#xcommand implement iserror()      => static function iserror(this)
#xcommand implement errorstr()     => static function errorstr(this)
#xcommand implement printtostr()   => static function printtostr(this)
#xcommand implement getstr()       => static function getstr(this)
#xcommand implement copytoken(id,str) => ;
                    static function copytoken(this,id,str)
#xcommand implement oinit(id,str,file,line,pos) => ;
                    static function oinit(this,id,str,file,line,pos)

#ifdef _IMPLEMENT_EXPORT_
#xcommand implement export iserror()      => function iserror(this)
#xcommand implement export errorstr()     => function errorstr(this)
#xcommand implement export printtostr()   => function printtostr(this)
#xcommand implement export getstr()       => function getstr(this)
#xcommand implement export copytoken(id,str) => ;
                    function copytoken(this,id,str)
#xcommand implement export oinit(id,str,file,line,pos) => ;
                    function oinit(this,id,str,file,line,pos)
#endif // _IMPLEMENT_EXPORT_

#xtranslate super:oinit            => (OBJGENM.(eval(BEHAVIOR.clOBJECT():objmethodsimplement)).(this):(4))
#xtranslate super:getclass         => (OBJGENM.(eval(BEHAVIOR.clOBJECT():objmethodsimplement)).(this):(5))
#xtranslate super:isclass          => (OBJGENM.(eval(BEHAVIOR.clOBJECT():objmethodsimplement)).(this):(6))
#xtranslate super:getattrib        => (OBJGENM.(eval(BEHAVIOR.clOBJECT():objmethodsimplement)).(this):(7))
#xtranslate super:setattrib        => (OBJGENM.(eval(BEHAVIOR.clOBJECT():objmethodsimplement)).(this):(8))

**********************************************************************
static function setCMethods(pOsztaly)
// Egy t”mb”t felt”lt az oszt ly m–veleti blokkjaival.
   pOsztaly[(CM_OBJECT_N+1)]:={|this| iserror(this)}
   pOsztaly[(CM_OBJECT_N+2)]:={|this| errorstr(this)}
   pOsztaly[(CM_OBJECT_N+3)]:={|this| printtostr(this)}
   pOsztaly[(CM_OBJECT_N+4)]:={|this| getstr(this)}
   pOsztaly[(CM_OBJECT_N+5)]:={|this,id,str| copytoken(this,id,str)}
   pOsztaly[(4)]:={|this,id,str,file,line,pos| oinit(this,id,str,file,line,pos)}
return pOsztaly

**********************************************************************
static function setCams(ta,tm)
// Egy t”mb”t felt”lt az oszt ly  ltal def. objektumok attrib£tumaival ‚s m–veleteivel.
   ta[CA_OBJECT_N+1-CA_NIL_N] := {CA_OBJECT_N+1,'id', }
   ta[CA_OBJECT_N+2-CA_NIL_N] := {CA_OBJECT_N+2,'str', }
   ta[CA_OBJECT_N+3-CA_NIL_N] := {CA_OBJECT_N+3,'file', }
   ta[CA_OBJECT_N+4-CA_NIL_N] := {CA_OBJECT_N+4,'line', }
   ta[CA_OBJECT_N+5-CA_NIL_N] := {CA_OBJECT_N+5,'pos', }
   ta[CA_OBJECT_N+6-CA_NIL_N] := {CA_OBJECT_N+6,'classify', }
   ta[CA_OBJECT_N+7-CA_NIL_N] := {CA_OBJECT_N+7,'error', }
   ta[CA_OBJECT_N+8-CA_NIL_N] := {CA_OBJECT_N+8,'eqtype',nil}

   tm[(CM_OBJECT_N+1)-CM_NIL_N] := {(CM_OBJECT_N+1),'iserror','',nil}
   tm[(CM_OBJECT_N+2)-CM_NIL_N] := {(CM_OBJECT_N+2),'errorstr','',nil}
   tm[(CM_OBJECT_N+3)-CM_NIL_N] := {(CM_OBJECT_N+3),'printtostr','',nil}
   tm[(CM_OBJECT_N+4)-CM_NIL_N] := {(CM_OBJECT_N+4),'getstr','',nil}
   tm[(CM_OBJECT_N+5)-CM_NIL_N] := {(CM_OBJECT_N+5),'copytoken','id,str',nil}
   tm[(4)-CM_NIL_N] := {(4),'oinit','id,str,file,line,pos',nil}
return nil

#ifndef _NO_CLTOKEN_
#ifdef _STRICT_PARENT_
#ifdef _CA_CM_ONLY_
#include "meta.och"
#else // _CA_CM_ONLY_
#define _CA_CM_ONLY_
#include "meta.och"
#undef _CA_CM_ONLY_
#endif // _CA_CM_ONLY_
#else
#include "meta.och"
#endif // _STRICT_PARENT_
**********************************************************************
function clTOKEN()
// El“szedi az oszt lyt. (class)
static osztaly
   if (osztaly==nil)
      osztaly:=META.mcTOKENCLASS():onew(;
                  clOBJECT(),;
                  "TOKEN",;
                  CA_TOKEN_N,;
                  CM_TOKEN_N,;
                  {|ta,tm|setCams(ta,tm)},;
                  {|t|setCMethods(t)})
   endif
return osztaly
#endif // _NO_CLTOKEN_

#ifndef _NO_TOKENCLASS_

**********************************************************************
#xtranslate class:<m> => TOKENCLASS.(class):<m>

#xcommand cimplement onew(id,str,file,line,pos) => ;
                    static function onew(class,id,str,file,line,pos)
#xcommand cimplement onewerror(id,str,file,line,pos,error) => ;
                    static function onewerror(class,id,str,file,line,pos,error)
#xcommand cimplement oinitclass()   => static function oinitclass(class)
#xcommand cimplement copyfromtoken(t,id,str) => ;
                    static function copyfromtoken(class,t,id,str)
#xcommand cimplement findclassify(str) => ;
                    static function findclassify(class,str)

#ifdef _IMPLEMENT_EXPORT_
#xcommand cimplement export onew(id,str,file,line,pos) => ;
                    function onew(class,id,str,file,line,pos)
#xcommand cimplement export onewerror(id,str,file,line,pos,error) => ;
                    function onewerror(class,id,str,file,line,pos,error)
#xcommand cimplement export oinitclass()   => function oinitclass(class)
#xcommand cimplement export copyfromtoken(t,id,str) => ;
                    function copyfromtoken(class,t,id,str)
#xcommand cimplement export findclassify(str) => ;
                    function findclassify(class,str)
#endif // _IMPLEMENT_EXPORT_

#xtranslate superclass:oinit            => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(4))
#xtranslate superclass:getclass         => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(5))
#xtranslate superclass:isclass          => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(6))
#xtranslate superclass:getattrib        => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(7))
#xtranslate superclass:setattrib        => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(8))
#xtranslate superclass:onew             => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(CM_OBJECT_N+1))
#xtranslate superclass:ocreate          => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(CM_OBJECT_N+2))
#xtranslate superclass:rawoinit         => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(CM_OBJECT_N+3))
#xtranslate superclass:oinitclass       => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(CM_OBJECT_N+4))
#xtranslate superclass:getmethodsimplement  => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(CM_OBJECT_N+5))
#xtranslate superclass:attribidx        => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(CM_OBJECT_N+6))
#xtranslate superclass:needclassid      => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(CM_OBJECT_N+7))
#xtranslate superclass:isinheritfrom    => (OBJGENM.(eval(BEHAVIOR.clBEHAVIOR():objmethodsimplement)).(class):(CM_OBJECT_N+8))

**********************************************************************
static function setMCMethods(pOsztaly)
// Egy t”mb”t felt”lt a metaoszt ly m–veleti blokkjaival.
   pOsztaly[(CM_OBJECT_N+1)]:={|class,id,str,file,line,pos| onew(class,id,str,file,line,pos)}
   pOsztaly[(CM_BEHAVIOR_N+1)]:={|class,id,str,file,line,pos,error| onewerror(class,id,str,file,line,pos,error)}
   pOsztaly[(CM_OBJECT_N+4)]:={|class| oinitclass(class)}
   pOsztaly[(CM_BEHAVIOR_N+2)]:={|class,t,id,str| copyfromtoken(class,t,id,str)}
   pOsztaly[(CM_BEHAVIOR_N+3)]:={|class,str| findclassify(class,str)}
return pOsztaly

**********************************************************************
static function setMCams(ta,tm)
// Egy t”mb”t felt”lt a metaoszt ly  ltal def. objektumok attrib£tumaival ‚s m–veleteivel.
   ta[CA_BEHAVIOR_N+1-CA_NIL_N] := {CA_BEHAVIOR_N+1,'errstrarray',nil}
   ta[CA_BEHAVIOR_N+2-CA_NIL_N] := {CA_BEHAVIOR_N+2,'equivclass',nil}

   tm[(CM_OBJECT_N+1)-CM_NIL_N] := {(CM_OBJECT_N+1),'onew','id,str,file,line,pos',nil}
   tm[(CM_BEHAVIOR_N+1)-CM_NIL_N] := {(CM_BEHAVIOR_N+1),'onewerror','id,str,file,line,pos,error',nil}
   tm[(CM_OBJECT_N+4)-CM_NIL_N] := {(CM_OBJECT_N+4),'oinitclass','',nil}
   tm[(CM_BEHAVIOR_N+2)-CM_NIL_N] := {(CM_BEHAVIOR_N+2),'copyfromtoken','t,id,str',nil}
   tm[(CM_BEHAVIOR_N+3)-CM_NIL_N] := {(CM_BEHAVIOR_N+3),'findclassify','str',nil}
return nil

**********************************************************************
#ifndef _NO_MCTOKENCLASS_
#ifdef _STRICT_PARENT_
#ifdef _CA_CM_ONLY_
#include "meta.och" // "metaclas.och" 
#else // _CA_CM_ONLY_
#define _CA_CM_ONLY_
#include "meta.och" // "metaclas.och" 
#undef _CA_CM_ONLY_
#endif // _CA_CM_ONLY_
#else
#include "meta.och" // "metaclas.och" 
#endif // _STRICT_PARENT_
function mcTOKENCLASS()
// El“szedi az oszt ly metaoszt ly t. (metaclass)
static metaOsztaly
   if (metaOsztaly==nil)
      metaOsztaly:=META.clMETA():onew(;
                  clBEHAVIOR(),;
                  "TOKENCLASS",;
                  CA_TOKENCLASS_N,;
                  CM_TOKENCLASS_N,;
                  {|ta,tm|setMCams(ta,tm)},;
                  {|t|setMCMethods(t)})
   endif
return metaOsztaly
#endif // _NO_MCTOKENCLASS_

#endif // _NO_TOKENCLASS_
#ifdef _IMPLEMENT_ONEW_
**********************************************************************
cimplement onew(id,str,file,line,pos)
local o:=class:ocreate()

    TOKEN.o:oinit(id,str,file,line,pos)
return o
#endif // _IMPLEMENT_ONEW_

**********************************************************************
#ifdef _IMPLEMENT_OINIT_
implement oinit(id,str,file,line,pos)
    super:oinit()
return this
#endif // _IMPLEMENT_OINIT_

**********************************************************************
**********************************************************************
#endif // _TOKEN_PRG_OCH_
#endif // _TOKEN_PRG_
