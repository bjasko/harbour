/*
 * $Id$
 */

/*
 * The following parts are Copyright of the individual authors.
 * www - http://www.harbour-project.org
 *
 * Copyright 1999 Jose Lalin <dezac@corevia.com>
 *    DESCEND() documentation
 *
 * Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>
 *    HB_OEMTOANSI() Documentation
 *    HB_ANSITOOEM() Documentation
 *    ISALPHA()   Documentation
 *    ISDIGIT()   Documentation
 *    ISUPPER()   Documentation
 *    ISLOWER()   Documentation
 *    LTRIM()     Documentation
 *    AT()        Documentation
 *    RAT()       Documentation  
 *    LEFT()      Documentation
 *    RIGHT()     Documentation
 *    SUBSTR()    Documentation  
 *    UPPER()     Documentation  
 *    LOWER()     Documentation
 *
 * See doc/license.txt for licensing terms.
 *
 */

/*  $DOC$
 *  $FUNCNAME$
 *      ISALPHA()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Checks if leftmost character in a string is an alphabetic character
 *  $SYNTAX$
 *      ISALPHA(<cString>) --> lAlpha
 *  $ARGUMENTS$
 *      <cString> Any character string   </par>
 *  $RETURNS$
 *      lAlpha Logical true (.T.) or false (.F.).   </par>
 *  $DESCRIPTION$
 *      This function return a logical true (.T.) if the first character
 *      in <cString> is an alphabetic character.If not, the function will
 *      return a logical false (.F.).   </par>
 *  $EXAMPLES$
 *      QOUT( "isalpha( 'hello' ) = ", isalpha( 'hello' ) ) 
 *      QOUT( "isalpha( '12345' ) = ", isalpha( '12345' ) ) 
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compliant   </par>
 *  $PLATFORMS$
 *      All      </par>
 *  $SEEALSO$
 *      ISDIGIT(),ISLOWER(),ISUPPER(),LOWER(),UPPER()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      ISDIGIT()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Checks if leftmost character is a digit character
 *  $SYNTAX$
 *      ISDIGIT(<cString>) --> lDigit
 *  $ARGUMENTS$
 *      <cString> Any character string   </par>
 *  $RETURNS$
 *      lDigit Logical true (.T.) or false (.F.).   </par>
 *  $DESCRIPTION$
 *      This function takes the caracter string <cString> and checks to
 *      see if the leftmost character is a digit,from 1 to 9.If so, the
 *      function will return a logical true (.T.);otherwise, it will
 *      return a logical false (.F.).   </par>
 *  $EXAMPLES$
 *      QOUT( "isdigit( '12345' ) = ", isdigit( '12345' ) ) 
 *      QOUT( "isdigit( 'abcde' ) = ", isdigit( 'abcde' ) ) 
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compliant   </par>
 *  $PLATFORMS$
 *      All   </par>
 *  $SEEALSO$
 *      ISALPHA(),ISLOWER(),ISUPPER(),LOWER(),UPPER()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      ISUPPER()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Checks if leftmost character is an uppercased letter.
 *  $SYNTAX$
 *      ISUPPER(<cString>) --> lUpper
 *  $ARGUMENTS$
 *      <cString> Any character string   </par>
 *  $RETURNS$
 *      lUpper Logical true (.T.) or false (.F.).   </par>
 *  $DESCRIPTION$
 *      This function takes the caracter string <cString> and checks to
 *      see if the leftmost character is a uppercased letter.If so, the
 *      function will return a logical true (.T.);otherwise, it will
 *      return a logical false (.F.).   </par>
 *  $EXAMPLES$
 *      QOUT( "isupper( 'Abcde' ) = ", isupper( 'Abcde' ) ) 
 *      QOUT( "isupper( 'abcde' ) = ", isupper( 'abcde' ) ) 
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compliant   </par>
 *  $PLATFORMS$
 *      All    </par>
 *  $SEEALSO$
 *      ISALPHA(),ISLOWER(),ISDIGIT(),LOWER(),UPPER()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      ISLOWER()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Checks if leftmost character is an lowercased letter.
 *  $SYNTAX$
 *      ISLOWER(<cString>) --> lLower
 *  $ARGUMENTS$
 *      <cString> Any character string   </par>
 *  $RETURNS$
 *      lLower Logical true (.T.) or false (.F.).   </par>
 *  $DESCRIPTION$
 *      This function takes the caracter string <cString> and checks to
 *      see if the leftmost character is a lowercased letter.If so, the
 *      function will return a logical true (.T.);otherwise, it will
 *      return a logical false (.F.).   </par>
 *  $EXAMPLES$
 *      QOUT( "islower( 'Abcde' ) = ", islower( 'Abcde' ) ) 
 *      QOUT( "islower( 'abcde' ) = ", islower( 'abcde' ) ) 
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compliant   </par>
 *  $PLATFORMS$
 *      All   </par>
 *  $SEEALSO$
 *      ISALPHA(),ISDIGIT(),ISUPPER(),LOWER(),UPPER()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      LTRIM()
 *  $CATEGORY$
 *      Strings   
 *  $ONELINER$
 *      Removes leading spaces from a string 
 *  $SYNTAX$
 *      LTRIM(<cString>)   --> <cReturn>
 *  $ARGUMENTS$
 *      <cString>  Character expression with leading spaces   </par>
 *  $RETURNS$
 *      <cReturn>  The same character expression with leading spaces removed   </par>
 *  $DESCRIPTION$
 *      This function trims the leading space blank   </par>
 *  $EXAMPLES$
 *      ? QOUT( LTRIM("HELLO     "))
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This functions is CA-CLIPPER compatible   </par>
 *  $PLATFORMS$
 *      All  </par>
 *  $SEEALSO$
 *      TRIM(),RTRIM(),ALLTRIM()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      AT()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Locates the position of a substring in a main string.
 *  $SYNTAX$
 *      AT(<cSearch>,<cString>) --> nPos
 *  $ARGUMENTS$
 *      <cSearch>  Substring to search for   </par>
 *      <cString>  Main string   </par>
 *  $RETURNS$
 *      AT() return the starting position of the first occurrence of the
 *      substring in the main string   </par>
 *  $DESCRIPTION$
 *      This function searches the string <cString> for the characters in
 *      the first string <cSearch>. If the substring is not contained within
 *      the second expression,the function will return 0.   </par>
 *  $EXAMPLES$
 *      QOUT( "at( 'cde', 'abcdefgfedcba' ) = '" +;
 *      at( 'cde', 'abcsefgfedcba' ) + "'" )
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compatible.   </par>
 *  $PLATFORMS$
 *      All   </par>
 *  $SEEALSO$
 *      RAT()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      RAT()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Searches for a substring from the right side of a string.
 *  $SYNTAX$
 *      RAT(<cSearch>,<cString>) --> nPos    </par>
 *  $ARGUMENTS$
 *      <cSearch>  Substring to search for   </par>
 *      <cString>  Main string   </par>
 *  $RETURNS$
 *      RAT() return the location of beginnig position.   </par>
 *  $DESCRIPTION$
 *      This function searches througt <cString> for the first existence
 *      of <cSearch>.The search operation is performed from the right side
 *      of <cString> to the left. If the function is unable to find any
 *      occurence of <cSearch> in <cString>,the value of the function will be 0.    </par>
 *  $EXAMPLES$
 *      QOUT( "rat( 'cde', 'abcdefgfedcba' ) = '" +;
 *      rat( 'cde', 'abcsefgfedcba' ) + "'" )
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Will not work with a search string > 64 KB on some platforms   </par>
 *  $PLATFORMS$
 *      All   </par>
 *  $SEEALSO$
 *      AT(),SUBSTR(),RIGHT()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      LEFT()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Extract the leftmost substring of a character expression
 *  $SYNTAX$
 *      LEFT(<cString>,<nPos>) --> <cReturn>
 *  $ARGUMENTS$
 *      <cString> Main character to be parsed   </par>
 *      <nPos>    Number of bytes to return beggining at the leftmost position   </par>
 *  $RETURNS$
 *      <cReturn>  Substring of evaluation   </par>
 *  $DESCRIPTION$
 *      This functions returns the leftmost <nPos> characters of <cString>.   </par>
 *      It is equivalent to the following programing expression:
 *          SUBSTR(<cString>,1,<nPos>   </par>
 *  $EXAMPLES$
 *      ? QOUT(LEFT('HELLO HARBOUR',5))
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This functions is CA CLIPPER compatible   </par>
 *  $PLATFORMS$
 *      All   </par>
 *  $SEEALSO$
 *      SUBSTR(),RIGHT(),AT(),RAT()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      RIGHT()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Extract the rightmost substring of a character expression
 *  $SYNTAX$
 *      SUBSTR(<cString>,<nPos>) --> <cReturn>
 *  $ARGUMENTS$
 *      <cString> Character expression to be parsed   </par>
 *      <nPos>    Number of bytes to return beggining at the rightmost position   </par>
 *  $RETURNS$
 *      <cReturn>  Substring of evaluation   </par>
 *  $DESCRIPTION$
 *      This functions returns the rightmost <nPos> characters of <cString>.   </par>
 *  $EXAMPLES$
 *      ? QOUT(RIGHT('HELLO HARBOUR',5))
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This functions is CA CLIPPER compatible   </par>
 *  $PLATFORMS$
 *      All   </par>
 *  $SEEALSO$
 *      SUBSTR(),LEFT(),AT(),RAT()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      SUBSTR()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Returns a substring from a main string
 *  $SYNTAX$
 *      SUBSTR(<cString>,<nStart>[,<nLen>)] --> <cReturn>
 *  $ARGUMENTS$
 *      <cString> Character expression to be parsed   </par>
 *      <nStart>  Start position   </par>
 *      <nLen>    Number of characters to return    </par>
 *  $RETURNS$
 *      <cReturn>  Substring of evaluation   </par>
 *  $DESCRIPTION$
 *      This functions returns a character string formed from <cString>,
 *      starting at the position of <nStart> and continuing on for a
 *      lenght of <nLen> characters. If <nLen> is not specified, the value
 *      will be all remaining characters from the position of <nStart>.   </par>

 *      The value of <nStart> may be negative. If it is, the direction of
 *      operation is reversed from a default of left-to-right to right-to-left
 *      for the number of characters specified in <nStart>.   </par>
 *  $EXAMPLES$
 *      FUNCTION MAIN()
 *      LOCAL X:=REPLICATE('ABCD',70000)
 *
 *      ? QOUT(SUBSTR(X,65519,200)
 *
 *      RETURN NIL
 *  </fixed>
 *  $TESTS$
 *      ? QOUT(SUBSTR('HELLO HARBOUR',5)
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This functions is CA CLIPPER compatible with the execption that
 *      CA CLIPPER will generate an error if the passed string is >65519 bytes
 *      and Harbour depends of plataform.   </par>
 *  $PLATFORMS$
 *      All    </par>
 *  $SEEALSO$
 *     LEFT(),AT(),RIGHT()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      STR()
 *  $CATEGORY$
 *      Run-time Library, Strings
 *  $ONELINER$
 *      Convert a numeric expression to a character string.
 *  $SYNTAX$
 *      STR(<nNumber>, [<nLength>], [<nDecimals>]) --> cNumber
 *  $ARGUMENTS$
 *      <nNumber> is the numeric expression to be converted to a character
 *      string.   </par>
 *      <nLength> is the length of the character string to return, including
 *      decimal digits, decimal point, and sign.   </par>
 *      <nDecimals> is the number of decimal places to return.   </par>
 *  $RETURNS$
 *      STR() returns <nNumber> formatted as a character string.  If the
 *      optional length and decimal arguments are not specified, STR()
 *      returns the character string according to the following rules:   </par>
 *
 *      Results of STR() with No Optional Arguments   </par>
 *      ---------------------------------------------------------------   </par>
 *      Expression               Return Value Length   </par>
 *      ---------------------------------------------------------------   </par>
 *      Field Variable           Field length plus decimals   </par>
 *      Expressions/constants    Minimum of 10 digits plus decimals   </par>
 *      VAL()                    Minimum of 3 digits   </par>
 *      MONTH()/DAY()            3 digits   </par>
 *      YEAR()                   5 digits   </par>
 *      RECNO()                  7 digits   </par>
 *      ---------------------------------------------------------------   </par>
 *  $DESCRIPTION$
 *      STR() is a numeric conversion function that converts numeric values
 *      to character strings. It is commonly used to concatenate numeric values
 *      to character strings. STR() has applications displaying numbers,
 *      creating codes such as part numbers from numeric values, and creating
 *      index keys that combine numeric and character data.   </par>
 *
 *      STR() is like TRANSFORM(), which formats numeric values as character
 *      strings using a mask instead of length and decimal specifications.   </par>
 *
 *      The inverse of STR() is VAL(), which converts character numbers to
 *      numerics.   </par>
 *
 *      *  If <nLength> is less than the number of whole number digits in
 *         <nNumber>, STR() returns asterisks instead of the number.   </par>
 *
 *      *  If <nLength> is less than the number of decimal digits
 *         required for the decimal portion of the returned string, Harbour
 *         rounds the number to the available number of decimal places.   </par>
 *
 *      *  If <nLength> is specified but <nDecimals> is omitted (no
 *         decimal places), the return value is rounded to an integer.   </par>
 *  $EXAMPLES$
 *      ? STR( 10, 6, 2 ) // " 10.00"
 *      ? STR( -10, 8, 2 ) // "  -10.00"
 *      </fixed>
 *  $TESTS$
 *      see the regression test suit for comprehensive tests.
 *          </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      CA-Clipper compatible.   </par>
 *  $SEEALSO$
 *      STRZERO(),VAL()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      STRZERO()
 *  $CATEGORY$
 *      Run-time Library, Strings
 *  $ONELINER$
 *      Convert a numeric expression to a character string, zero padded.
 *  $SYNTAX$
 *      STRZERO(<nNumber>, [<nLength>], [<nDecimals>]) --> cNumber
 *  $ARGUMENTS$
 *      <nNumber> is the numeric expression to be converted to a character
 *      string.   </par>
 *      <nLength> is the length of the character string to return, including
 *      decimal digits, decimal point, and sign.   </par>
 *      <nDecimals> is the number of decimal places to return.   </par>
 *  $RETURNS$
 *      STRZERO() returns <nNumber> formatted as a character string.  If the
 *      optional length and decimal arguments are not specified, STRZERO()
 *      returns the character string according to the following rules:   </par>
 *
 *      Results of STRZERO() with No Optional Arguments   </par>
 *      ---------------------------------------------------------------   </par>
 *      Expression               Return Value Length   </par>
 *      ---------------------------------------------------------------   </par>
 *      Field Variable           Field length plus decimals   </par>
 *      Expressions/constants    Minimum of 10 digits plus decimals   </par>
 *      VAL()                    Minimum of 3 digits   </par>
 *      MONTH()/DAY()            3 digits   </par>
 *      YEAR()                   5 digits   </par>
 *      RECNO()                  7 digits   </par>
 *      ---------------------------------------------------------------   </par>
 *  $DESCRIPTION$
 *      STRZERO() is a numeric conversion function that converts numeric values
 *      to character strings. It is commonly used to concatenate numeric values
 *      to character strings. STRZERO() has applications displaying numbers,
 *      creating codes such as part numbers from numeric values, and creating
 *      index keys that combine numeric and character data.   </par>
 *
 *      STRZERO() is like TRANSFORM(), which formats numeric values as character
 *      strings using a mask instead of length and decimal specifications.   </par>
 *
 *      The inverse of STRZERO() is VAL(), which converts character numbers to
 *      numerics.   </par>
 *
 *      *  If <nLength> is less than the number of whole number digits in
 *         <nNumber>, STR() returns asterisks instead of the number.   </par>
 *
 *      *  If <nLength> is less than the number of decimal digits
 *         required for the decimal portion of the returned string, Harbour
 *         rounds the number to the available number of decimal places.   </par>
 *
 *      *  If <nLength> is specified but <nDecimals> is omitted (no
 *         decimal places), the return value is rounded to an integer.   </par>
 *  $EXAMPLES$
 *      ? STRZERO( 10, 6, 2 ) // "010.00"
 *      ? STRZERO( -10, 8, 2 ) // "-0010.00"
 *  </fixed>
 *  $TESTS$
 *      see the regression test suit for comprehensive tests.
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      CA-Clipper compatible (it was not mentioned in the docs though).   </par>
 *  $SEEALSO$
 *      STR(),VAL()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      HB_VALTOSTR()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Converts any scalar type to a string.
 *  $SYNTAX$
 *      HB_VALTOSTR( <xValue> ) --> cString
 *  $ARGUMENTS$
 *      <xValue> is any scalar argument.   </par>
 *  $RETURNS$
 *      <cString>  A string representation of <xValue> using default conversions.   </par>
 *  $DESCRIPTION$
 *      HB_VALTOSTR can be used to convert any scalar value to a string.   </par>
 *  $EXAMPLES$
 *      ? HB_VALTOSTR( 4 )
 *      ? HB_VALTOSTR( "String" )
 *  </fixed>
 *  $TESTS$
 *      ? HB_VALTOSTR( 4 ) == "         4"
 *      ? HB_VALTOSTR( 4.0 / 2 ) == "         2.00"
 *      ? HB_VALTOSTR( "String" ) == "String"
 *      ? HB_VALTOSTR( CTOD( "01/01/2001" ) ) == "01/01/01"
 *      ? HB_VALTOSTR( NIL ) == "NIL"
 *      ? HB_VALTOSTR( .F. ) == ".F."
 *      ? HB_VALTOSTR( .T. ) == ".T."
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      HB_VALTOSTR() is a Harbour enhancement.   </par>
 *  $SEEALSO$
 *      STR(),VAL()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      LEN()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Returns size of a string or size of an array.
 *  $SYNTAX$
 *      LEN( <cString> | <aArray> ) --> <nLength>
 *  $ARGUMENTS$
 *      <acString> is a character string or the array to check.   </par>
 *  $RETURNS$
 *      The length of the string or the number of elements that contains
 *      an array.   </par>
 *  $DESCRIPTION$
 *      This function returns the string length or the size of an array. If
 *      it is used with a multidimensional array it returns the size of the
 *      first dimension.   </par>
 *  $EXAMPLES$
 *      ? Len( "Harbour" ) --> 7
 *      ? Len( { "One", "Two" } ) --> 2
 *  </fixed>
 *  $TESTS$
 *      function Test()
 *         LOCAL cName := ""
 *         ACCEPT "Enter your name: " TO cName
 *         ? Len( cName )
 *      return nil
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      LEN() is fully CA-Clipper compliant.   </par>
 *  $SEEALSO$
 *      EMPTY(),RTRIM(),LTRIM(),AADD(),ASIZE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      EMPTY()
 *  $CATEGORY$
 *      Conversion
 *  $ONELINER$
 *      Checks if the passed argument is empty.
 *  $SYNTAX$
 *      EMPTY( <xExp> ) --> <lIsEmpty>
 *  $ARGUMENTS$
 *      <xExp> is any valid expression.   </par>
 *  $RETURNS$
 *      A logical value. It is true (.T.) if the passed argument is empty
 *      otherwise it is false (.F.).   </par>
 *  $DESCRIPTION$
 *      This function checks if an expression has empty value and returns a
 *      logical indicating whether it the expression is empty or not.   </par>
 *  $EXAMPLES$
 *      ? Empty( "I'm not empty" )
 *  </fixed>
 *  $TESTS$
 *      function Test()
 *         ? Empty( 1 )       --> .f.
 *         ? Empty( Date() )  --> .f.
 *         ? Empty( .f. )     --> .t.
 *      return nil
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      EMPTY() is fully CA-Clipper compliant.   </par>
 *  $SEEALSO$
 *      LEN()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      DESCEND()
 *  $CATEGORY$
 *      Conversion
 *  $ONELINER$
 *      Inverts an expression of string, logical, date or numeric type.
 *  $SYNTAX$
 *      DESCEND( <xExp> ) --> <xExpInverted>
 *  $ARGUMENTS$
 *      <xExp> is any valid expression.   </par>
 *  $RETURNS$
 *      Inverted value of the same type as passed.   </par>
 *  $DESCRIPTION$
 *      This function converts an expression in his inverted form. It is
 *      useful to build descending indexes.   </par>
 *  $EXAMPLES$
 *      // Seek for Smith in a descending index
 *      SEEK DESCEND( "SMITH" )
 /    </fixed>
 *  $TESTS$
 *      DATA->( DBSEEK( DESCEND( "SMITH" ) ) )
 *      will seek "SMITH" into a descending index.
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      DESCEND() is fully CA-Clipper compliant.   </par>
 *  $SEEALSO$
 *       INDEX,SEEK
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      HB_ANSITOOEM()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Convert a windows Character to a Dos based character
 *  $SYNTAX$
 *      HB_ANSITOOEM(<cString>)  -> cDosString
 *  $ARGUMENTS$
 *      <cString>  Windows ansi string to convert to DOS oem String   </par>
 *  $RETURNS$
 *      <cDosString> Dos based  string   </par>
 *  $DESCRIPTION$
 *      This function converts each character in <cString> to the corresponding
 *      character in the MS-DOS (OEM) character set.The character expression
 *      <cString> should contain characters from the ANSI character set.
 *      If a character in <cString> doesn't have a MS-DOS equivalent, the
 *      character is converted to a similar MS-DOS character.   </par>
 *  $EXAMPLES$
 *      ? HB_OEMTOANSI("Harbour")
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is a Harbour extension   </par>
 *  $PLATFORMS$
 *      This functions work only on Windows Plataform   </par>
 *  $SEEALSO$
 *      HB_OEMTOANSI()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      HB_OEMTOANSI()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Convert a DOS(OEM) Character to a WINDOWS (ANSI) based character
 *  $SYNTAX$
 *      HB_OEMTOANSI(<cString>)  -> cDosString
 *  $ARGUMENTS$
 *      <cString>  DOS (OEM)  string to convert to WINDOWS (ANSI) String   </par>
 *  $RETURNS$
 *      <cDosString> WINDOWS based  string   </par>
 *  $DESCRIPTION$
 *      This function converts each character in <cString> to the corresponding
 *      character in the Windows (ANSI) character set.The character expression
 *      <cString> should contain characters from the OEM character set.
 *      If a character in <cString> doesn't have a ANSI equivalent, the
 *      character is remais the same.   </par>
 *  $EXAMPLES$
 *      ? HB_OEMTOANSI("Harbour")
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is a Harbour extension   </par>
 *  $PLATFORMS$
 *      This functions work only on Windows Plataform   </par>
 *  $SEEALSO$
 *      HB_ANSITOOEM()
 *  $END$
 */


/*  $DOC$
 *  $FUNCNAME$
 *      LOWER()
 *  $CATEGORY$
 *      Strings()
 *  $ONELINER$
 *      Universally lowercases a character string expression.
 *  $SYNTAX$
 *      LOWER( <cString> ) --> cLowerString
 *  $ARGUMENTS$
 *      <cString> Any character expression.     </par>
 *  $RETURNS$
 *      <cLowerString> Lowercased value of <cString>   </par>
 *  $DESCRIPTION$
 *      This function converts any character expression passes as <cString>
 *      to its lowercased representation.Any nonalphabetic character withing
 *      <cString> will remain unchanged.   </par>
 *  $EXAMPLES$
 *      ? Lower("HARBOUR")
 *      ? Lower("Hello All")
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compatible   </par>
 *  $PLATFORMS$
 *      ALL   </par>
 *  $SEEALSO$
 *      UPPER(),ISLOWER(),ISUPPER()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      UPPER()
 *  $CATEGORY$
 *      Strings
 *  $ONELINER$
 *      Converts a character expression to uppercase format
 *  $SYNTAX$
 *      UPPER( <cString> ) --> cUpperString
 *  $ARGUMENTS$
 *      <cString> Any character expression.     </par>
 *  $RETURNS$
 *      <cUpperString> Uppercased value of <cString>   </par>
 *  $DESCRIPTION$
 *      This function converts all alpha characters in <cString> to upper
 *      case values and returns that formatted character expression.   </par>
 *  $EXAMPLES$
 *      ? UPPER("harbour")
 *      ? UPPER("Harbour")
 *  </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compatible   </par>
 *  $PLATFORMS$
 *      All   </par>
 *  $SEEALSO$
 *      LOWER(),ISUPPER(),ISLOWER()
 *  $END$
 */

