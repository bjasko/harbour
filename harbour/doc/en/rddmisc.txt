/*
 * $Id$
 */

/*
 * The following parts are Copyright of the individual authors.
 * www - http://www.harbour-project.org
 *
 * Copyright 1999 Luiz Rafael Culik <culik@sl.conex.net>
 *    DB*() documentation
 *    ORD*() documentation
 *    RDD*() documentation
 *
 * See doc/license.txt for licensing terms.
 *
 */

/*  $DOC$
 *  $FUNCNAME$
 *     AFIELDS()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Fills referenced arrays with database field information
 *  $SYNTAX$
 *      AFields(<aNames>[,<aTypes>][,<aLen>][,<aDecs>]) --> <nFields>
 *  $ARGUMENTS$
 *      <aNames>  Array of field names
 *
 *      <aTypes>  Array of field names
 *
 *      <aLens>  Array of field names
 *
 *      <aDecs>  Array of field names
 *  $RETURNS$
 *      <nFields> Number od fields in a database or work area
 *  $DESCRIPTION$
 *      This function will fill a series of arrays with field
 *      names,field types,field lenghts, and number of field
 *      decimal positions for the currently selected or designed
 *      database. Each array parallels the different descriptors
 *      of a file's structure.The first array will consist of the
 *      names of the fields in the current work area.All other arrays
 *      are optional and will be filled with the corrensponding data.
 *      This function will return zero if no parameters are specified
 *      or if no database is avaliable in the current work area.Otherwise,
 *      the number of fields or the lenght of the shortest array argument,
 *      witchever is smaller, will be returned.
 *  $EXAMPLES$
 *      FUNCTION Main()
 *         LOCAL aNames:={},aTypes:={},aLens:={},aDecs:={},nFields:=0
 *
 *         USE Test
 *
 *         dbGoTop()
 *         nFields:=aFields(aNames,aTypes,aLens,aDecs)
 *
 *         ? "Number of fields", nFields
 *
 *         RETURN NIL
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      AFIELDS() is fully CA-Clipper compliant.
 *  $FILES$
 *      Library is rdd
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *     ALIAS()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Returns the alias name of a work area
 *  $SYNTAX$
 *      Alias([<nWorkArea>]) --> <cWorkArea>
 *  $ARGUMENTS$
 *      <nWorkArea> Number of a work area
 *  $RETURNS$
 *      <cWorkArea> Name of alias
 *  $DESCRIPTION$
 *      This function returns the alias of the work area indicated by <nWorkArea>
 *      If <nWorkArea> is not provided, the alias of the current work area is
 *      returned.
 *  $EXAMPLES$
 *      FUNCTION Main()
 *
 *      USE Test
 *      select 0
 *      qOut( IF(Alias()=="","No Name",Alias()))
 *      Test->(qOut(Alias())
 *      qOut(Alias(1))
 *
 *      RETURN NIL
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      ALIAS() is fully CA-Clipper compliant.
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      DBF()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *     BOF()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Test for the beggining-of-file condition
 *  $SYNTAX$
 *      BOF() --> <lBegin>
 *  $RETURNS$
 *      BOF() Logical true (.T.) or false (.F.)
 *  $DESCRIPTION$
 *      This function determines if the beggining of the file marker has been
 *      reached. If so, the function will return a logical true (.T.); otherwise,
 *      a logical false(.F.) will be returned.
 *      By default, BOF() will apply to the currently selected database unless
 *      the function is preceded by an alias
 *  $EXAMPLES$
 *      FUNCTION Main()
 *        USE Tests NEW
 *        DBGOTOP()
 *        ? "Is Eof()",EOF()
 *        DBGOBOTTOM()
 *        ? "Is Eof()",EOF()
 *        USE
 *     RETURN NIL
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      BOF() is fully CA-Clipper compliant.
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *    EOF(),FOUND(),LASTREC()
 *  $END$
 */

/*  $DOC$
 *  $COMMANDNAME$
 *      ZAP
 *  $CATEGORY$
 *      Command
 *  $ONELINER$
 *      Remove all records from the current database file
 *  $SYNTAX$
 *      ZAP
 *  $DESCRIPTION$
 *      This command removes all of the records from the database in the
 *      current work area.This operation also updates any index file in
 *      use at the time of this operation.In addition, this command removes
 *      all items within an associated memo file.
 *      In a network enviroment,any file that is about to be ZAPped must
 *      be used exclusively.
 *  $EXAMPLES$
 *      USE Tests NEW index Tests
 *      ZAP
 *      USE
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This command is CA Clipper compliant
 *  $SEEALSO$
 *      DELETE,PACK,USE
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      DELETED()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Tests the record's deletion flag.
 *  $SYNTAX$
 *      DELETED() --> lDeleted
 *  $RETURNS$
 *      DELETED() return a logical true (.T.) or false (.F.).
 *  $DESCRIPTION$
 *      This function returns a logical true (.T.) is the current record in the
 *      selected or designated work area ha ben marked for deletion.If not, the
 *      function will return a logical false (.F.).
 *  $EXAMPLES$
 *      FUNCTION Main()
 *      USE Test New
 *      DBGOTO()
 *      DBDELETE()
 *      ? "Is Record Deleted",Test->(DELETED())
 *      DBRECALL()
 *      USE
 *      RETURN NIL
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compliant
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      DBDELETE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      EOF()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Test for end-of-file condition.
 *  $SYNTAX$
 *      EOF() --> <lEnd>
 *  $RETURNS$
 *      <lEnd> A logical true (.T.) or false (.F.)
 *  $DESCRIPTION$
 *      This function determines if the end-of-file marker has been reached.
 *      If it has, the function will return a logical true (.T.); otherwise
 *      a logical false (.F.) will be returnd
 *  $EXAMPLES$
 *      FUNCTION Main()
 *        USE Tests NEW
 *        DBGOTOP()
 *        ? "Is Eof()",EOF()
 *        DBGOBOTTOM()
 *        ? "Is Eof()",EOF()
 *        USE
 *     RETURN NIL
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      EOF() is fully CA-Clipper compliant.
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *    BOF(),FOUND(),LASTREC()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FCOUNT()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Counts the number of fields in an active database.
 *  $SYNTAX$
 *      FCOUNT() --> nFields
 *  $RETURNS$
 *      <nFields> Return the number of fields
 *  $DESCRIPTION$
 *      This function returns the number of fields in the current or designated
 *      work area.If no database is open in this work area, the function will
 *      return 0.
 *  $EXAMPLES$
 *      FUNCTION Main()
 *        USE Tests NEW
 *        ? "This database have ",Tests->(FCOUNT()),"Fields"
 *        USE
 *      RETURN Nil
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compliant
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      FIELDNAME(),TYPE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FIELDGET()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Obtains the value  of a specified field
 *  $SYNTAX$
 *      FIELDGET(<nField>) --> ValueField
 *  $ARGUMENTS$
 *      <nField> Is the numeric field position
 *  $RETURNS$
 *      <ValueField>  Any expression
 *  $DESCRIPTION$
 *      This function returns the value of the field at the <nField>th location
 *      in the selected or designed work area.If the value in <nField> does not
 *      correspond to n avaliable field position in this work area, the function
 *      will return a NIL data type.
 *  $EXAMPLES$
 *      FUNCTION Main()
 *      USE Test NEW
 *      ? Test->(FieldGet(1))
 *      USE
 *      RETURN NIL
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper Compliant.
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      FIELDPUT()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FIELDNAME()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Return the name of a field at a numeric field location.
 *  $SYNTAX$
 *      FIELDNAME/FIELD(<nPosition>) --> cFieldName
 *  $ARGUMENTS$
 *      <nPosition> Field order in the database.
 *  $RETURNS$
 *      <cFieldName> returns the field name.
 *  $DESCRIPTION$
 *      This function return the name of the field at the <nPosition>th position.
 *      If the numeric value passed to this function does not correspond to an
 *      existing field in the designated or selected work area,this function
 *      will return a NULL byte.
 *  $EXAMPLES$
 *      FUNCTION Main()
 *        LOCAL x
 *        USE Tests NEW
 *        FOR x := 1 to Tests->(FCOUNT())
 *          ? "Field Name",FieldName(x)
 *        NEXT
 *        USE
 *      RETURN Nil
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compatible.
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *    DBSTRUCT(),FCOUNT(),LEN(),VALTYPE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FIELDPOS()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Return the ordinal position of a field.
 *  $SYNTAX$
 *      FIELDPOS(<cFieldName>) --> nFieldPos
 *  $ARGUMENTS$
 *      <cFieldName> Name of a field.
 *  $RETURNS$
 *      <nFieldPos> is ordinal position of the field.
 *  $DESCRIPTION$
 *      This function return the ordinal position of the specified field <cField>
 *      in the current or aliased work areaIf there isn't  field under the name
 *      of <cField> or of no database is open in the selected work area, the func-
 *      tion will return a 0.
 *  $EXAMPLES$
 *      FUNCTION Main()
 *      USE Test NEW
 *      ? Test->(FIELDPOS("ID"))
 *      USE
 *      RETURN NIL
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compliant.
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      FIELDGET(),FIELDPUT()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FIELDPUT()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Set the value of a field variable
 *  $SYNTAX$
 *      FIELDPUT(<nField>, <expAssign>) --> ValueAssigned
 *  $ARGUMENTS$
 *      <nField> The field numeric position
 *  
 *      <expAssign> Expression to be assigned to the specified field
 *  $RETURNS$
 *      <ValueAssigned> Any expression
 *  $DESCRIPTION$
 *      This function assings the value in <expAssing> to the <nField>th
 *      field in the current or designated work area.If the operation is
 *      successful,the return value of the function will be the same value
 *      assigned to the specified field.If the operation is not successful,
 *      the function will return a NIL data type
 *  $EXAMPLES$
 *      USE Tests New
 *      FIELDPUT(1,"Mr. Jones")
 *      USE
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compatible.
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      FIELDGET()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FLOCK()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Locks a file
 *  $SYNTAX$
 *      FLOCK() --> lSuccess
 *  $RETURNS$
 *      <lSuccess> A true (.T.) value, if the lock was successful;otherwise
 *      false (.F.)
 *  $DESCRIPTION$
 *      This function returns a logical true (.T.0 if a file lock is
 *      attempted and is successfully placed on the current or designated
 *      database.This function will also unlock all records locks placed
 *      by the same network station.
 *  $EXAMPLES$
 *      USE Tests New
 *      IF FLOCK()
 *         SUM Tests->Ammount
 *      ENDIF
 *      USE
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compatible
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      RLOCK()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FOUND()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Determine the success of a previous search operation.
 *  $SYNTAX$
 *      FOUND() --> lSuccess
 *  $ARGUMENTS$
 *      None.
 *  $RETURNS$
 *      <lSuccess> A logical true (.T.) is successful;otherwise, false (.F.)
 *  $DESCRIPTION$
 *      This function is used to test if the previous SEEK,LOCATE,CONTINUE,
 *      or FIND operation was successful.Each wrk area has its own FOUND()
 *      flag,so that a FOUND() condition may be tested in unselected work
 *      areas by using an alias.
 *  $EXAMPLES$
 *      nId:=100
 *      USE Tests NEW INDEX Tests
 *      SEEK nId
 *      IF FOUND()
 *        ? Tests->Name
 *      ENDIF
 *      USE
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compatible
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      EOF()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      HEADER()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Return the length of a database file header 
 *  $SYNTAX$
 *      HEADER() --> nBytes
 *  $RETURNS$
 *      <nBytes> The numeric size of a database file header in bytes
 *  $DESCRIPTION$
 *      This function returns the number of bytes in the header of the
 *      selected database ot the database in the designated work area.
 *
 *      If used in conjunction with the LASTREC(),RECSIZE() and DISKSPACE()
 *      functions,this functions is capable of implementing a backup and
 *      restore routine.
 *  $EXAMPLES$
 *      USE Tests New
 *      ? Header()
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compatible
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      DISKSPACE(),LASTREC(),RECSIZE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      LASTREC()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Returns the number of records in an active work area or database.
 *  $SYNTAX$
 *      LASTREC() | RECCOUNT()* --> nRecords
 *  $RETURNS$
 *      <nRecords > The number of records
 *  $DESCRIPTION$
 *      This function returns the number of records present in the database
 *      in the selected or designated work area.If no records are present
 *      the value of this function will be 0.Additionaly,if no database is
 *      in use in the selected or designated work area,this function will
 *      return a 0 value as well.
 *  $EXAMPLES$
 *      USE Tests NEW
 *      ? LASTREC(), RECCOUNT()
 *  $TESTS$
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA Clipper compatible
 *  $PLATFORMS$
 *      All
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      EOF()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      LUPDATE()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Yields the date the database was last updated.
 *  $SYNTAX$
 *      LUPDATE() --> dModification
 *  $ARGUMENTS$
 *      None
 *  $RETURNS$
 *      <dModification>  The date of the last modification.
 *  $DESCRIPTION$
 *      This function returns the date recorded by the OS when the selected
 *      or designated database was last written to disk.This function will
 *      only work for those database files in USE.
 *  $EXAMPLES$
 *      Function Main
 *
 *      Use Tests New
 *      ? Lupdate() // 04/25/2000
 *      Use
 *      Return Nil
 *  $TESTS$
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA Clipper compliant
 *  $PLATFORMS$
 *      All
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      FIELDNAME(),LASTREC(),RECSIZE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      NETERR()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Tests the success of a network function
 *  $SYNTAX$
 *      NETERR([<lNewError>]) --> lError
 *  $ARGUMENTS$
 *      <lNewError> Is a logical Expression.
 *  $RETURNS$
 *      <lError> A value based on the success of a network operation or
 *      function.
 *  $DESCRIPTION$
 *      This function return a logical true (.T.) is a USE,APPEND BLANK, or
 *      a USE...EXCLUSIVE command is issue and fails in a network enviroment.
 *      In the case of USE and USE...EXCLUSIVE commands,a NETERR() value
 *      of .T. would be returned if another node of the network has the
 *      exclusive use of a file.And the case of the APPEND BLANK command,
 *      NETERR() will return a logical true (.T.) if the file or record
 *      is locked by another node or the value of LASTREC() has been advanced
 *      The value of NETERR() may be changed via the value of <lNewError>.
 *      This allow the run-time error-handling system to control the way
 *      certains errors are handled.
 *  $EXAMPLES$
 *      USE TEST NEW Index Test
 *      If !NetErr()
 *          Seek Test->Name="HARBOUR"
 *          If Found()
 *             ? Test->Name
 *          Endif
 *      Endif
 *      USE
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA Clipper compliant
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      FLOCK(),RLOCK()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      RECCOUNT()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Counts the number of records in a database.
 *  $SYNTAX$
 *      RECCOUNT()* | LASTREC() --> nRecords
 *  $ARGUMENTS$
 *      None.
 *  $RETURNS$
 *      <nRecords>  The number of records
 *  $DESCRIPTION$*
 *      This function returns the number of records present in the database
 *      in the selected or designated work area.If no records are present
 *      the value of this function will be 0.Additionaly,if no database is
 *      in use in the selected or designated work area,this function will
 *      return a 0 value as well.
 *  $EXAMPLES$
 *      Use Test NEW
 *      USE Harbour NEW
 *      ? Reccount()
 *      ? Test->(RECCOUNT())
 *      CLOSE ALL
 *  $TESTS$
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      This function is CA-Clipper compliant
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      EOF(),LASTREC(),RECNO(),DBGOBOTTOM(
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      RECNO()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Returns the current record number or identity.
 *  $SYNTAX$
 *      RECNO() --> Identity
 *  $ARGUMENTS$
 *      None.
 *  $RETURNS$
 *     RECNO() The record number or indentity
 *  $DESCRIPTION$
 *  $EXAMPLES$
 *      USE Tests NEW
 *      DBGOTOP()
 *      RECNO()            // Returns 1
 *      DBGOTO(50)
 *      RECNO()            // Returns 50
 *  $TESTS$
 *  $STATUS$
 *      R
 *  $COMPLIANCE$    
 *      This function is Ca-Clipper compliant
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      DBGOTO()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      RECSIZE()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Determine the record length of a database (.dbf) file
 *  $SYNTAX$
 *      RECSIZE() --> nBytes
 *  $ARGUMENTS$
 *
 *  $RETURNS$
 *     RECSIZE() returns, as a numeric value, the record length, in bytes, of
 *   the database file open in the current work area.  RECSIZE() returns zero
 *   if no database file is open.
 *  $DESCRIPTION$
 *     RECSIZE() is a database function that determines the length of a record
 *   by summing the lengths of each field then adding one for the DELETED()
 *   status flag.  When this value is multiplied by LASTREC(), the product is
 *   the amount of space occupied by the file's records.
 *
 *     RECSIZE() is useful in programs that perform automatic file backup.
 *   When used in conjunction with DISKSPACE(), the RECSIZE() function can
 *   assist in ensuring that sufficient free space exists on the disk before a
 *   file is stored.
 *
 *     By default, RECSIZE() operates on the currently selected work area.  It
 *   will operate on an unselected work area if you specify it as part of an
 *   aliased expression (see example below).
 *  $EXAMPLES$
 *     The following user-defined function, DbfSize(), uses RECSIZE()
 *      to calculate the size of the current database file:
 *
 *      FUNCTION DbfSize
 *         RETURN ((RECSIZE() * LASTREC()) + HEADER() + 1)
 *
 *     This example illustrates the use of RECSIZE() to determine the
 *      record length of database files open in unselected work areas:
 *
 *      USE Customer NEW
 *      USE Sales NEW
 *      //
 *      ? RECSIZE(), Customer->(RECSIZE())
 *      ? DbfSize(), Customer->(DbfSize())
 *  $TESTS$
 *
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      DISKSPACE(),FIELDNAME(),HEADER(),LASTREC()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      RLOCK()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Lock the current record in the active work area
 *  $SYNTAX$
 *      RLOCK() --> lSuccess
 *  $ARGUMENTS$
 *
 *  $RETURNS$
 *     RLOCK() returns true (.T.) if the record lock is obtained; otherwise, it
 *   returns false (.F.).
 *  $DESCRIPTION$
 *     RLOCK() is a network function that locks the current record, preventing
 *      other users from updating the record until the lock is released.
 *      RLOCK() provides a shared lock, allowing other users read-only access to
 *      the locked record while allowing only the current user to modify it.  A
 *      record lock remains until another record is locked, an UNLOCK is
 *      executed, the current database file is closed, or an FLOCK() is obtained
 *      on the current database file.
 *
 *      For each invocation of RLOCK(), there is one attempt to lock the current
 *      record, and the result is returned as a logical value.  An attempt to
 *      obtain a record lock fails if another user currently has a file or
 *      record lock, or EXCLUSIVE USE of the database file.  An attempt to
 *      RLOCK() in an empty database returns true (.T.).
 *
 *      By default, RLOCK() operates on the currently selected work area.  It
 *      will operate on an unselected work area if you specify it as part of an
 *      aliased expression (see example below).  This feature is useful since
 *      RLOCK() does not automatically attempt a record lock for related files.
 *
 *      As a general rule, RLOCK() operates solely on the current record.  This
 *      includes the following commands:
 *
 *      @...GET
 *
 *      DELETE (single record)
 *
 *      RECALL (single record)
 *
 *      REPLACE (single record)
 *
 *
 *      Notes
 *
 *      SET RELATION: HARBOUR does not automatically lock all
 *      records in the relation chain when you lock the current work area
 *      record.  Also, an UNLOCK has no effect on related work areas.
 *  $EXAMPLES$
 *     This example deletes a record in a network environment, using
 *      RLOCK():
 *
 *      USE Customer INDEX CustName SHARED NEW
 *      SEEK "Smith"
 *      IF FOUND()
 *         IF RLOCK()
 *            DELETE
 *            ? "Smith deleted"
 *         ELSE
 *            ? "Record in use by another"
 *         ENDIF
 *      ELSE
 *         ? "Smith not in Customer file"
 *      ENDIF
 *      CLOSE
 *
 *      This example specifies RLOCK() as an aliased expression to
 *      lock a record in an unselected work area:
 *
 *      USE Sales SHARED NEW
 *      USE Customer SHARED NEW
 *      //
 *      IF !Sales->(RLOCK())
 *         ? "The current Sales record is in use by another"
 *      ENDIF
 *  $TESTS$
 *
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      FLOCK()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      SELECT()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Determine the work area number of a specified alias
 *  $SYNTAX$
 *      SELECT([<cAlias>]) --> nWorkArea
 *  $ARGUMENTS$
 *      <cAlias> is the target work area alias name.
 *  $RETURNS$
 *      SELECT() returns the work area of the specified alias as a integer
 *      numeric value.
 *  $DESCRIPTION$
 *      SELECT() is a database function that determines the work area number of
 *      an alias.  The number returned can range from zero to 250.  If <cAlias>
 *      is not specified, the current work area number is returned.  If <cAlias>
 *      is specified and the alias does not exist, SELECT() returns zero.
 *
 *      Note:  The SELECT() function and SELECT command specified with an
 *      extended expression argument look somewhat alike.  This shouldn't be a
 *      problem since the SELECT() function is not very useful on a line by
 *      itself
 *  $EXAMPLES$
 *     This example uses SELECT() to determine which work area
 *      USE...NEW selected:
 *
 *      USE Sales NEW
 *      SELECT 1
 *      ? SELECT("Sales")          // Result: 4
 *
 *      To reselect the value returned from the SELECT() function, use
 *      the SELECT command with the syntax, SELECT (<idMemvar>), like this:
 *
 *      USE Sales NEW
 *      nWorkArea:= SELECT()
 *      USE Customer NEW
 *      SELECT (nWorkArea)
 *  $TESTS$
 *
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      ALIAS(),USED()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      USED()
 *  $CATEGORY$
 *      Database
 *  $ONELINER$
 *      Determine whether a database file is in USE
 *  $SYNTAX$
 *      USED() --> lDbfOpen
 *  $ARGUMENTS$
 *
 *  $RETURNS$
 *      USED() returns true (.T.) if there is a database file in USE; otherwise,
 *      it returns false (.F.).
 *  $DESCRIPTION$
 *      USED() is a database function that determines whether there is a
 *      database file in USE in a particular work area.  By default, USED()
 *      operates on the currently selected work area.  It will operate on an
 *      unselected work area if you specify it as part of an aliased expression.
 *  $EXAMPLES$
 *      This example determines whether a database file is in USE in
 *      the current work area:
 *
 *      USE Customer NEW
 *      ? USED()              // Result: .T.
 *      CLOSE
 *      ? USED()              // Result: .F.
 *  $TESTS$
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *
 *  $FILES$
 *      Library is rdd
 *  $SEEALSO$
 *      ALIAS(),SELECT()
 *  $END$
 */
