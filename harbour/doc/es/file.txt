/*
 * $Id$
 */

/*
 * Las siguientes partes son derechos adquiridos de sus autores individuales.
 * www - http://www.harbour-project.org
 *
 * Copyright 2000 Chen Kedem <niki@actcom.co.il>
 *   Documentaci¢n en Ingl‚s de: __TYPEFILE(), TYPE
 *
 * Copyright 2000 Luiz Rafael Culik <culik@sl.conex.net>
 *   Documentaci¢n en Ingl‚s de:
 *         FOPEN(), FCLOSE(), FWRITE(), FSEEK(), FREAD(), FILE(),
 *         FREADSTR(), FRENAME(), FERROR(), RENAME, ERASE, CURDIR(),
 *         DIRMAKE(),DIRCHANGE(),ISDISK(),DIRREMOVE(),DISKCHANGE(),
 *         DIRCHANGE()
 *
 * Copyright 2000 David G. Holm <Harbour@SpaceMoose.com>
 *   Documentaci¢n en Ingl‚s de: HB_FEOF()
 *
 * Copyright 2003 Alejandro de G rate <alex_degarate@hotmail.com>
 *   Documentaci¢n en Espa¤ol de:
 *         FOPEN(), FCREAT(), FREAD(), FWRITE(), FERROR(), FCLOSE(),
 *         FERASE(), FRENAME(), FSEEK(), FILE(), FREADSTR(), RENAME,
 *         ERASE, DELETE FILE, __TYPEFILE(), TYPE, CURDIR(), COPY FILE,
 *         HB_FEOF(), DIRREMOVE(), DIRCHANGE(), MAKEDIR(), ISDISK(),
 *
 * Vea doc/license.txt por los t‚rminos de la licencia.
 *
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FOPEN()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Abre un archivo binario
 *  $SYNTAX$
 *      FOPEN( <cArchivo>, [<nModo>] ) --> nHandle
 *  $ARGUMENTS$
 *      <cArchivo> Es el Nombre del archivo a abrir
 *
 *      <nModo>    Modo de apertura del archivo
 *  $RETURNS$
 *      Devuelve <nHandle>, el manejador (handle) del archivo.
 *  $DESCRIPTION$
 *      Esta funci¢n abre el archivo binario indicado como <cArchivo> y
 *      devuelve un manejador de archivo para ser usado por otras funciones
 *      de bajo nivel.
 *      El valor de <nModo> representa la forma de apertura del archivo, el
 *      valor por defecto es 0 (cero).
 *      Los modos de apertura son los siguientes:
 *
 *      <table>
 *       nModo   fileio.ch      Significado
 *
 *         0     FO_READ        Solo Lectura   (Read only)
 *         1     FO_WRITE       Solo Escritura (Write only)
 *         2     FO_READWRITE   Leer/Escribir  (Read/write)
 *        16     FO_EXCLUSIVE   Uso exclusivo, Solo Lectura
 *        32     FO_DENYWRITE   Evita escritura por otros
 *        48     FO_DENYREAD    Evita Lectura por otros
 *        64     FO_DENYNONE    No Evita nada, Otros pueden Leer/Escribir
 *        64     FO_SHARED      igual que FO_DENYNONE
 *      </table>
 *
 *      Si existe un error en la apertura del archivo, la funci¢n devolver 
 *      -1. El valor del manejador de archivo (handle) puede estar en el
 *      rango de cero a 65535.
 *      El estado de los comandos SET DEFAULT TO y SET PATH TO no tiene
 *      efecto sobre esta funci¢n.
 *      Los nombres de directorios y la trayectoria a trav‚s de ellos (path)
 *      puede ser especificada junto con el nombre del archivo a ser abierto.
 *
 *      Si ocurre un error, consulte el valor que devuelve la funci¢n
 *      FERROR(), por las causas posibles del error.
 *  $EXAMPLES$
 *      1) Abre un archivo para lectura/escritura y en modo compartido
 *
 *      nHandle := FOPEN('x.txt', 66 )
 *
 *      IF nHandle < 0
 *         ? "El archivo no puede ser abierto"
 *      ENDIF
 *
 *
 *      2) ¢ mejor a£n
 *      cFile   := "x.txt"
 *      nHandle := FOPEN( cFile, FO_SHARED + FO_READWRITE )
 *
 *      IF FERROR() != 0
 *         ? "El archivo <" + cFile + "> no puede ser abierto, error: ", ;
 *            FERROR()
 *         // Tomar la acci¢n apropiada...
 *      ENDIF
 *
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper.
 *  $PLATFORMS$
 *      Todas
 *  $FILES$
 *      La librer¡a asociada es rtl
 *      El archivo de cabecera es fileio.ch
 *  $SEEALSO$
 *      FCREATE(),FERROR(),FCLOSE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FCREATE()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Crea ¢ Trunca un archivo binario.
 *  $SYNTAX$
 *      FCREATE( <cArchivo>, [<nAtributo>] ) --> nHandle
 *  $ARGUMENTS$
 *      <cArchivo>  Es el Nombre del archivo a abrir
 *
 *      <nAtributo> C¢digo num‚rico con los atributos del archivo
 *  $RETURNS$
 *      Devuelve <nHandle> el manejador num‚rico (handle) del archivo para
 *      ser usado en otras operaciones.
 *  $DESCRIPTION$
 *      Esta funci¢n crea un nuevo archivo binario con el nombre <cArchivo>.
 *      El valor por defecto de <nAtributo> es cero y es usado para
 *      establecer el byte de atributo del archivo creado por esta funci¢n.
 *      El valor de retorno es un manejador de archivo (handle) que es
 *      asociado con el nuevo archivo. Este n£mero estar  entre cero y 65535
 *      Si ocurre un error, el valor de retorno de esta funci¢n ser  de -1.
 *
 *      Si el archivo <cArchivo> ya existe, ese archivo ser  truncado a una
 *      longitud de cero bytes.
 *
 *      Si <nAtributo> es especificado, la tabla siguiente muestra los
 *      valores que puede tomar y su relaci¢n con el archivo <cArchivo> que
 *      est  siendo creado por esta funci¢n.
 *
 *      <table>
 *      <nAtributo> fileio.ch    Significado
 *
 *       0          FC_NORMAL    Normal/Por Defecto, Lectura/Escritura
 *       1          FC_READONLY  Solo Lectura
 *       2          FC_HIDDEN    Oculto, Excluido de la b£squeda normal DIR
 *       4          FC_SYSTEM    Sistema, Excluido de la b£squeda normal DIR
 *      </table>
 *  $EXAMPLES$
 *      cFile := "test.txt"
 *      nHandle := FCREATE( cFile )
 *
 *      IF nHandle < 0
 *         ? "No se puede crear el archivo:", cFile
 *      ENDIF
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *      El archivo de cabecera es fileio.ch
 *  $SEEALSO$
 *      FCLOSE(),FOPEN(),FWRITE(),FREAD(),FERROR()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FREAD()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Lee un n£mero de bytes especificado desde un archivo binario
 *  $SYNTAX$
 *      FREAD( <nHandle>, @<cBuffer>, <nBytes> ) --> nBytesLeidos
 *  $ARGUMENTS$
 *      <nHandle>    Manejador de archivo del sistema operativo
 *
 *      <cBuffer>    Cadena de caracteres usada como buffer temporal y
 *                   pasada por referencia (n¢tese el operador '@' delante
 *                   del nombre de la variable).
 *
 *      <nBytes>     N£mero de bytes a leer
 *  $RETURNS$
 *      Devuelve <nBytesleidos>, el n£mero de bytes satisfactoriamente
 *      le¡dos desde el archivo.
 *  $DESCRIPTION$
 *      Esta funci¢n lee caracteres desde un archivo cuyo manejador es
 *      <nHandle> a una variable de memoria indicada como <cBuffer>.
 *      La funci¢n retorna el n£mero de bytes exitosamente le¡dos dentro de
 *      <cBuffer>.
 *
 *      El valor de <nHandle> es obtenido de la llamada a la funci¢n FOPEN()
 *      ¢ bien de la llamada a la funci¢n FCREATE().
 *
 *      La expresi¢n <cBuffer> es pasada por referencia y debe ser definida
 *      antes que esta funci¢n sea llamada.  Esta tambi‚n debe tener el
 *      mismo ¢ mayor tama¤o que <nBytes>, caso contrario se producir  un
 *      error.
 *
 *      <nBytes> es el n£mero de bytes a leer, comenzando en la posici¢n
 *      actual del puntero del archivo. Si esta funci¢n tiene ‚xito en la
 *      lectura de los caracteres del archivo, el n£mero real de caracteres
 *      le¡dos ser  igual a la longitud de <cBuffer>, igual al n£mero de
 *      bytes especificado en <nBytes> y ese ser  el valor devuelto.
 *      El puntero actual del archivo avanza tantas posiciones como el n£mero
 *      de bytes le¡dos.
 *
 *      Esta funci¢n lee todos los caracteres ASCII de 0-255, incluyendo el
 *      car cter null / ASC(0) y los caracteres de control.
 *      Si esta funci¢n devuelve cero, ¢ si el n£mero de bytes le¡dos no
 *      coincide ni con la longitud de <cBuffer>, ni con el valor
 *      especificado en <nBytes>, es porque se ha alcanzado la condici¢n
 *      end-of-file (EOF) ¢ fin de archivo.
 *
 *      Si ocurre un error, consulte el valor que devuelve la funci¢n
 *      FERROR(), por las causas posibles del error.
 *  $EXAMPLES$
 *      nChunck := 500
 *      cBuffer := SPACE( nChunck )
 *
 *      IF (nHandle := FOPEN('x.txt') ) > 0
 *         FREAD( nHandle, @cBuffer, nChunck )
 *      ENDIF
 *
 *      FCLOSE( nHandle )
 *
 *      ? cBuffer
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper, pero tambi‚n extiende el
 *      tama¤o del buffer a cadenas m s grandes que 64 Kb (dependiendo de la
 *      plataforma).
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      BIN2I(),BIN2L(),BIN2W(),FERROR(),FWRITE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FWRITE()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Escribe caracteres hacia un archivo binario abierto.
 *  $SYNTAX$
 *      FWRITE( <nHandle>, <cBuffer>, [<nBytes>] ) --> nBytesEscritos
 *  $ARGUMENTS$
 *      <nHandle>  Manejador de archivo del sistema operativo
 *
 *      <cBuffer>  Cadena de caracteres a escribirse
 *
 *      <nBytes>   El n£mero de bytes a escribir
 *  $RETURNS$
 *      <nBytesEscritos> el n£mero de bytes satisfactoriamente escritos.
 *  $DESCRIPTION$
 *      Esta funci¢n escribe el contenido de la memoria intermedia <cBuffer>
 *      a un archivo binario designado por su manejador de archivo <nHandle>.
 *
 *      El valor devuelto por esta funci¢n es el n£mero de bytes exitosamente
 *      escritos en el archivo.
 *      Si el valor devuelto es cero, un error ha ocurrido, disco lleno, etc.
 *
 *      Una escritura satisfactoria ocurre cuando el n£mero de bytes
 *      retornados por FWRITE() es igual al LEN( <cBuffer>) ¢ <nBytes>.
 *
 *      El valor de <nBytes> es el n£mero de bytes a escribir al archivo.
 *      La escritura comienza en la posici¢n actual del puntero del archivo.
 *      Si <nBytes> es especificado, este es el n£mero de bytes en <cBuffer>
 *      que van a ser escritos. Si esta variable no es usada, el contenido
 *      completo del buffer  <cBuffer> es escrito al archivo.
 *      Para truncar un archivo, una llamada a FWRITE( nHandle, "", 0 ) es
 *      necesaria.
 *
 *      Si ocurre un error, consulte el valor que devuelve la funci¢n
 *      FERROR(), por las causas posibles del error.
 *  $EXAMPLES$
 *      nHandle := FCREATE('x.txt')
 *
 *      FOR x :=1 TO 10
 *          FWRITE( nHandle, STR(x) )
 *      NEXT
 *
 *      FCLOSE( nHandle )
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n no es compatible con CA-Cl*pper porque puede escribir
 *      cadenas de caracteres mayores a 64 Kb.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      FCLOSE(),FCREATE(),FERROR(),FOPEN(),I2BIN(),L2BIN()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FERROR()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Reporta el estado de error de las funciones de archivo de bajo nivel
 *  $SYNTAX$
 *      FERROR() --> <nCodigoError>
 *  $RETURNS$
 *      <nCodigoError> Valor del £ltimo error del DOS encontrado por una
 *                     funci¢n de bajo nivel.
 *
 *      Valores de Retorno de FERROR()
 *
 *      <table>
 *       Error          Significado
 *
 *        0             Exito, no hubo error
 *        2             Archivo no encontrado
 *        3             Camino (Path) no encontrado
 *        4             Demasiados archivos abiertos
 *        5             Acceso denegado
 *        6             Manejador (handle) no v lido
 *        8             Memoria insuficiente
 *       15             Drive especificado no v lido
 *       19             Intento de escritura en un disco protegido
 *       21             Drive no listo
 *       23             Error en CRC de datos
 *       29             Error de escritura
 *       30             Error de lectura
 *       32             Sharing violation
 *       33             Violaci¢n de bloqueo
 *      </table>
 *  $DESCRIPTION$
 *      Despu‚s de ejecutar una funci¢n de manipulaci¢n de archivos de bajo
 *      nivel , esta funci¢n retornar  un valor que provee informaci¢n
 *      adicional sobre su funcionamiento.
 *      Si la funci¢n FERROR() devuelve cero, no se ha detectado ning£n
 *      error.  Esta funci¢n mantiene su valor hasta la pr¢xima ejecuci¢n de
 *      una funci¢n de archivo de bajo nivel.
 *      M s arriba hay un tabla con algunos valores devueltos por la funci¢n
 *      FERROR().
 *      Note que esos valores podr¡an ser distintos en otra plataforma
 *      (sistema operativo) distinta a DOS/Windows.
 *  $EXAMPLES$
 *      #include "fileio.ch"
 *      //
 *      nHandle := FCREATE("temp.txt", FC_NORMAL)
 *
 *      IF FERROR() != 0
 *         ? "No se puede crear el archivo, DOS error ", FERROR()
 *      ENDIF
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      FCLOSE(),FERASE(),FOPEN(),FWRITE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FCLOSE()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Cierra un archivo binario abierto
 *  $SYNTAX$
 *      FCLOSE( <nHandle> ) --> <lExito>
 *  $ARGUMENTS$
 *      <nHandle> Manejador de archivo del sistema operativo
 *  $RETURNS$
 *      Devuelve un valor l¢gico, <lExito> es TRUE (.T.) si se cerr¢ con
 *      ‚xito ¢ FALSE (.F.) si no se pudo cerrar.
 *  $DESCRIPTION$
 *      Esta funci¢n cierra un archivo abierto identificado con el manejador
 *      de DOS <nHandle> y escribe el contenido del buffer DOS asociado hacia
 *      el disco.
 *      El valor <nHandle> es obtenido del llamado a alguna de las
 *      funciones FCREATE() ¢ FOPEN().
 *
 *      Si ocurre un error, consulte el valor que devuelve la funci¢n
 *      FERROR(), por las causas posibles del error.
 *  $EXAMPLES$
 *      nHandle := FOPEN('x.txt')
 *
 *      ? FSEEK( nHandle, 0, 2)
 *
 *      FCLOSE( nHandle )
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      FOPEN(),FCREATE(),FREAD(),FWRITE(),FERROR()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FERASE()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Borra un archivo del disco
 *  $SYNTAX$
 *      FERASE( <cArchivo> ) --> nExito
 *  $ARGUMENTS$
 *      <cArchivo>  Nombre del archivo a borrar
 *  $RETURNS$
 *      Devuelve cero si hubo ‚xito, -1 en caso contrario.
 *  $DESCRIPTION$
 *      Esta funci¢n borra el archivo especificado en <cArchivo> del disco.
 *      Ninguna extensi¢n es asumida. El disco y el camino (path) pueden ser
 *      incluidos en <cArchivo>;
 *      Ninguno de los comandos SET DEFAULT ni SET PATH afectan la ejecuci¢n
 *      de esta funci¢n.
 *      Si el disco ¢ el camino no son usados, esta funci¢n buscar  el
 *      archivo solamente en el directorio actual del disco al cual se
 *      encuentra loggeado.
 *
 *      Si la funci¢n es capaz de borrar satisfactoriamente el archivo del
 *      disco, el valor devuelto por la funci¢n ser  cero ¢ -1 si hubo alguna
 *      falla.  Si no fue exitosa la operaci¢n, informaci¢n adicional puede
 *      ser obtenida llamando a la funci¢n FERROR().
 *
 *      Nota: Cualquier archivo a ser removido por FERASE() debe estar
 *            previamente cerrado.
 *  $EXAMPLES$
 *      IF FERASE("test.txt") == 0
 *          ? "El archivo fu‚ exitosamente borrado"
 *      ELSE
 *          ? "El archivo no puede ser borrado"
 *      ENDIF
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      FERROR(),FRENAME()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FRENAME()
 *  $CATEGORY$
 *      File management
 *  $ONELINER$
 *      Renombra un archivo
 *  $SYNTAX$
 *      FRENAME( <cArchivoViejo>, <cArchivoNuevo> ) --> nExito
 *  $ARGUMENTS$
 *      <cArchivoViejo>  Nombre del archivo a ser cambiado
 *
 *      <cArchivoNuevo>  Nuevo nombre que tomar  el archivo
 *  $RETURNS$
 *      Devuelve cero si hubo ‚xito, -1 en caso contrario.
 *  $DESCRIPTION$
 *      Esta funci¢n renombra el archivo especificado en <cArchivoViejo>
 *      al nuevo nombre: <cArchivoNuevo>.
 *      El nombre del archivo junto con el del directorio puede ser
 *      especificado para cualquier par metro.
 *      Sin embargo, si el camino es aportado como parte de <cArchivoNuevo>
 *      y este camino es diferente del camino especificado en <cArchivoViejo>
 *      ¢ (si ninguno es usado) el disco y directorio actuales, la funci¢n
 *      podr¡a no ejecutarse satisfactoriamente.
 *
 *      Ninguno de los comandos SET DEFAULT ni SET PATH afectan la ejecuci¢n
 *      de esta funci¢n.
 *      Al intentar localizar el archivo a ser renombrado, esta funci¢n
 *      buscar  en el disco y el directorio por defecto, ¢ en el disco y
 *      directorio especificado en <cArchivoViejo>.
 *      No buscar  en los directorios mencionados en los comandos SET PATH TO
 *      SET DEFAULT TO ¢ por la sentencia PATH del sistema operativo.
 *
 *      Si el archivo especificado en <cArchivoNuevo> existe ¢ el archivo
 *      est  abierto, la funci¢n ser  incapaz de renombrar el archivo.
 *      Si la funci¢n es incapaz de completar su operaci¢n, esta devolver 
 *      el valor -1, y cero si la operaci¢n fue exitosa.
 *      Si ocurre un error, consulte el valor que devuelve la funci¢n
 *      FERROR(), por las causas posibles del error.
 *  $EXAMPLES$
 *      nResult := FRENAME("x.txt", "x1.txt")
 *
 *      IF nResult < 0
 *         ? "El archivo no pudo ser renombrado."
 *      ENDIF
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      ERASE,FERASE(),FERROR(),FILE(),RENAME
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FSEEK()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Mueve el puntero de un archivo binario
 *  $SYNTAX$
 *      FSEEK( <nHandle>, <nOffset>, [<nOrigen>] ) --> nPosicion
 *  $ARGUMENTS$
 *      <nHandle>  Manejador de archivo del sistema operativo
 *                 El valor <nHandle> es obtenido del llamado a alguna de
 *                 las funciones FCREATE() ¢ FOPEN().
 *
 *      <nOffset>  N£mero de bytes a mover el puntero del archivo
 *
 *      <nOrigen>  Posici¢n inicial del puntero del archivo
 *  $RETURNS$
 *      Devuelve <nPosicion> la posici¢n actual del puntero del archivo con
 *      respecto al comienzo del archivo.
 *  $DESCRIPTION$
 *      Esta funci¢n mueve el puntero del archivo, cuyo manejador DOS es
 *      <nHandle> tantos bytes hacia delante ¢ atras seg£n el contenido de
 *      <nOffset>, desde la posici¢n establecida por <nOrigen>.
 *
 *      El valor num‚rico retornado por la funci¢n es la posici¢n relativa
 *      del puntero del archivo al marcador de inicio de archivo una vez que
 *      la operaci¢n ha sido completada.
 *      Esta funci¢n no realiza ninguna lectura, simplemente mueve el puntero
 *      del archivo.
 *
 *      Si el valor de <nOffSet> es positivo el puntero se mover  hacia
 *      delante, si el valor es negativo se mover  hacia atr s, desde la
 *      posici¢n establecida por <nOrigen>.
 *
 *      El valor de <nOrigen> establece el punto de inicio desde el cual el
 *      puntero del archivo va a ser movido, como se muestra en la tabla
 *      siguiente:
 *
 *      <table>
 *      <nOrigen>    fileio.ch     Posici¢n en el archivo
 *
 *         0         FS_SET        Comienzo del archivo
 *         1         FS_RELATIVE   Actual posici¢n del puntero del archivo
 *         2         FS_END        Fin del archivo (EOF)
 *      </table>
 *
 *      Si un valor no es provisto para <nOrigen>, por defecto es cero y
 *      el puntero del archivo se mueve desde el comienzo del archivo.
 *      El puntero del archivo no puede desplazarse m s alla de los l¡mites
 *      de inicio ¢ de fin de archivo, caso contrario ocurrir  un error.
 *      Si ocurre un error, consulte el valor que devuelve la funci¢n
 *      FERROR(), por las causas posibles del error.
 *  $EXAMPLES$
 *      // Funci¢n que lee una l¡nea de texto desde un archivo abierto
 *
 *      // nHandle = manejador de archivo obtenido de FOPEN()
 *      // cB = cadena buffer pasada-por-referencia para poner el resultado
 *      // nMaxLine = n£mero maximo de bytes a leer
 *
 *      #define EOL HB_OSNEWLINE()
 *
 *      FUNCTION FREADln( nHandle, cB, nMaxLine )
 *
 *      LOCAL cLine, nSavePos, nEol, nNumRead
 *
 *      cLine := SPACE( nMaxLine )
 *      cB := ''
 *      nSavePos := FSEEK( nHandle, 0, FS_RELATIVE )
 *      nNumRead := FREAD( nHandle, @cLine, nMaxLine )
 *
 *      IF ( nEol := AT( EOL, substr( cLine, 1, nNumRead ) ) ) == 0
 *         cB := cLine
 *      ELSE
 *         cB := SUBSTR( cLine, 1, nEol - 1 )
 *         FSEEK( nHandle, nSavePos + nEol + 1, FS_SET )
 *      ENDIF
 *
 *      RETURN nNumRead != 0
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *      El archivo de cabecera es fileio.ch
 *  $SEEALSO$
 *      FCREATE(),FERROR(),FOPEN(),FREAD(),FREADSTR(),FWRITE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FILE()
 *  $CATEGORY$
 *      File management
 *  $ONELINER$
 *      Verifica la existencia de archivos
 *  $SYNTAX$
 *      FILE( <cEspecArchivo> ) --> lExiste
 *  $ARGUMENTS$
 *      <cEspecArchivo> Especificaci¢n del archivo, esta puede contener una
 *                      referencia a la unidad de disco y el directorio.
 *                      La extensi¢n debe ser especificada.
 *                      Sigue las reglas b sicas de archivos de DOS.
 *  $RETURNS$
 *      Retorna <lExiste> un valor l¢gico verdadero (.T.) si el archivo
 *      existe, ¢ falso (.F.) si no es encontrado.
 *  $DESCRIPTION$
 *      Esta funci¢n busca el archivo como es especificado en <cEspecArchivo>
 *
 *      Si el camino no es especificado, FILE() buscar  primero en la
 *      ubicaci¢n indicada por SET DEFAULT, si no lo encuentra seguir  luego
 *      con la/s ubicaci¢n/es contenidas en SET PATH, hasta que el archivo
 *      sea encontrado ¢ hasta que no haya m s caminos para buscar.
 *
 *      El PATH del DOS nunca es examinado y el actual disco y directorio
 *      es s¢lo examinado si SET DEFAULT est  en blanco.
 *
 *      Nota: La utilizaci¢n de caracteres comodines '*' y '?' todav¡a no
 *            est  soportada comletamente.
 *  $EXAMPLES$
 *      ? FILE( "C:\harbour\doc\compiler.txt")
 *      ? FILE( "C:\harbour\doc\subcodes.txt")
 *  </fixed>
 *  $STATUS$
 *      S (el soporte de comodines todav¡a est  ausente)
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      SET DEFAULT,SET PATH,SET()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      FREADSTR()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Lee una cadena de caracteres desde un archivo binario
 *  $SYNTAX$
 *      FREADSTR( <nHandle>, <nBytes>) --> cCadena
 *  $ARGUMENTS$
 *      <nHandle>  Manejador de archivo del sistema operativo
 *                 El valor <nHandle> es obtenido del llamado a alguna de
 *                 las funciones FCREATE() ¢ FOPEN().
 *
 *      <nBytes>   N£mero de bytes a leer
 *  $RETURNS$
 *      Devuelve la cadena de caracteres <cCadena>.
 *  $DESCRIPTION$
 *      Esta es una funci¢n de bajo nivel que lee caracteres de un archivo
 *      binario.
 *      El valor de <nBytes> es el n£mero de bytes a leer desde el archivo.
 *
 *      La cadena devuelta ser  el n£mero de caracteres especificado en
 *      <nBytes> si no hubo error y el archivo todav¡a conten¡a esa cantidad
 *      de caracteres.
 *      Si se encuentra los caracteres ASCII=cero ¢ ASCII=26 el tama¤o de la
 *      cadena devuelta ser  menor que <nBytes> e inclusive puede ser nula.
 *
 *      NOTA:
 *      Esta funci¢n es similar a la funci¢n FREAD(), excepto que detiene la
 *      lectura si encuentra los caracteres CHR(0) (fin de cadena) ¢ CHR(26)
 *      (fin de archivo).
 *      Tenga esto en cuenta si no logra el resultado deseado al leer un
 *      archivo binario, en tal caso la funci¢n FREAD() deber¡a ser usada en
 *      lugar de la funci¢n FREADSTR().
 *  $EXAMPLES$
 *      - Este ejemplo lee y muestra los primeros 100 caracteres de un
 *        archivo de texto
 *
 *      IF ( nHandle := FOPEN("x.txt") ) > 0
 *         cStr := FREADSTR( nHandle, 100)
 *         ? cStr
 *      ENDIF
 *
 *      FCLOSE( nHandle )
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n no es compatible CA-Cl*pper dado que la versi¢n de
 *      Harbour, puede leer cadenas mayores que 64 Kb, dependiendo de la
 *      plataforma.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      BIN2I(),BIN2L(),BIN2W(),FERROR(),FREAD(),FSEEK()
 *  $END$
 */


/* HARBOUR COMMANDS */

/*  $DOC$
 *  $FUNCNAME$
 *      RENAME
 *  $CATEGORY$
 *      Comando
 *  $ONELINER$
 *      Cambia el nombre del archivo especificado
 *  $SYNTAX$
 *      RENAME <xcArchivoViejo> TO <xcArchivoNuevo>
 *  $ARGUMENTS$
 *      <xcArchivoViejo>  Nombre del archivo a ser cambiado
 *
 *      <xcArchivoNuevo>  Nuevo nombre que tomar  el archivo
 *  $DESCRIPTION$
 *      Este comando cambia el nombre de <xcArchivoViejo> a <xcArchivoNuevo>.
 *      Ambos archivos <xcArchivoViejo> y <xcArchivoNuevo> deben incluir la
 *      extensi¢n del archivo y pueden opcionalmente incluir la unidad de
 *      disco y el camino, aunque deben especificarse si cualquier archivo
 *      est  en otro directorio distinto al disco y directorio por defecto.
 *      El nombre de cualquiera de los dos archivos puede ser especificado
 *      como una cadena literal, ¢ como una expresi¢n de caracteres
 *      encerrada entre par‚ntesis.
 *      Este comando no es afectado ni por el comando SET PATH TO, ni por el
 *      comando SET DEFAULT TO.
 *
 *      Si <xcArchivoNuevo> existe previamente ¢ si est  actualmente abierto
 *      este comando no realizar  la operaci¢n deseada.
 *      Si ocurre un error, consulte el valor que devuelve la funci¢n
 *      FERROR(), por las causas posibles del error.
 *  $EXAMPLES$
 *      RENAME C:\autoexec.bat TO C:\autoexec.old
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Este comando es compatible con CA-Cl*pper.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      CURDIR(),ERASE,FILE(),FERASE(),FRENAME()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      ERASE
 *  $CATEGORY$
 *      Comando
 *  $ONELINER$
 *      Remueve un archivo del disco
 *  $SYNTAX$
 *      ERASE <xcArchivo>
 *  $ARGUMENTS$
 *      <xcArchivo>   Nombre del archivo a remover
 *  $DESCRIPTION$
 *      Este comando borra ¢ remueve un archivo del disco.
 *      El nombre de <xcArchivo> puede especificarse como una cadena literal,
 *      ¢ como una expresi¢n de caracteres.  Debe incluir la extensi¢n del
 *      archivo y puede opcionalmente incluir la unidad de disco y el camino.
 *
 *      El uso de los caracteres comodines '*' y '?' esta permitido.
 *
 *      Los comandos SET DEFAULT y SET PATH no afectan la operatoria de este
 *      comando.
 *      El archivo debe ser considerado cerrado por el sistema operativo,
 *      antes de que ‚ste pueda ser borrado.
 *  $EXAMPLES$
 *      ERASE C:\autoexec.bat     // s¢lo es una broma, no lo intente!
 *      ERASE C:/temp/read.txt
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Este comando es compatible con CA-Cl*pper.
 *  $SEEALSO$
 *      CURDIR(),FILE(),FERASE(),DELETE FILE
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      DELETE FILE
 *  $CATEGORY$
 *      Comando
 *  $ONELINER$
 *      Remueve un archivo del disco
 *  $SYNTAX$
 *      DELETE FILE <xcArchivo>
 *  $ARGUMENTS$
 *      <xcArchivo>   Nombre del archivo a remover
 *  $DESCRIPTION$
 *      Este comando borra ¢ remueve un archivo del disco.
 *      El nombre de <xcArchivo> puede especificarse como una cadena literal,
 *      ¢ como una expresi¢n de caracteres.  Debe incluir la extensi¢n del
 *      archivo y puede opcionalmente incluir la unidad de disco y el camino.
 *
 *      El uso de los caracteres comodines '*' y '?' esta permitido.
 *
 *      Los comandos SET DEFAULT y SET PATH no afectan la operatoria de este
 *      comando.
 *      El archivo debe ser considerado cerrado por el sistema operativo,
 *      antes de que ‚ste pueda ser borrado.
 *  $EXAMPLES$
 *      ERASE C:\autoexec.bat     // s¢lo es una broma, no lo intente!
 *      ERASE C:/temp/read.txt
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Este comando es compatible con CA-Cl*pper.
 *  $SEEALSO$
 *      CURDIR(),FILE(),FERASE(),ERASE
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      __TYPEFILE()
 *  $CATEGORY$
 *      Data input and output
 *  $ONELINER$
 *      Muestra el contenido de un archivo en la consola y/o impresora
 *  $SYNTAX$
 *      __TYPEFILE( <cArchivo>, [<lImprime>] ) --> NIL
 *  $ARGUMENTS$
 *      <cArchivo>   Es el nombre del archivo a visualizar.
 *                   Si el archivo tiene una extensi¢n, esta debe ser
 *                   especificada (no hay valor por defecto).
 *
 *      <lImprime>   Es un valor l¢gico opcional que especifica a donde
 *                   deber¡a ir la salida:
 *                   (.F.) salida solamente a la pantalla
 *                   (.T.) salida a pantalla e impresora.
 *                   Por defecto es  (.F.).
 *  $RETURNS$
 *      __TYPEFILE() siempre devuelve NIL.
 *  $DESCRIPTION$
 *      La funci¢n __TYPEFILE() muestra el contenido de un archivo de texto
 *      en la pantalla, con una opci¢n para enviar esta informaci¢n tambi‚n
 *      a la impresora.
 *      El archivo es visualizado tal como est  sin ning£n encabezado ¢
 *      formateo previo.
 *
 *      Si <cArchivo> no contiene ning£n camino ¢ path, __TYPEFILE() tratar 
 *      de encontrar primero el archivo en el directorio indicado por
 *      SET DEFAULT y luego entonces en todos los directorios indicados por
 *      SET PATH.
 *      Si el archivo <cArchivo>, no puede ser encontrado ocurrir  un error
 *      en tiempo de ejecuci¢n.
 *
 *      Use SET CONSOLE OFF para suprimir la salida por pantalla.
 *      Usted puede pausar la salida usando <Ctrl-S>, y pulsando cualquier
 *      tecla para continuar.
 *
 *      La funci¢n __TYPEFILE() es usada en el preprocesamiento del comando
 *      TYPE.
 *  $EXAMPLES$
 *      Los siguientes ejemplos asumen que un archivo con el nombre
 *      mitexto.dat existe en todos los caminos especificados, un error de
 *      ejecuci¢n podr¡a ser visualizado de no ser as¡.
 *
 *      // Visualiza el archivo mitexto.dat en la pantalla
 *      __TYPEFILE( "mitexto.dat" )
 *
 *      // Visualiza el archivo mitexto.dat en la pantalla e impresora
 *      __TYPEFILE( "mitexto.dat", .T. )
 *
 *      // Visualiza el archivo mitexto.dat en la impresora solamente
 *      SET CONSOLE OFF
 *
 *      __TYPEFILE( "mitexto.dat", .T. )
 *
 *      SET CONSOLE ON
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      __TYPEFILE() trabaja exactamente como __TYPEFILE() de CA-Cl*pper
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      COPY FILE,SET DEFAULT,SET PATH,SET PRINTER,TYPE
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      TYPE
 *  $CATEGORY$
 *      Comando
 *  $ONELINER$
 *      Visualiza el contenido de un archivo de texto
 *  $SYNTAX$
 *      TYPE <xcArchivo> [TO PRINTER] [TO FILE <xcArchivoDest>]
 *  $ARGUMENTS$
 *      <xcArchivo>  Es el nombre del archivo a visualizar.
 *                   Si el archivo tiene una extensi¢n, esta debe ser
 *                   especificada (no hay valor por defecto). Esta puede ser
 *                   especificada como literal de nombre de archivo ¢ como
 *                   una expresi¢n de caracteres encerrada entre parentesis
 *
 *      TO PRINTER   es una cl usula opcional que especifica que la salida
 *                   deber¡a ir a la pantalla e impresora.
 *
 *      TO FILE <xcArchivoDest> Copia el archivo fuente <xcArchivo> tambi‚n
 *                   a un archivo.  Si ninguna extensi¢n es dada (.txt) es
 *                   agregada al archivo de salida.
 *                   <xcArchivoDest> puede ser especificado como literal de
 *                   nombre de archivo ¢ como una expresi¢n de caracteres
 *                   encerrada entre par‚ntesis.
 *  $DESCRIPTION$
 *      El comando TYPE muestra el contenido de un archivo de texto en la
 *      pantalla, con una opci¢n para enviar esta informaci¢n tambi‚n
 *      a la impresora ¢ a un archivo alternativo.
 *      El archivo es visualizado tal como est  sin ning£n encabezado ¢
 *      formateo previo.
 *
 *      Si <xcArchivo> no contiene ning£n camino ¢ path,  TYPE tratar 
 *      de encontrar primero el archivo en el directorio indicado por
 *      SET DEFAULT y luego entonces en todos los directorios indicados por
 *      SET PATH.
 *      Si el archivo <xcArchivo>, no puede ser encontrado ocurrir  un error
 *      en tiempo de ejecuci¢n.
 *
 *      Si <xcDestFile> no contiene ning£n camino ¢ path, este es creado en
 *      directorio indicado en SET DEFAULT.
 *
 *      Use SET CONSOLE OFF para suprimir la salida por pantalla.
 *      Usted puede pausar la salida usando <Ctrl-S>, y pulsando cualquier
 *      tecla para continuar.
 *  $EXAMPLES$
 *      Los siguientes ejemplos asumen que un archivo con el nombre
 *      mitexto.dat existe en todos los caminos especificados, un error de
 *      ejecuci¢n podr¡a ser visualizado de no ser as¡.
 *
 *      // Visualiza el archivo mitexto.dat en la pantalla
 *      TYPE mitexto.dat
 *
 *      // Visualiza el archivo mitexto.dat en la pantalla e impresora
 *      TYPE mitexto.dat TO PRINTER
 *
 *      // Visualiza el archivo mitexto.dat en la impresora solamente
 *      SET CONSOLE OFF
 *
 *      TYPE mitexto.dat TO PRINTER
 *
 *      SET CONSOLE ON
 *
 *      // Visualiza el archivo mitexto.dat en la pantalla y lo env¡a al
 *      // archivo mireporte.txt
 *      TYPE mitexto.dat TO FILE MiReporte
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      TYPE trabaja exactamente como el comando TYPE de CA-Cl*pper
 *  $SEEALSO$
 *      COPY FILE,SET DEFAULT,SET PATH,SET PRINTER,__TYPEFILE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      CURDIR()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Retorna el nombre del directorio actual del Sistema Operativo
 *  $SYNTAX$
 *      CURDIR( [<cDrive>] )  --> cPath
 *  $ARGUMENTS$
 *      <cDrive>  Letra del disco del Sistema Operativo
 *  $RETURNS$
 *      Devuelve <cPath>, el nombre del directorio actual
 *  $DESCRIPTION$
 *      Esta funci¢n devuelve el nombre del directorio actual del Sistema
 *      Operativo para un drive especificado.
 *      Si <cDrive> no es especificado, el drive al que se encuentra
 *      actualmente loggeado ¢ conectado ser  usado.
 *
 *      Esta funci¢n no deber¡a devolver las barras de separaci¢n de
 *      directorio que se encuentren por delante y por detr s del directorio,
 *      sino s¢lo el nombre.
 *      Si un error ha sido detectado por la funci¢n, ¢ el directorio actual
 *      del Sistema Operativo es el raiz, el valor de la funci¢n podr¡a ser
 *      un byte nulo (NULL).
 *  $EXAMPLES$
 *      ? CURDIR()
 *      </fixed>
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper.
 *  $PLATFORMS$
 *      Todas
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      FILE()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      COPY FILE
 *  $CATEGORY$
 *      Comando
 *  $ONELINER$
 *      Copia un archivo a uno nuevo ¢ a un dispositivo
 *  $SYNTAX$
 *      COPY FILE <xcArchivoOrig> TO <xcArchivoDest> | <xcDevice>
 *  $ARGUMENTS$
 *      <xcArchivoOrig>  es el nombre del archivo fuente ¢ de origen
 *
 *      <xcArchivoDest>  es el nombre del archivo destino
 *
 *      <xcDevice>       es el nombre del dispositivo al que se va a enviar
 *                       los datos. Si no existe el dispositivo se crea un
 *                       archivo con ese nombre.
 *  $DESCRIPTION$
 *      Este comando realiza una copia exacta del archivo <xcArchivoOrig> y
 *      le asigna el nombre <xcArchivoDest>.
 *      Ambos archivos deben tener la extensi¢n incluida, no se agrega
 *      ninguna por defecto.  Ambos archivos pueden especificar tanto
 *      la unidad de disco como el camino.
 *      Tanto ambos archivos como el dispositivo pueden ser especificados
 *      como literal de nombre de archivo ¢ como una expresi¢n de caracteres
 *      encerrada entre parentesis.
 *
 *      El nombre del dispositivo puede ser tanto uno local como uno de red
 *      LPT1, \\SHARED\PRINTER, etc.
 *
 *      Los comandos SET DEFAULT y SET PATH no afectan la operatoria de este
 *      comando.
 *  $EXAMPLES$
 *      COPY FILE C:\harbour\tests\adirtest.prg TO C:\temp\adirtest.prg
 *      COPY FILE C:\harbour\utils\hbdoc\gennf.prg TO LPT1
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Este comando es compatible con CA-Cl*pper.
 *  $SEEALSO$
 *      ERASE,RENAME,FRENAME(),FERASE(),COPY TO
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      HB_FEOF()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Chequea si el puntero del archivo esta al final (EOF).
 *  $SYNTAX$
 *      HB_FEOF( <nHandle> ) --> lEsEOF
 *  $ARGUMENTS$
 *      <nHandle>  Manejador de archivo del sistema operativo
 *                 El valor <nHandle> es obtenido del llamado a alguna de
 *                 las funciones FCREATE() ¢ FOPEN().
 *  $RETURNS$
 *      Devuelve <lEsEOF>, un valor l¢gico verdadero (.T.) si el puntero
 *      del archivo de ese manejador est  al final del archivo (EOF), ¢
 *      falso (.F.) si a£n no lleg¢ al fin del archivo.
 *  $DESCRIPTION$
 *      Esta funci¢n testea si el archivo abierto correspondiente al
 *      manejador <nHandle> tiene el puntero del archivo al final del
 *      archivo, E-O-F.
 *
 *      Si el manejador de archivo falta, no es num‚rico, ¢ el archivo no
 *      est  abierto, entonces esta funci¢n devuelve .T. y establece el
 *      valor devuelto por FERROR() a -1 (FS_ERROR), ¢ a un valor de error
 *      dependiente del compilador de lenguaje C (EBADF ¢ EINVAL).
 *  $EXAMPLES$
 *      nHandle := FOPEN('file.txt')
 *
 *      ? FREADSTR( nHandle, 80)
 *
 *      IF HB_FEOF( nHandle )
 *         ? "Fue alcanzado el Fin-de-Archivo (EOF)"
 *      ELSE
 *         ? FREADSTR( nHandle, 80)
 *      ENDIF
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es una extensi¢n de Harbour.
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      FERROR()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      DIRREMOVE()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Remueve un directorio
 *  $SYNTAX$
 *      DIRCHANGE( <cDirectorio> ) --> nError
 *  $ARGUMENTS$
 *      <cDirectorio>   Es el nombre del directorio a remover
 *  $RETURNS$
 *      Devuelve un valor num‚rico, <nError> es cero si el directorio fu‚
 *      exitosamente removido, de otro modo devuelve el n£mero del £ltimo
 *      error ocurrido.
 *  $DESCRIPTION$
 *      Esta funci¢n intenta remover el directorio especificado en la
 *      variable <cDirectorio>.  Si esta funci¢n falla, devolver  el c¢digo
 *      num‚rico del sistema operativo correspondiente al £ltimo error
 *      ocurrido.
 *      Consulte la funci¢n FERROR() por una descripci¢n del error.
 *  $EXAMPLES$
 *      cDir   := ".\backup"
 *      nError := DIRREMOVE( cDir )
 *
 *      IF nError == 0
 *         ? "La remoci¢n del directorio [" + cDir + "] fu‚ exitosa"
 *      ENDIF
 *  $TESTS$
 *      Ver ejemplos
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper 5.3
 *  $PLATFORMS$
 *      Todas
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      MAKEDIR(),DIRCHANGE(),ISDISK(),DISKCHANGE(),DISKNAME(),FERROR()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      DIRCHANGE()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Cambia el directorio activo
 *  $SYNTAX$
 *      DIRCHANGE( <cDirectorio> ) --> nError
 *  $ARGUMENTS$
 *      <cDirectorio> Es el nombre del directorio al cual Ud. desea cambiarse
 *  $RETURNS$
 *      Devuelve un valor num‚rico, <nError> es cero si el directorio fu‚
 *      exitosamente cambiado, de otro modo devuelve el n£mero del £ltimo
 *      error ocurrido.
 *  $DESCRIPTION$
 *      Esta funci¢n intenta cambiar el directorio actual a otro especificado
 *      en la variable <cDirectorio>.  Si esta funci¢n falla, devolver  el
 *      c¢digo num‚rico del sistema operativo correspondiente al £ltimo error
 *      ocurrido.
 *      Consulte la funci¢n FERROR() por una descripci¢n del error.
 *  $EXAMPLES$
 *      cDir   := "\temp"
 *      nError := DIRCHANGE( cDir )
 *
 *      IF nError == 0
 *         ? "El cambio al directorio [" + cDir + "] fu‚ exitoso"
 *      ENDIF
 *  $TESTS$
 *      Ver ejemplos
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper 5.3
 *  $PLATFORMS$
 *      Todas
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      MAKEDIR(),DIRREMOVE(),ISDISK(),DISKCHANGE(),DISKNAME(),FERROR()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      MAKEDIR()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Crea un nuevo directorio
 *  $SYNTAX$
 *      MAKEDIR( <cDirectorio> ) --> nError
 *  $ARGUMENTS$
 *      <cDirectorio>   Es el nombre del directorio que Ud. desea crear
 *  $RETURNS$
 *      Devuelve un valor num‚rico, <nError> es cero si el directorio fu‚
 *      exitosamente creado, de otro modo devuelve el n£mero del £ltimo
 *      error ocurrido.
 *  $DESCRIPTION$
 *      Esta funci¢n intenta crear un nuevo directorio con el nombre
 *      especificado en la variable <cDirectorio>.  Si esta funci¢n falla,
 *      devolver  el c¢digo num‚rico del sistema operativo correspondiente
 *      al £ltimo error ocurrido.
 *      Consulte la funci¢n FERROR() por una descripci¢n del error.
 *  $EXAMPLES$
 *      cDir   := "Temp"
 *      nError := MAKEDIR( cDir)
 *      IF nError == 0
 *         ? "La creaci¢n del directorio [" + cDir + "] fu‚ exitosa"
 *      ENDIF
 *  $TESTS$
 *      Ver ejemplos
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper 5.3
 *  $PLATFORMS$
 *      Todas
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      DIRCHANGE(),DIRREMOVE(),ISDISK(),DISKCHANGE(),DISKNAME(),FERROR()
 *  $END$
 */

/*  $DOC$
 *  $FUNCNAME$
 *      ISDISK()
 *  $CATEGORY$
 *      Bajo Nivel
 *  $ONELINER$
 *      Verifica si un drive est  listo
 *  $SYNTAX$
 *      ISDISK( <cDrive> ) --> lExito
 *  $ARGUMENTS$
 *      <cDrive>  Una letra de drive que sea v lida
 *  $RETURNS$
 *      Devuelve un valor l¢gico <lExito>, es verdadero (.T.) si el drive
 *      est  listo, ¢ falso (.F.) si no est  listo.
 *  $DESCRIPTION$
 *      Esta funci¢n intenta acceder a un drive.  Si el aceso al drive fu‚
 *      Es £til para funcines de respaldo ¢ back-up, as¡ Ud. puede determinar
 *      si el drive que va a recibir los datos a resguardar est  listo ¢ no.
 *      Si esta funci¢n falla, devolver  el c¢digo num‚rico del sistema
 *      operativo correspondiente al £ltimo error ocurrido.
 *      Consulte la funci¢n FERROR() por una descripci¢n del error.
 *  $EXAMPLES$
 *      1) Testea el drive A:
 *
 *      IF ISDISK("A")
 *         ? "El Drive est  listo "
 *      ENDIF
 *
 *
 *      2) Testea el drive B:
 *      cDrive := "B"
 *
 *      IF ! ISDISK( cDrive )
 *         ? "El Drive [" + cDrive + ":] No est  disponible"
 *      ENDIF
 *  $TESTS$
 *      Ver ejemplos
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      Esta funci¢n es compatible con CA-Cl*pper 5.3
 *  $PLATFORMS$
 *      Todas
 *  $FILES$
 *      La librer¡a asociada es rtl
 *  $SEEALSO$
 *      DIRCHANGE(),MAKEDIR(),DIRREMOVE(),DISKCHANGE(),DISKNAME()
 *  $END$
 */



