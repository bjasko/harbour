/*
 * $Id$
 */

/*
 * Harbour Project source code:
 * Compiler SimpLex rules
 *
 * Copyright 2000 Ron Pinkas <ronpinkas@profit-master.com>
 * www - http://www.harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version, with one exception:
 *
 * The exception is that if you link the Harbour Runtime Library (HRL)
 * and/or the Harbour Virtual Machine (HVM) with other files to produce
 * an executable, this does not by itself cause the resulting executable
 * to be covered by the GNU General Public License. Your use of that
 * executable is in no way restricted on account of linking the HRL
 * and/or HVM code into it.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA (or visit
 * their web site at http://www.gnu.org/).
 */

#define NUMERALS_PER_LINE 512

//#define SHOW_LEX_TOKENS
//#define DEBUG_LEX

#ifdef DEBUG_LEX
   #undef DEBUG_INFO
      #define DEBUG_INFO(x) x
#endif

#undef LEX_ABBREVIATE_KEYS
   #define LEX_ABBREVIATE_KEYS 4

#undef LEX_ABBREVIATE_WORDS
   #define LEX_ABBREVIATE_WORDS 4

#undef YY_INPUT      /* to implement our own YY_INPUT function to manage PRGs without \n at the end */
   extern FILE * yyin;  /* currently yacc parsed file */
   int yy_lex_input( char *, int );
   #define YY_INPUT( buf, result, max_size ) result = yy_lex_input( buf, max_size );

#undef YY_BUF_SIZE
   #define YY_BUF_SIZE HB_PP_STR_SIZE

#undef STREAM_EXCEPTION
   #define STREAM_EXCEPTION( sPair, cChar ) \
	   if( sTerm[1] == ']' && iCloseSquare ) \
	   { \
              szBuffer -= ( ( strlen( sPair ) - iCloseSquare ) + 1 ); \
	      memmove( (char*) &(sPair[1]), (char*) &(sPair[0]), iCloseSquare - 1 ); \
	      sPair[0] = sStart[1]; \
	      sPair[ iCloseSquare ] = '\0'; \
              aiReturn[ iReturn++ ] = HB_LIT_ACT; \
	   } \
	   else \
	   { \
	      hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_STRING_TERMINATOR, sPair, NULL ); \
              aiReturn[ iReturn++ ] = '\n'; \
              yylval.string = hb_compIdentifierNew( sPair, TRUE ); \
              aiReturn[ iReturn++ ] = LITERAL; \
	   } \

#undef STREAM_APPEND
   #define STREAM_APPEND(x) \
   if( x == ']' && ! iCloseSquare ) iCloseSquare = iPairLen + 1; sPair[ iPairLen++ ] = x

#undef STREAM_OPEN
   #define STREAM_OPEN( sStarter ) \
      { \
         iCloseSquare = 0; \
	 \
         if( sStarter[0] == 'Q' ) \
           bTmp = FALSE /* TODO: hb_ppInsideTextBlock*/; \
         else \
           bTmp = TRUE; \
      } \
      if( bTmp )

static int iTexts = 0, iCloseSquare = 0;
static char * aTexts[ NUMERALS_PER_LINE ];
static char* sIdOnHold;

/*
static int iIdentifier = 0;
*/

long hb_lex_Hex2L( char* sHex );

/* -----------------------------------------------------  Language Definitions. ---------------------------------------------------- */

/* Delimiters. */
ACCEPT_TOKEN_AND_DROP_DELIMITER_IF_ONE_OF_THESE( " \t" );
ACCEPT_TOKEN_AND_RETURN_DELIMITER_IF_ONE_OF_THESE( "|,()[]{}^%*/+-:=!<>#@$" );
DELIMITER_BELONGS_TO_TOKEN_IF_ONE_OF_THESE( "" );

/* Custom Action can be requested by setting reduction to LEX_CUSTOM_ACTION or lower. */

/* Intermediate Token needed to be expanded. */
#define HB_LIT_ACT      -1001
#define HB_QOUT_ACT     -1002
#define HB_RET_QOUT_LIT -1003

/* Stream Pairs. */
DEFINE_STREAM_AS_ONE_OF_THESE {
                                START_WITH("\'")     END_WITH("\'")   STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("\"")     END_WITH("\"" )  STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("[")      END_WITH("]" )   STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(TRUE ) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("[\'")    END_WITH("\']" ) STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("[\"")    END_WITH("\"]" ) STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("[[")     END_WITH("]]" )  STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("QOUT([") END_WITH("])\n") STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_QOUT_ACT)
                              };

START_NEW_LINE_IF_ONE_OF_THESE( "\n;" );

/* Intermediate Token neede to be expanded. */
#define _DOT_DOT_  1001

SELF_CONTAINED_WORDS_ARE {
                           LEX_WORD( ".T."   ) AS_TOKEN( TRUEVALUE  ),
                           LEX_WORD( ".Y."   ) AS_TOKEN( TRUEVALUE  ),
                           LEX_WORD( ".F."   ) AS_TOKEN( FALSEVALUE ),
                           LEX_WORD( ".N."   ) AS_TOKEN( FALSEVALUE ),
                           LEX_WORD( ".NOT." ) AS_TOKEN( NOT        ),
                           LEX_WORD( ".AND." ) AS_TOKEN( AND        ),
                           LEX_WORD( ".OR."  ) AS_TOKEN( OR         ),
                           LEX_WORD( ":="    ) AS_TOKEN( INASSIGN   ),
                           LEX_WORD( "=="    ) AS_TOKEN( EQ         ),
                           LEX_WORD( "<>"    ) AS_TOKEN( NE2        ),
                           LEX_WORD( "!="    ) AS_TOKEN( NE2        ),
                           LEX_WORD( "++"    ) AS_TOKEN( INC        ),
                           LEX_WORD( "--"    ) AS_TOKEN( DEC        ),
                           LEX_WORD( "->"    ) AS_TOKEN( ALIASOP    ),
                           LEX_WORD( "<="    ) AS_TOKEN( LE         ),
                           LEX_WORD( ">="    ) AS_TOKEN( GE         ),
                           LEX_WORD( "+="    ) AS_TOKEN( PLUSEQ     ),
                           LEX_WORD( "-="    ) AS_TOKEN( MINUSEQ    ),
                           LEX_WORD( "*="    ) AS_TOKEN( MULTEQ     ),
                           LEX_WORD( "/="    ) AS_TOKEN( DIVEQ      ),
                           LEX_WORD( "**"    ) AS_TOKEN( POWER      ),
                           LEX_WORD( "^="    ) AS_TOKEN( EXPEQ      ),
                           LEX_WORD( "%="    ) AS_TOKEN( MODEQ      ),
                           LEX_WORD( "::"    ) AS_TOKEN( _DOT_DOT_  )
                         };

/* Intermediate Key Words when ambigious. */
#define EXIT_      1002
#define BEGIN_     1003
#define PROCREQ_   1004
#define FIELD_     1005
#define PRIVATE_   1006

/* Custom Actions - Suspend reserved words after these (waiting for Identifier). */
#define HB_FUNCTION  -1004
#define HB_PROCEDURE -1005
#define HB_EXTERN    -1006
#define HB_DECLARE   -1007
#define HB_PUBLIC    -1008
#define HB_PRIVATE   -1009
#define HB_LOCAL     -1010
#define HB_MEMVAR    -1011
#define HB_FIELD     -1012
#define HB_PARAM     -1013
#define HB_FOR       -1014
#define HB_OPTIONAL  -1015

/* When 2 identifiers are correct syntax like in class declaration, we have to temporarily store the 2nd identifier. */
/*
#define HB_ID_ON_HOLD -1016
*/

#define HB_MACRO_ERR -1017

#define HB_CHK_NEXT  -1018
#define HB_CHK_EXIT  -1019
#define HB_CHK_LOOP  -1020
#define HB_CHK_IN    -1021

#define HB_INIT_PROC -1022
#define HB_EXIT_PROC -1023
#define HB_INIT_FUNC -1024
#define HB_EXIT_FUNC -1025

#define HB_RET_FUNID -1026

/* Key Words. */
LANGUAGE_KEY_WORDS_ARE {
                         LEX_WORD( "FUNCTION"   ) AS_TOKEN( HB_FUNCTION ),
                         LEX_WORD( "PROCEDURE"  ) AS_TOKEN( HB_PROCEDURE),
                         LEX_WORD( "RETURN"     ) AS_TOKEN( RETURN      ),
                         LEX_WORD( "LOCAL"      ) AS_TOKEN( HB_LOCAL    ),
                         LEX_WORD( "STATIC"     ) AS_TOKEN( STATIC      ),
                         LEX_WORD( "IF"         ) AS_TOKEN( IF          ),
                         LEX_WORD( "ELSE"       ) AS_TOKEN( ELSE        ),
                         LEX_WORD( "ELSEIF"     ) AS_TOKEN( ELSEIF      ),
                         LEX_WORD( "END"        ) AS_TOKEN( END         ),
                         LEX_WORD( "ENDIF"      ) AS_TOKEN( ENDIF       ),
                         LEX_WORD( "ANNOUNCE"   ) AS_TOKEN( ANNOUNCE    ),
                         LEX_WORD( "EXTERNAL"   ) AS_TOKEN( HB_EXTERN   ),
                         LEX_WORD( "INIT"       ) AS_TOKEN( INIT        ),
                         LEX_WORD( "EXIT"       ) AS_TOKEN( EXIT_       ),
                         LEX_WORD( "PUBLIC"     ) AS_TOKEN( HB_PUBLIC   ),
                         LEX_WORD( "CASE"       ) AS_TOKEN( CASE        ),
                         LEX_WORD( "OTHERWISE"  ) AS_TOKEN( OTHERWISE   ),
                         LEX_WORD( "ENDCASE"    ) AS_TOKEN( ENDCASE     ),
                         LEX_WORD( "ENDDO"      ) AS_TOKEN( ENDDO       ),
                         LEX_WORD( "MEMVAR"     ) AS_TOKEN( HB_MEMVAR   ),
                         LEX_WORD( "LOOP"       ) AS_TOKEN( LOOP        ),
                         LEX_WORD( "FOR"        ) AS_TOKEN( HB_FOR      ),
                         LEX_WORD( "NEXT"       ) AS_TOKEN( NEXT        ),
                         LEX_WORD( "PARAMETERS" ) AS_TOKEN( HB_PARAM    ),
                         LEX_WORD( "PRIVATE"    ) AS_TOKEN( HB_PRIVATE  ),
                         LEX_WORD( "BEGIN"      ) AS_TOKEN( BEGIN_      ),
                         LEX_WORD( "BREAK"      ) AS_TOKEN( BREAK       ),
                         LEX_WORD( "RECOVER"    ) AS_TOKEN( RECOVER     ),
                         LEX_WORD( "DO"         ) AS_TOKEN( DO          ),
                         LEX_WORD( "WHILE"      ) AS_TOKEN( WHILE       ),
                         LEX_WORD( "DECLARE"    ) AS_TOKEN( HB_DECLARE  ),
                         LEX_WORD( "_PROCREQ_"  ) AS_TOKEN( PROCREQ_    ),
                         LEX_WORD( "FIELD"      ) AS_TOKEN( HB_FIELD    )
                       };

/* Intermediate Words when ambigious. */
#define _FUNC_      2001
#define _PROC_      2002
#define _IF_        2003
#define _USING_     2004
#define _SEQUENCE_  2005
#define _OF_        2006
#define QSELF       2007
#define _LINE_      2008
#define _AS_        2009
#define _ARRAY_     2010
#define _BLOCK_     2011
#define _STRING_    2012
#define _CLASS_     2013
#define _DATE_      2014
#define _LOGICAL_   2015
#define _NUMERIC_   2016
#define _OBJECT_    2017
#define _VARIANT_   2018
#define _FIELD_     2019
#define _FIELD      2020
#define _CASE_      2021
#define _WHILE_     2022
#define _WITH_      2023
#define _SELF_      2024

/* Words. */
LANGUAGE_WORDS_ARE {
                     LEX_WORD( "FUNCTION"  ) AS_TOKEN( _FUNC_      ),
                     LEX_WORD( "PROCEDURE" ) AS_TOKEN( _PROC_      ),
                     LEX_WORD( "IF"        ) AS_TOKEN( _IF_        ),
                     LEX_WORD( "CASE"      ) AS_TOKEN( _CASE_      ),
                     LEX_WORD( "WHILE"     ) AS_TOKEN( _WHILE_     ),
                     LEX_WORD( "SEQUENCE"  ) AS_TOKEN( _SEQUENCE_  ),
                     LEX_WORD( "USING"     ) AS_TOKEN( _USING_     ),
                     LEX_WORD( "OPTIONAL"  ) AS_TOKEN( HB_OPTIONAL ),
                     LEX_WORD( "NIL"       ) AS_TOKEN( NIL         ),
                     LEX_WORD( "IIF"       ) AS_TOKEN( IIF         ),
                     LEX_WORD( "TO"        ) AS_TOKEN( TO          ),
                     LEX_WORD( "STEP"      ) AS_TOKEN( STEP        ),
                     LEX_WORD( "IN"        ) AS_TOKEN( HB_CHK_IN   ),
                     LEX_WORD( "WITH"      ) AS_TOKEN( _WITH_      ),
                     LEX_WORD( "SELF"      ) AS_TOKEN( _SELF_      ),
                     LEX_WORD( "QSELF"     ) AS_TOKEN( QSELF       ),
                     LEX_WORD( "LINE"      ) AS_TOKEN( _LINE_      ),
                     LEX_WORD( "AS"        ) AS_TOKEN( _AS_        ),
                     LEX_WORD( "OF"        ) AS_TOKEN( _OF_        ),
                     LEX_WORD( "ARRAY"     ) AS_TOKEN( _ARRAY_     ),
                     LEX_WORD( "CODEBLOCK" ) AS_TOKEN( _BLOCK_     ),
                     LEX_WORD( "STRING"    ) AS_TOKEN( _STRING_    ),
                     LEX_WORD( "CLASS"     ) AS_TOKEN( _CLASS_     ),
                     LEX_WORD( "DATE"      ) AS_TOKEN( _DATE_      ),
                     LEX_WORD( "LOGICAL"   ) AS_TOKEN( _LOGICAL_   ),
                     LEX_WORD( "NUMERIC"   ) AS_TOKEN( _NUMERIC_   ),
                     LEX_WORD( "OBJECT"    ) AS_TOKEN( _OBJECT_    ),
                     LEX_WORD( "ANYTYPE"   ) AS_TOKEN( _VARIANT_   ),
                     LEX_WORD( "FIELD"     ) AS_TOKEN( _FIELD_     ),
                     LEX_WORD( "_FIELD"    ) AS_TOKEN( _FIELD      )
                   };

/* When reservered words are used as Identifier. */
#define HB_EXTERN_ID      -2001
#define HB_AS_ID          -2002
#define HB_OF_ID          -2003
#define HB_ARRAY_ID       -2004
#define HB_VARIANT_ID     -2005
#define HB_BLOCK_ID       -2006
#define HB_STRING_ID      -2007
#define HB_CLASS_ID       -2008
#define HB_DATE_ID        -2009
#define HB_LOGICAL_ID     -2010
#define HB_NUMEIC_ID      -2011
#define HB_OBJECT_ID      -2012
#define HB_PUBLIC_ID      -2013
#define HB_OTHERWISE_ID   -2014
#define HB_MEMVAR_ID      -2015
#define HB_WHILE_ID       -2016
#define HB_LOOP_ID        -2017
#define HB_FOR_ID         -2018
#define HB_NEXT_ID        -2019
#define HB_FIELD_ID       -2020
#define HB_PARAMETERS_ID  -2021
#define HB_PRIVATE_ID     -2022
#define HB_EXIT_ID        -2023
#define HB_BEGIN_ID       -2024
#define HB_SEQUENCE_ID    -2025
#define HB_BREAK_ID       -2026
#define HB_RECOVER_ID     -2027
#define HB_USING_ID       -2028
#define HB_CASE_ID        -2029
#define HB_DO_ID          -2030
#define HB_WITH_ID        -2031
#define HB_DECLARE_ID     -2032
#define HB_PROCREQ_ID     -2033
#define HB_SELF_ID        -2034
#define HB_IF_ID          -2035
#define HB_IIF_ID         -2036
#define HB_OPTIONAL_ID    -2037
#define HB_IN_ID          -2038
#define HB__FIELD_ID      -2039
#define HB_LINE_ID        -2040
#define HB_INIT_ID        -2041
#define HB_PROCEDURE_ID   -2042
#define HB_FUNCTION_ID    -2043
#define HB_STATIC_ID      -2044
#define HB_LOCAL_ID       -2045
#define HB_QSELF_ID       -2046
#define HB_RETURN_ID      -2047
#define HB_END_ID         -2048

/* Intermediate Reductions when still ambigious or need further reductions. */
#define _WHILE_WITH       3001
#define _ID_ARRAY         3002
#define _ID_COMMA         3003
#define _ID_CR            3004
#define _ID_SEMI          3005
#define _ID_ASSIGN        3006
#define _ID_AS            3007
#define _CASE_WITH        3008
#define _WHL_ID_CR        3009
#define _WHL_ID_SEMI      3010
#define _VAR_ARRAY        3011
#define _TEXT_ARRAY       3012
#define _INC_CR           3013
#define _INC_SEMI         3014
#define _DEC_CR           3015
#define _DEC_SEMI         3016

#define HB_QOUT_LIT       3017

LANGUAGE_RULES_ARE {
                    IF_SEQUENCE_IS( '^'         , 0           , 0      , 0          ) REDUCE_TO( POWER             , 0             ),
                    IF_SEQUENCE_IS( '!'         , 0           , 0      , 0          ) REDUCE_TO( NOT               , 0             ),

                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , 0      , 0          ) REDUCE_TO( AS_ARRAY          , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _BLOCK_     , 0      , 0          ) REDUCE_TO( AS_BLOCK          , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _STRING_    , 0      , 0          ) REDUCE_TO( AS_CHARACTER      , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _CLASS_     , 0      , 0          ) REDUCE_TO( AS_CLASS          , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _DATE_      , 0      , 0          ) REDUCE_TO( AS_DATE           , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _LOGICAL_   , 0      , 0          ) REDUCE_TO( AS_LOGICAL        , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _NUMERIC_   , 0      , 0          ) REDUCE_TO( AS_NUMERIC        , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _OBJECT_    , 0      , 0          ) REDUCE_TO( AS_OBJECT         , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _VARIANT_   , 0      , 0          ) REDUCE_TO( AS_VARIANT        , 0             ),

                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , _OF_   , _ARRAY_    ) REDUCE_TO( AS_ARRAY_ARRAY    , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , _OF_   , _VARIANT_  ) REDUCE_TO( AS_ARRAY_ARRAY    , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , _OF_   , _BLOCK_    ) REDUCE_TO( AS_BLOCK_ARRAY    , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , _OF_   , _STRING_   ) REDUCE_TO( AS_CHARACTER_ARRAY, 0             ),
                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , _OF_   , _CLASS_    ) REDUCE_TO( AS_CLASS_ARRAY    , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , _OF_   , _DATE_     ) REDUCE_TO( AS_DATE_ARRAY     , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , _OF_   , _LOGICAL_  ) REDUCE_TO( AS_LOGICAL_ARRAY  , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , _OF_   , _NUMERIC_  ) REDUCE_TO( AS_NUMERIC_ARRAY  , 0             ),
                    IF_SEQUENCE_IS( _AS_        , _ARRAY_     , _OF_   , _OBJECT_   ) REDUCE_TO( AS_OBJECT_ARRAY   , 0             ),

		    /* Treat as Identifiers when not qualified with the AS qualifier. */
                    IF_SEQUENCE_IS( _AS_        , 0           , 0      , 0          ) REDUCE_TO( HB_AS_ID          , 0             ),
                    IF_SEQUENCE_IS( _OF_        , 0           , 0      , 0          ) REDUCE_TO( HB_OF_ID          , 0             ),
                    IF_SEQUENCE_IS( _ARRAY_     , 0           , 0      , 0          ) REDUCE_TO( HB_ARRAY_ID       , 0             ),
                    IF_SEQUENCE_IS( _VARIANT_   , 0           , 0      , 0          ) REDUCE_TO( HB_VARIANT_ID     , 0             ),
                    IF_SEQUENCE_IS( _BLOCK_     , 0           , 0      , 0          ) REDUCE_TO( HB_BLOCK_ID       , 0             ),
                    IF_SEQUENCE_IS( _STRING_    , 0           , 0      , 0          ) REDUCE_TO( HB_STRING_ID      , 0             ),
                    IF_SEQUENCE_IS( _CLASS_     , 0           , 0      , 0          ) REDUCE_TO( HB_CLASS_ID       , 0             ),
                    IF_SEQUENCE_IS( _DATE_      , 0           , 0      , 0          ) REDUCE_TO( HB_DATE_ID        , 0             ),
                    IF_SEQUENCE_IS( _LOGICAL_   , 0           , 0      , 0          ) REDUCE_TO( HB_LOGICAL_ID     , 0             ),
                    IF_SEQUENCE_IS( _NUMERIC_   , 0           , 0      , 0          ) REDUCE_TO( HB_NUMEIC_ID      , 0             ),
                    IF_SEQUENCE_IS( _OBJECT_    , 0           , 0      , 0          ) REDUCE_TO( HB_OBJECT_ID      , 0             ),

                    IF_SEQUENCE_IS( FUNCTION    , IDENTIFIER  , 0      , 0          ) REDUCE_TO( HB_RET_FUNID      , 0            ),
                    IF_SEQUENCE_IS( FUNCTION    , '['         , 0      , 0          ) REDUCE_TO( HB_FUNCTION_ID    , '['          ),
                    IF_SEQUENCE_IS( FUNCTION    , 0           , 0      , 0          ) REDUCE_TO( HB_FUNCTION_ID    , 0            ),

                    IF_SEQUENCE_IS( PROCEDURE   , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( PROCEDURE   , '['         , 0      , 0          ) REDUCE_TO( HB_PROCEDURE_ID   , '['          ),
                    IF_SEQUENCE_IS( PROCEDURE   , 0           , 0      , 0          ) REDUCE_TO( HB_PROCEDURE_ID   , 0            ),

                    IF_SEQUENCE_IS( EXTERN      , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( EXTERN      , '['         , 0      , 0          ) REDUCE_TO( HB_EXTERN_ID      , '['          ),
                    IF_SEQUENCE_IS( EXTERN      , 0           , 0      , 0          ) REDUCE_TO( HB_EXTERN_ID      , 0            ),

                    IF_SEQUENCE_IS( END         , INASSIGN    , 0      , 0          ) REDUCE_TO( HB_END_ID         , INASSIGN      ),
                    IF_SEQUENCE_IS( END         , INC         , 0      , 0          ) REDUCE_TO( HB_END_ID         , INC           ),
                    IF_SEQUENCE_IS( END         , DEC         , 0      , 0          ) REDUCE_TO( HB_END_ID         , DEC           ),
                    IF_SEQUENCE_IS( END         , ALIASOP     , 0      , 0          ) REDUCE_TO( HB_END_ID         , ALIASOP       ),
                    IF_SEQUENCE_IS( END         , PLUSEQ      , 0      , 0          ) REDUCE_TO( HB_END_ID         , PLUSEQ        ),
                    IF_SEQUENCE_IS( END         , MINUSEQ     , 0      , 0          ) REDUCE_TO( HB_END_ID         , MINUSEQ       ),
                    IF_SEQUENCE_IS( END         , MULTEQ      , 0      , 0          ) REDUCE_TO( HB_END_ID         , MULTEQ        ),
                    IF_SEQUENCE_IS( END         , DIVEQ       , 0      , 0          ) REDUCE_TO( HB_END_ID         , DIVEQ         ),
                    IF_SEQUENCE_IS( END         , EXPEQ       , 0      , 0          ) REDUCE_TO( HB_END_ID         ,  EXPEQ        ),
                    IF_SEQUENCE_IS( END         , MODEQ       , 0      , 0          ) REDUCE_TO( HB_END_ID         ,  MODEQ        ),
                    IF_SEQUENCE_IS( END         , '('         , 0      , 0          ) REDUCE_TO( HB_END_ID         , '('           ),
                    IF_SEQUENCE_IS( END         , '['         , 0      , 0          ) REDUCE_TO( HB_END_ID         , '['           ),
                    IF_SEQUENCE_IS( END         , '='         , 0      , 0          ) REDUCE_TO( HB_END_ID         , '='           ),
                    IF_SEQUENCE_IS( END         , ':'         , 0      , 0          ) REDUCE_TO( HB_END_ID         , ':'           ),
                    IF_SEQUENCE_IS( END         , _SEQUENCE_  , 0      , 0          ) REDUCE_TO( END               , 0             ),
                    IF_SEQUENCE_IS( END         , 0           , 0      , 0          ) PASS_THROUGH(),

		    /* DECLARE as PRIVATE. */
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , '['    , 0          ) REDUCE_TO( PRIVATE           , _ID_ARRAY     ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , ','    , 0          ) REDUCE_TO( PRIVATE           , _ID_COMMA     ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , '\n'   , 0          ) REDUCE_TO( PRIVATE           , _ID_CR        ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , ';'    , 0          ) REDUCE_TO( PRIVATE           , _ID_SEMI      ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  ,INASSIGN, 0          ) REDUCE_TO( PRIVATE           , _ID_ASSIGN    ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  ,_AS_    , 0          ) REDUCE_TO( PRIVATE           , _ID_AS        ),
                    IF_SEQUENCE_IS( DECLARE     , MACROVAR    , 0      , 0          ) REDUCE_TO( PRIVATE           , MACROVAR      ),
                    IF_SEQUENCE_IS( DECLARE     , MACROTEXT   , 0      , 0          ) REDUCE_TO( PRIVATE           , MACROTEXT     ),
                    IF_SEQUENCE_IS( _ID_ARRAY   , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER        , '['           ),
                    IF_SEQUENCE_IS( _ID_COMMA   , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER        , ','           ),
                    IF_SEQUENCE_IS( _ID_CR      , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER        , '\n'          ),
                    IF_SEQUENCE_IS( _ID_SEMI    , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER        , ';'           ),
                    IF_SEQUENCE_IS( _ID_ASSIGN  , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER        , INASSIGN      ),
                    IF_SEQUENCE_IS( _ID_AS      , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER        , _AS_          ),

		    /* Anything DECLARE IDENTIFIER, must be Strong Type DECLARE. */
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),

		    /* Anthing else, DECLARE as Identifier. */
                    IF_SEQUENCE_IS( DECLARE     , '['         , 0      , 0          ) REDUCE_TO( HB_DECLARE_ID      , '['          ),
                    IF_SEQUENCE_IS( DECLARE     , 0           , 0      , 0          ) REDUCE_TO( HB_DECLARE_ID      ,              ),

                    IF_SEQUENCE_IS( PUBLIC      , IDENTIFIER  , '['    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( PUBLIC      , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( PUBLIC      , MACROVAR    , '['    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( PUBLIC      , MACROVAR    , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( PUBLIC      , MACROTEXT   , '['    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( PUBLIC      , MACROTEXT   , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( PUBLIC      , '['         , 0      , 0          ) REDUCE_TO( HB_PUBLIC_ID      , '['           ),
                    IF_SEQUENCE_IS( PUBLIC      , 0           , 0      , 0          ) REDUCE_TO( HB_PUBLIC_ID      , 0             ),

                    IF_SEQUENCE_IS( PRIVATE_    , IDENTIFIER  , '['    , 0          ) REDUCE_TO( PRIVATE           , _ID_ARRAY     ),
                    IF_SEQUENCE_IS( PRIVATE_    , IDENTIFIER  , 0      , 0          ) REDUCE_TO( PRIVATE           , IDENTIFIER    ),
                    IF_SEQUENCE_IS( PRIVATE_    , MACROVAR    , '['    , 0          ) REDUCE_TO( PRIVATE           , _VAR_ARRAY    ),
                    IF_SEQUENCE_IS( PRIVATE_    , MACROVAR    , 0      , 0          ) REDUCE_TO( PRIVATE           , MACROVAR      ),
                    IF_SEQUENCE_IS( PRIVATE_    , MACROTEXT   , '['    , 0          ) REDUCE_TO( PRIVATE           , _TEXT_ARRAY   ),
                    IF_SEQUENCE_IS( PRIVATE_    , MACROTEXT   , 0      , 0          ) REDUCE_TO( PRIVATE           , MACROTEXT     ),
                    IF_SEQUENCE_IS( PRIVATE_    , '['         , 0      , 0          ) REDUCE_TO( PRIVATE           , '['           ),
                    IF_SEQUENCE_IS( PRIVATE_    , 0           , 0      , 0          ) REDUCE_TO( HB_PRIVATE_ID     , 0             ),
                    IF_SEQUENCE_IS( _VAR_ARRAY  , 0           , 0      , 0          ) REDUCE_TO( MACROVAR          , '['           ),
                    IF_SEQUENCE_IS( _TEXT_ARRAY , 0           , 0      , 0          ) REDUCE_TO( MACROTEXT         , '['           ),

                    IF_SEQUENCE_IS( LOCAL       , IDENTIFIER  , '['    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( LOCAL       , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( LOCAL       , '['         , 0      , 0          ) REDUCE_TO( HB_LOCAL_ID       , '['           ),
                    IF_SEQUENCE_IS( LOCAL       , 0           , 0      , 0          ) REDUCE_TO( HB_LOCAL_ID       , 0             ),

		    /* STATIC Func/Proc. */
                    IF_SEQUENCE_IS( STATIC      , _PROC_      , 0      , 0          ) REDUCE_TO( STATIC            , PROCEDURE     ),
                    IF_SEQUENCE_IS( STATIC      , _FUNC_      , 0      , 0          ) REDUCE_TO( STATIC            , FUNCTION      ),

		    /* STATIC IDENTIFIER - Exclusion works best here because we may also have STATIC Func/Proc (above). */
                    IF_SEQUENCE_IS( STATIC      , INASSIGN    , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , INASSIGN      ),
                    IF_SEQUENCE_IS( STATIC      , INC         , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , INC           ),
                    IF_SEQUENCE_IS( STATIC      , DEC         , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , DEC           ),
                    IF_SEQUENCE_IS( STATIC      , ALIASOP     , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , ALIASOP       ),
                    IF_SEQUENCE_IS( STATIC      , PLUSEQ      , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , PLUSEQ        ),
                    IF_SEQUENCE_IS( STATIC      , MINUSEQ     , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , MINUSEQ       ),
                    IF_SEQUENCE_IS( STATIC      , MULTEQ      , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , MULTEQ        ),
                    IF_SEQUENCE_IS( STATIC      , DIVEQ       , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , DIVEQ         ),
                    IF_SEQUENCE_IS( STATIC      , EXPEQ       , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      ,  EXPEQ        ),
                    IF_SEQUENCE_IS( STATIC      , MODEQ       , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      ,  MODEQ        ),
                    IF_SEQUENCE_IS( STATIC      , '('         , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , '('           ),
                    IF_SEQUENCE_IS( STATIC      , '['         , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , '['           ),
                    IF_SEQUENCE_IS( STATIC      , '='         , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , '='           ),
                    IF_SEQUENCE_IS( STATIC      , ':'         , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , ':'           ),
                    IF_SEQUENCE_IS( STATIC      , ';'         , 0      , 0          ) REDUCE_TO( HB_STATIC_ID      , ';'           ),
                    IF_SEQUENCE_IS( STATIC      , 0           , 0      , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( MEMVAR      , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( MEMVAR      , '['         , 0      , 0          ) REDUCE_TO( HB_MEMVAR_ID      , '['           ),
                    IF_SEQUENCE_IS( MEMVAR      , 0           , 0      , 0          ) REDUCE_TO( HB_MEMVAR_ID      , 0             ),

                    IF_SEQUENCE_IS( FIELD_      , IDENTIFIER  , 0      , 0          ) REDUCE_TO( FIELD             , IDENTIFIER    ),
                    IF_SEQUENCE_IS( FIELD_      , '['         , 0      , 0          ) REDUCE_TO( HB_FIELD_ID       , '['           ),
                    IF_SEQUENCE_IS( FIELD_      , 0           , 0      , 0          ) REDUCE_TO( HB_FIELD_ID       , 0             ),

                    IF_SEQUENCE_IS( PARAMETERS  , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( PARAMETERS  , '['         , 0      , 0          ) REDUCE_TO( HB_PARAMETERS_ID  , '['           ),
                    IF_SEQUENCE_IS( PARAMETERS  , 0           , 0      , 0          ) REDUCE_TO( HB_PARAMETERS_ID  , 0             ),

		    /* This _FIELD_ is FIELD NOT at BOL wants only ->. */
                    IF_SEQUENCE_IS( _FIELD_     , ALIASOP     , 0      , 0          ) REDUCE_TO( FIELD             , ALIASOP       ),
                    IF_SEQUENCE_IS( _FIELD_     , '['         , 0      , 0          ) REDUCE_TO( HB_FIELD_ID       , '['           ),
                    IF_SEQUENCE_IS( _FIELD_     , 0           , 0      , 0          ) REDUCE_TO( HB_FIELD_ID       , 0             ),

		    /* This _FIELD is _FIELD NOT at BOL wants only ->. */
                    IF_SEQUENCE_IS( _FIELD      , ALIASOP     , 0      , 0          ) REDUCE_TO( FIELD             , ALIASOP       ),
                    IF_SEQUENCE_IS( _FIELD      , '['         , 0      , 0          ) REDUCE_TO( HB__FIELD_ID      , '['           ),
                    IF_SEQUENCE_IS( _FIELD      , 0           , 0      , 0          ) REDUCE_TO( HB__FIELD_ID      , 0             ),

                    IF_SEQUENCE_IS( OTHERWISE   , '\n'        , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( OTHERWISE   , ';'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( OTHERWISE   , '['         , 0      , 0          ) REDUCE_TO( HB_OTHERWISE_ID   , '['           ),
                    IF_SEQUENCE_IS( OTHERWISE   , 0           , 0      , 0          ) REDUCE_TO( HB_OTHERWISE_ID   , 0             ),

                    IF_SEQUENCE_IS( RETURN      , INASSIGN    , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , INASSIGN      ),
                    IF_SEQUENCE_IS( RETURN      , INC         , '\n'   , 0          ) REDUCE_TO( HB_RETURN_ID      , _INC_CR       ),
                    IF_SEQUENCE_IS( RETURN      , INC         , ';'    , 0          ) REDUCE_TO( HB_RETURN_ID      , _INC_SEMI     ),
                    IF_SEQUENCE_IS( RETURN      , DEC         , '\n'   , 0          ) REDUCE_TO( HB_RETURN_ID      , _DEC_CR       ),
                    IF_SEQUENCE_IS( RETURN      , DEC         , ';'    , 0          ) REDUCE_TO( HB_RETURN_ID      , _DEC_SEMI     ),
                    IF_SEQUENCE_IS( RETURN      , ALIASOP     , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , ALIASOP       ),
                    IF_SEQUENCE_IS( RETURN      , PLUSEQ      , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , PLUSEQ        ),
                    IF_SEQUENCE_IS( RETURN      , MINUSEQ     , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , MINUSEQ       ),
                    IF_SEQUENCE_IS( RETURN      , MULTEQ      , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , MULTEQ        ),
                    IF_SEQUENCE_IS( RETURN      , DIVEQ       , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , DIVEQ         ),
                    IF_SEQUENCE_IS( RETURN      , EXPEQ       , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      ,  EXPEQ        ),
                    IF_SEQUENCE_IS( RETURN      , MODEQ       , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      ,  MODEQ        ),
                 /* IF_SEQUENCE_IS( RETURN      , '('         , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , '('           ),
                    IF_SEQUENCE_IS( RETURN      , '['         , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , '['           ), */
                    IF_SEQUENCE_IS( RETURN      , '='         , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , '='           ),
                    IF_SEQUENCE_IS( RETURN      , ':'         , 0      , 0          ) REDUCE_TO( HB_RETURN_ID      , ':'           ),
                    IF_SEQUENCE_IS( RETURN      , 0           , 0      , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( FOR         , IDENTIFIER  , '['    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( FOR         , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( FOR         , MACROVAR    , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( FOR         , MACROTEXT   , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( FOR         , '['         , 0      , 0          ) REDUCE_TO( HB_FOR_ID         , '['           ),
                    IF_SEQUENCE_IS( FOR         , 0           , 0      , 0          ) REDUCE_TO( HB_FOR_ID         , 0             ),

                    IF_SEQUENCE_IS( NEXT        , '\n'        , 0      , 0          ) REDUCE_TO( HB_CHK_NEXT       , '\n'          ),
                    IF_SEQUENCE_IS( NEXT        , ';'         , 0      , 0          ) REDUCE_TO( HB_CHK_NEXT       , ';'           ),
                    IF_SEQUENCE_IS( NEXT        , '['         , 0      , 0          ) REDUCE_TO( HB_NEXT_ID        , '['           ),
                    IF_SEQUENCE_IS( NEXT        , 0           , 0      , 0          ) REDUCE_TO( HB_NEXT_ID        , 0             ),

                    IF_SEQUENCE_IS( EXIT_       , '\n'        , 0      , 0          ) REDUCE_TO( HB_CHK_EXIT       , '\n'          ),
                    IF_SEQUENCE_IS( EXIT_       , ';'         , 0      , 0          ) REDUCE_TO( HB_CHK_EXIT       , ';'           ),

                    IF_SEQUENCE_IS( INIT        , _PROC_      , 0      , 0          ) REDUCE_TO( HB_INIT_PROC      , 0             ),
                    IF_SEQUENCE_IS( INIT        , _FUNC_      , 0      , 0          ) REDUCE_TO( HB_INIT_FUNC      , 0             ),
                    IF_SEQUENCE_IS( INIT        ,  '['        , 0      , 0          ) REDUCE_TO( HB_INIT_ID        , '['           ),
                    IF_SEQUENCE_IS( INIT        ,  0          , 0      , 0          ) REDUCE_TO( HB_INIT_ID        , 0             ),

                    IF_SEQUENCE_IS( EXIT_       , _PROC_      , 0      , 0          ) REDUCE_TO( HB_EXIT_PROC      , 0             ),
                    IF_SEQUENCE_IS( EXIT_       , _FUNC_      , 0      , 0          ) REDUCE_TO( HB_EXIT_FUNC      , 0             ),
                    IF_SEQUENCE_IS( EXIT_       , '['         , 0      , 0          ) REDUCE_TO( HB_EXIT_ID        , '['           ),
                    IF_SEQUENCE_IS( EXIT_       , 0           , 0      , 0          ) REDUCE_TO( HB_EXIT_ID        , 0             ),

                    /* LOOP at BOL if followed by anything other the NEW LINE than Identifier else LOOP. */
                    IF_SEQUENCE_IS( LOOP        , '\n'        , 0      , 0          ) REDUCE_TO( HB_CHK_LOOP       , '\n'          ),
                    IF_SEQUENCE_IS( LOOP        , ';'         , 0      , 0          ) REDUCE_TO( HB_CHK_LOOP       , ';'           ),
                    IF_SEQUENCE_IS( LOOP        , '['         , 0      , 0          ) REDUCE_TO( HB_LOOP_ID        , '['           ),
                    IF_SEQUENCE_IS( LOOP        , 0           , 0      , 0          ) REDUCE_TO( HB_LOOP_ID        , 0             ),

		    /* ---------------------------  BEGIN SEQUENCE ; BREAK ; RECOVER ; RECOVER USING   --------------------------- */
                    IF_SEQUENCE_IS( BEGIN_      , _SEQUENCE_  , 0      , 0          ) REDUCE_TO( BEGINSEQ          , 0             ),
                    IF_SEQUENCE_IS( BEGIN_      , '['         , 0      , 0          ) REDUCE_TO( HB_BEGIN_ID       , '['           ),
                    IF_SEQUENCE_IS( BEGIN_      , 0           , 0      , 0          ) REDUCE_TO( HB_BEGIN_ID       , 0             ),
                    IF_SEQUENCE_IS( _SEQUENCE_  , 0           , 0      , 0          ) REDUCE_TO( HB_SEQUENCE_ID    , 0             ),

                    IF_SEQUENCE_IS( BREAK       , INASSIGN    , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , INASSIGN      ),
                    IF_SEQUENCE_IS( BREAK       , INC         , '\n'   , 0          ) REDUCE_TO( HB_BREAK_ID       , _INC_CR       ),
                    IF_SEQUENCE_IS( BREAK       , INC         , ';'    , 0          ) REDUCE_TO( HB_BREAK_ID       , _INC_SEMI     ),
                    IF_SEQUENCE_IS( BREAK       , DEC         , '\n'   , 0          ) REDUCE_TO( HB_BREAK_ID       , _DEC_CR       ),
                    IF_SEQUENCE_IS( BREAK       , DEC         , ';'    , 0          ) REDUCE_TO( HB_BREAK_ID       , _DEC_SEMI     ),
                    IF_SEQUENCE_IS( BREAK       , ALIASOP     , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , ALIASOP       ),
                    IF_SEQUENCE_IS( BREAK       , PLUSEQ      , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , PLUSEQ        ),
                    IF_SEQUENCE_IS( BREAK       , MINUSEQ     , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , MINUSEQ       ),
                    IF_SEQUENCE_IS( BREAK       , MULTEQ      , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , MULTEQ        ),
                    IF_SEQUENCE_IS( BREAK       , DIVEQ       , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , DIVEQ         ),
                    IF_SEQUENCE_IS( BREAK       , EXPEQ       , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       ,  EXPEQ        ),
                    IF_SEQUENCE_IS( BREAK       , MODEQ       , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       ,  MODEQ        ),
                /*  IF_SEQUENCE_IS( BREAK       , '('         , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , '('           ),
                    IF_SEQUENCE_IS( BREAK       , '['         , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , '['           ), */
                    IF_SEQUENCE_IS( BREAK       , '='         , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , '='           ),
                    IF_SEQUENCE_IS( BREAK       , ':'         , 0      , 0          ) REDUCE_TO( HB_BREAK_ID       , ':'           ),
                    IF_SEQUENCE_IS( BREAK       , 0           , 0      , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( RECOVER     , _USING_     , 0      , 0          ) REDUCE_TO( RECOVERUSING      , 0             ),
                    IF_SEQUENCE_IS( RECOVER     , '\n'        , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( RECOVER     , ';'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( RECOVER     , '['         , 0      , 0          ) REDUCE_TO( HB_RECOVER_ID     , '['           ),
                    IF_SEQUENCE_IS( RECOVER     , 0           , 0      , 0          ) REDUCE_TO( HB_RECOVER_ID     , 0             ),
                    IF_SEQUENCE_IS( _USING_     , '['         , 0      , 0          ) REDUCE_TO( HB_USING_ID       , '['           ),
                    IF_SEQUENCE_IS( _USING_     , 0           , 0      , 0          ) REDUCE_TO( HB_USING_ID       , 0             ),

		    /* --------------------------  DO WHILE; WHILE ; DO CASE ; CASE; DO ... ; DO ... WITH  ----------------------- */
                    IF_SEQUENCE_IS( DO          , _WHILE_     , _WITH_ , 0          ) REDUCE_TO( DO                , _WHILE_WITH   ),
                    IF_SEQUENCE_IS( DO          , _CASE_      , _WITH_ , 0          ) REDUCE_TO( DO                , _CASE_WITH    ),
                    IF_SEQUENCE_IS( DO          , _WHILE_     , '\n'   , 0          ) REDUCE_TO( DO                , _WHL_ID_CR    ),
                    IF_SEQUENCE_IS( DO          , _WHILE_     , ';'    , 0          ) REDUCE_TO( DO                , _WHL_ID_SEMI  ),
                    IF_SEQUENCE_IS( DO          , _WITH_      , 0      , 0          ) REDUCE_TO( DO                , HB_WITH_ID    ),
                    IF_SEQUENCE_IS( DO          , OPTIONAL    , 0      , 0          ) REDUCE_TO( DO                , HB_OPTIONAL_ID),
                    IF_SEQUENCE_IS( DO          , IN          , 0      , 0          ) REDUCE_TO( DO                , HB_IN_ID      ),
                    IF_SEQUENCE_IS( DO          , _WHILE_     , 0      , 0          ) REDUCE_TO( WHILE             , 0             ),
                    IF_SEQUENCE_IS( _WHILE_     , '['         , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , '['          ),
                    IF_SEQUENCE_IS( _WHILE_     , 0           , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , 0            ),

                    IF_SEQUENCE_IS( _WHILE_WITH , 0           , 0      , 0          ) REDUCE_TO( HB_WHILE_ID       , WITH          ),
                    IF_SEQUENCE_IS( _CASE_WITH  , 0           , 0      , 0          ) REDUCE_TO( HB_CASE_ID        , WITH          ),
                    IF_SEQUENCE_IS( _WHL_ID_CR  , 0           , 0      , 0          ) REDUCE_TO( HB_WHILE_ID       , '\n'          ),
                    IF_SEQUENCE_IS( _WHL_ID_SEMI, 0           , 0      , 0          ) REDUCE_TO( HB_WHILE_ID       , ';'           ),

                    /* This WHILE is only at BOL if followed by operator (other than logicals .t., .f., !) than Identifier else CASE. */
                    IF_SEQUENCE_IS( WHILE       , INASSIGN    , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , INASSIGN     ),
                    IF_SEQUENCE_IS( WHILE       , INC         , '\n'   , 0          ) REDUCE_TO( HB_WHILE_ID       , _INC_CR       ),
                    IF_SEQUENCE_IS( WHILE       , INC         , ';'    , 0          ) REDUCE_TO( HB_WHILE_ID       , _INC_SEMI     ),
                    IF_SEQUENCE_IS( WHILE       , DEC         , '\n'   , 0          ) REDUCE_TO( HB_WHILE_ID       , _DEC_CR       ),
                    IF_SEQUENCE_IS( WHILE       , DEC         , ';'    , 0          ) REDUCE_TO( HB_WHILE_ID       , _DEC_SEMI     ),
                    IF_SEQUENCE_IS( WHILE       , ALIASOP     , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , ALIASOP      ),
                    IF_SEQUENCE_IS( WHILE       , PLUSEQ      , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , PLUSEQ       ),
                    IF_SEQUENCE_IS( WHILE       , MINUSEQ     , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , MINUSEQ      ),
                    IF_SEQUENCE_IS( WHILE       , MULTEQ      , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , MULTEQ       ),
                    IF_SEQUENCE_IS( WHILE       , DIVEQ       , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , DIVEQ        ),
                    IF_SEQUENCE_IS( WHILE       , EXPEQ       , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    ,  EXPEQ       ),
                    IF_SEQUENCE_IS( WHILE       , MODEQ       , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    ,  MODEQ       ),
                 /* IF_SEQUENCE_IS( WHILE       , '('         , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , '('          ),
                    IF_SEQUENCE_IS( WHILE       , '['         , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , '['          ), */
                    IF_SEQUENCE_IS( WHILE       , '='         , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , '='          ),
                    IF_SEQUENCE_IS( WHILE       , ':'         , 0      , 0          ) REDUCE_TO( HB_WHILE_ID 	    , ':'          ),
                    IF_SEQUENCE_IS( WHILE       , 0           , 0      , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( DO          , _CASE_      , 0      , 0          ) REDUCE_TO( DOCASE      	    , 0            ),
                    IF_SEQUENCE_IS( _CASE_      , '['         , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , '['          ),
                    IF_SEQUENCE_IS( _CASE_      , 0           , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , 0            ),

                    /* This CASE is only at BOL if followed by operator (other than logicals .t., .f., !) than Identifier else CASE. */
                    IF_SEQUENCE_IS( CASE        , INASSIGN    , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , INASSIGN     ),
                    IF_SEQUENCE_IS( CASE        , INC         , '\n'   , 0          ) REDUCE_TO( HB_CASE_ID         , _INC_CR      ),
                    IF_SEQUENCE_IS( CASE        , INC         , ';'    , 0          ) REDUCE_TO( HB_CASE_ID         , _INC_SEMI    ),
                    IF_SEQUENCE_IS( CASE        , DEC         , '\n'   , 0          ) REDUCE_TO( HB_CASE_ID         , _DEC_CR      ),
                    IF_SEQUENCE_IS( CASE        , DEC         , ';'    , 0          ) REDUCE_TO( HB_CASE_ID         , _DEC_SEMI    ),
                    IF_SEQUENCE_IS( CASE        , ALIASOP     , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , ALIASOP      ),
                    IF_SEQUENCE_IS( CASE        , PLUSEQ      , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , PLUSEQ       ),
                    IF_SEQUENCE_IS( CASE        , MINUSEQ     , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , MINUSEQ      ),
                    IF_SEQUENCE_IS( CASE        , MULTEQ      , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , MULTEQ       ),
                    IF_SEQUENCE_IS( CASE        , DIVEQ       , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , DIVEQ        ),
                    IF_SEQUENCE_IS( CASE        , EXPEQ       , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , EXPEQ        ),
                    IF_SEQUENCE_IS( CASE        , MODEQ       , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , MODEQ        ),
                 /* IF_SEQUENCE_IS( CASE        , '('         , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , '('          ),
                    IF_SEQUENCE_IS( CASE        , '['         , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , '['          ), */
                    IF_SEQUENCE_IS( CASE        , '='         , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , '='          ),
                    IF_SEQUENCE_IS( CASE        , ':'         , 0      , 0          ) REDUCE_TO( HB_CASE_ID  	    , ':'          ),
                    IF_SEQUENCE_IS( CASE        , 0           , 0      , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( _INC_CR     , 0           , 0      , 0          ) REDUCE_TO( INC 	            , '\n'         ),
                    IF_SEQUENCE_IS( _INC_SEMI   , 0           , 0      , 0          ) REDUCE_TO( INC 	            , ';'          ),
                    IF_SEQUENCE_IS( _DEC_CR     , 0           , 0      , 0          ) REDUCE_TO( DEC 	            , '\n'         ),
                    IF_SEQUENCE_IS( _DEC_SEMI   , 0           , 0      , 0          ) REDUCE_TO( DEC 	            , ';'          ),

                    /* This _WITH_ is not at BOL. */
                    IF_SEQUENCE_IS( IDENTIFIER  , _WITH_      , 0      , 0          ) REDUCE_TO( IDENTIFIER         , WITH         ),
                    IF_SEQUENCE_IS( MACROVAR    , _WITH_      , 0      , 0          ) REDUCE_TO( MACROVAR           , WITH         ),
                    IF_SEQUENCE_IS( MACROTEXT   , _WITH_      , 0      , 0          ) REDUCE_TO( MACROTEXT          , WITH         ),
                    IF_SEQUENCE_IS( ')'         , _WITH_      , 0      , 0          ) REDUCE_TO( ')'                , WITH         ),
                    IF_SEQUENCE_IS( _WITH_      , '['         , 0      , 0          ) REDUCE_TO( HB_WITH_ID  	    , '['          ),
                    IF_SEQUENCE_IS( _WITH_      , 0           , 0      , 0          ) REDUCE_TO( HB_WITH_ID  	    , 0            ),

                    IF_SEQUENCE_IS( DO          , INASSIGN    , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , INASSIGN     ),
                    IF_SEQUENCE_IS( DO          , INC         , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , INC          ),
                    IF_SEQUENCE_IS( DO          , DEC         , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , DEC          ),
                    IF_SEQUENCE_IS( DO          , ALIASOP     , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , ALIASOP      ),
                    IF_SEQUENCE_IS( DO          , PLUSEQ      , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , PLUSEQ       ),
                    IF_SEQUENCE_IS( DO          , MINUSEQ     , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , MINUSEQ      ),
                    IF_SEQUENCE_IS( DO          , MULTEQ      , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , MULTEQ       ),
                    IF_SEQUENCE_IS( DO          , DIVEQ       , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , DIVEQ        ),
                    IF_SEQUENCE_IS( DO          , EXPEQ       , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , EXPEQ        ),
                    IF_SEQUENCE_IS( DO          , MODEQ       , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , MODEQ        ),
                    IF_SEQUENCE_IS( DO          , '('         , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , '('          ),
                    IF_SEQUENCE_IS( DO          , '['         , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , '['          ),
                    IF_SEQUENCE_IS( DO          , '='         , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , '='          ),
                    IF_SEQUENCE_IS( DO          , ':'         , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , ':'          ),
                    IF_SEQUENCE_IS( DO          , ';'         , 0      , 0          ) REDUCE_TO( HB_DO_ID    	    , ';'          ),
                    IF_SEQUENCE_IS( DO          , 0           , 0      , 0          ) PASS_THROUGH(),
		    /* ----------------------  End of: DO WHILE; WHILE ; DO CASE ; CASE; DO ... ; DO ... WITH  ------------------- */

                    /* This IF is only at BOL if followed by operator (other than logicals .t., .f., !) than Identifier else IF. */
                    IF_SEQUENCE_IS( IF         , INASSIGN    , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , INASSIGN     ),
                    IF_SEQUENCE_IS( IF         , INC         , '\n'    , 0          ) REDUCE_TO( HB_IF_ID           , _INC_CR      ),
                    IF_SEQUENCE_IS( IF         , INC         , ';'     , 0          ) REDUCE_TO( HB_IF_ID           , _INC_SEMI    ),
                    IF_SEQUENCE_IS( IF         , DEC         , '\n'    , 0          ) REDUCE_TO( HB_IF_ID           , _DEC_CR      ),
                    IF_SEQUENCE_IS( IF         , DEC         , ';'     , 0          ) REDUCE_TO( HB_IF_ID           , _DEC_SEMI    ),
                    IF_SEQUENCE_IS( IF         , ALIASOP     , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , ALIASOP      ),
                    IF_SEQUENCE_IS( IF         , PLUSEQ      , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , PLUSEQ       ),
                    IF_SEQUENCE_IS( IF         , MINUSEQ     , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , MINUSEQ      ),
                    IF_SEQUENCE_IS( IF         , MULTEQ      , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , MULTEQ       ),
                    IF_SEQUENCE_IS( IF         , DIVEQ       , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , DIVEQ        ),
                    IF_SEQUENCE_IS( IF         , EXPEQ       , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , EXPEQ        ),
                    IF_SEQUENCE_IS( IF         , MODEQ       , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , MODEQ        ),
                 /* IF_SEQUENCE_IS( IF         , '('         , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , '('          ),
                    IF_SEQUENCE_IS( IF         , '['         , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , '['          ), */
                    IF_SEQUENCE_IS( IF         , '='         , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , '='          ),
                    IF_SEQUENCE_IS( IF         , ':'         , 0       , 0          ) REDUCE_TO( HB_IF_ID  	    , ':'          ),
                    IF_SEQUENCE_IS( IF         , 0           , 0       , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( PROCREQ_    , '('         , 0      , 0          ) REDUCE_TO( PROCREQ           , 0             ),
                    IF_SEQUENCE_IS( PROCREQ_    , '['         , 0      , 0          ) REDUCE_TO( HB_PROCREQ_ID     , '['           ),
                    IF_SEQUENCE_IS( PROCREQ_    , 0           , 0      , 0          ) REDUCE_TO( HB_PROCREQ_ID     , 0             ),

                    /* Left Associate '[' to seperate from string delimiter. */
                    IF_SEQUENCE_IS( IDENTIFIER  , '['         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( MACROVAR    , '['         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( MACROTEXT   , '['         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( ')'         , '['         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( ']'         , '['         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( '}'         , '['         , 0      , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( _DOT_DOT_   , 0           , 0      , 0          ) REDUCE_TO( HB_SELF_ID        , ':'           ),

                    IF_SEQUENCE_IS( _SELF_      , ':'         , 0      , 0          ) REDUCE_TO( SELF         	    , ':'          ),
                    IF_SEQUENCE_IS( _SELF_      , '['         , 0      , 0          ) REDUCE_TO( HB_SELF_ID        , '['           ),
                    IF_SEQUENCE_IS( _SELF_      , 0           , 0      , 0          ) REDUCE_TO( HB_SELF_ID        , 0             ),

                    IF_SEQUENCE_IS( QSELF       , '('         , ')'    , 0          ) REDUCE_TO( SELF              , 0             ),
                    IF_SEQUENCE_IS( QSELF       , '['         , 0      , 0          ) REDUCE_TO( HB_QSELF_ID       , '['           ),
                    IF_SEQUENCE_IS( QSELF       , 0           , 0      , 0          ) REDUCE_TO( HB_QSELF_ID       , 0             ),

                    IF_SEQUENCE_IS( '#'         , _LINE_      , 0      , 0          ) REDUCE_TO( LINE              , 0             ),
                    IF_SEQUENCE_IS( '#'         , 0           , 0      , 0          ) REDUCE_TO( NE1               , 0             ),
                    IF_SEQUENCE_IS( _LINE_      , '['         , 0      , 0          ) REDUCE_TO( HB_LINE_ID        , '['           ),
                    IF_SEQUENCE_IS( _LINE_      , 0           , 0      , 0          ) REDUCE_TO( HB_LINE_ID        , 0             ),

                    IF_SEQUENCE_IS( _IF_        , '('         , 0      , 0         ) REDUCE_TO( IIF                , '('           ),
                    IF_SEQUENCE_IS( _IF_        , '['         , 0      , 0         ) REDUCE_TO( HB_IF_ID           , '['           ),
                    IF_SEQUENCE_IS( _IF_        , 0           , 0      , 0         ) REDUCE_TO( HB_IF_ID           , 0             ),

                    IF_SEQUENCE_IS( IIF         , '('         , 0      , 0         ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( IIF         , '['         , 0      , 0         ) REDUCE_TO( HB_IIF_ID          , '['           ),
                    IF_SEQUENCE_IS( IIF         , 0           , 0      , 0         ) REDUCE_TO( HB_IIF_ID          , 0             ),

                    IF_SEQUENCE_IS( OPTIONAL    , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( OPTIONAL    , 0           , 0      , 0          ) REDUCE_TO( HB_OPTIONAL_ID    , 0             ),

                    IF_SEQUENCE_IS( '&'         , '\''        , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR       , 0            ),
                    IF_SEQUENCE_IS( '&'         , '"'         , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR       , 0            ),
                    IF_SEQUENCE_IS( '&'         , '['         , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR       , 0            ),

                    IF_SEQUENCE_IS( HB_QOUT_LIT , 0           , 0      , 0          ) REDUCE_TO( HB_RET_QOUT_LIT    , 0            )
                   };

/* -------------------------------------------------  End of Language Definitions. ------------------------------------------------ */

/* SimpLex Macros. */

#undef LEX_CASE
   #define LEX_CASE(x) toupper(x)

#undef NEW_LINE_ACTION
   #define NEW_LINE_ACTION() \
		while( iTexts ) \
                { \
                   DEBUG_INFO( printf( "Releasing short term Text: %i = %s At: %i\n", iTexts, aTexts[iTexts - 1], aTexts[iTexts - 1] ) ); \
                   iTexts--; \
                   hb_xfree( aTexts[iTexts] ); \
                }\
		\
                if( ! hb_comp_bQuiet && ( hb_comp_iLine % 100 ) == 0 ) \
                { \
                   printf( "\r%i", hb_comp_iLine ); \
                   fflush( stdout ); \
                }

#ifdef SHOW_LEX_TOKENS
   #undef INTERCEPT_ACTION
   	#define INTERCEPT_ACTION(x) \
	\
	yytext = sToken; \
	/*\
      	if( x == IDENTIFIER ) \
	{ \
	   iIdentifier--; \
	} */\
        \
      	if( x == IDENTIFIER ) \
           printf( "   IDENTIFIER = \"%s\"\n", yylval.string  ); \
      	else if( x == LITERAL ) \
           printf( "   LITERAL = \"%s\"\n", yylval.string  ); \
      	else if( x == MACROVAR ) \
           printf( "   MACROVAR = \"%s\"\n", yylval.string  ); \
      	else if( x == MACROTEXT ) \
           printf( "   MACROTEXT = \"%s\"\n", yylval.string  ); \
      	else if( x == NUM_INTEGER ) \
           printf( "   INTEGER = %i\n", yylval.valInteger.iNumber  ); \
      	else if( x == NUM_LONG ) \
           printf( "   INTEGER = %il\n", yylval.valLong.lNumber  ); \
      	else if( x == NUM_DOUBLE ) \
           printf( "   DOUBLE = %f\n", yylval.valDouble.dNumber  ); \
      	else if( x < 256 ) \
	{ \
	   yytext[0] = x; \
	   yytext[1] = '\0'; \
	\
           if( x == '\n' || x == ';' ) \
              printf( "                           NEW LINE %i\n", hb_comp_iLine - 1  ); \
           else \
              printf( "   DELIMITER = \"%c\"\n", x  ); \
	} \
      	else \
           printf( "   TOKEN = %i\n", x  );
#else
   #undef INTERCEPT_ACTION
   	#define INTERCEPT_ACTION(x) \
	\
	yytext = sToken; \
	/*\
      	if( x == IDENTIFIER ) \
	{ \
	   iIdentifier--; \
	}*/ \
	\
      	if( x < 256 ) \
	{ \
	   yytext[0] = x; \
	   yytext[1] = '\0'; \
	}
#endif

/* Support Functions implemented as macros for speed. */

#undef ELEMENT_TOKEN
  #define ELEMENT_TOKEN(x)\
\
   if( x == NULL || *x == '\0' )\
   {\
      printf( "Invalid Token passed to ELEMENT_TOKEN()\n" );\
      iRet = 0;\
   }\
   else\
   {\
      yytext = x;\
      yyleng = strlen( yytext );\
\
      if( *yytext == '_' || *yytext == '&' || isalpha( (int) *yytext ) )\
      {\
         /* Macro. */\
         if( ( tmpPtr = strrchr( yytext, '&' ) )  != NULL ) /* Right Search. */\
         {\
            /* Is '&' the first char? - Since its was right search that would be the only '&'. */\
	    if( tmpPtr == yytext )\
	    {\
	       /* Maybe just the Macro Operator. */\
	       if( yyleng == 1 )\
	       {\
	          iRet = '&';\
	       }\
	       /* No '.' so Simple Macro. */ \
	       else if( ( tmpPtr = strchr( yytext, '.' ) ) == NULL ) /* Left Search. */ \
	       {\
	          /* Remove the '&'. */ \
	       	  yytext++;\
	      	  yyleng--;\
\
                  yylval.string = hb_compIdentifierNew( yytext, TRUE );\
	       	  iRet = MACROVAR;\
               }\
	       else if( tmpPtr == yytext + yyleng - 1 )\
	       {\
	          /* The only '.' is last char, so Simple Macro. */ \
\
	       	  /* Remove the '&' and the '.' */ \
	       	  yytext++;\
	       	  yyleng -= 2;\
	       	  yytext[yyleng] = '\0';\
\
                  yylval.string = hb_compIdentifierNew( yytext, TRUE );\
	       	  iRet = MACROVAR;\
	       }\
	       else\
	       {\
                  yytext = hb_compIdentifierNew( yytext, TRUE );\
\
                  yylval.string = yytext;\
	       	  iRet = MACROTEXT;\
	       }\
	    }\
	    else\
	    {\
               yytext = hb_compIdentifierNew( yytext, TRUE );\
\
               yylval.string = yytext;\
	       iRet = MACROTEXT;\
	    }\
         }\
         else\
         {\
      	    DEBUG_INFO( printf(  "Element \"%s\" is IDENTIFIER\n", yytext ) );\
\
            if( strlen( yytext ) > HB_SYMBOL_NAME_LEN )\
            {\
               yytext[ HB_SYMBOL_NAME_LEN ] = '\0';\
               yyleng = HB_SYMBOL_NAME_LEN;\
            }\
            /*\
	    if( iIdentifier )\
	    {\
	       sIdOnHold = hb_compIdentifierNew( yytext, TRUE );\
	       iRet = HB_ID_ON_HOLD;\
	    }\
	    else */\
	    {\
	       /* iIdentifier++; */\
               yylval.string = hb_compIdentifierNew( yytext, TRUE );\
      	       iRet = IDENTIFIER;\
	    }\
         }\
      }\
      else\
      {\
         DEBUG_INFO( printf(  "Passing Element \"%s\" to CONVERT_NUMBER()\n", sToken ) );\
\
         /* "Returns" Token in iRet. (yylval.string already allocated). */\
	 yylval.string = (char*) hb_xgrab( TOKEN_SIZE );\
	 yylval.string[0] = 0;\
	 aTexts[iTexts++] = yylval.string;\
	 /* printf( "Text %i At: %i for Converted %s\n", iTexts, aTexts[iTexts - 1], sToken ); */\
\
         CONVERT_NUMBER();\
\
         DEBUG_INFO( printf(  "Element \"%s\" is %i\n", sToken, iRet ) );\
       }\
    }\

#define CONVERT_NUMBER()\
\
   if( yytext == NULL || *yytext == '\0' )\
   {\
      printf( "Invalid Token passed to CONVERT_NUMBER()\n" );\
      iRet = 0;\
   }\
   /* Hex Number */\
   else if( yytext[0] == '0' && yytext[1] == 'X' )\
   {\
      long lNumber = hb_lex_Hex2L( yytext + 2 );\
\
      if( ( double ) SHRT_MIN <= lNumber && lNumber <= ( double ) SHRT_MAX )\
      {\
         yylval.valInteger.iNumber = lNumber;\
         yylval.valInteger.szValue = yytext;\
         iRet = NUM_INTEGER;\
      }\
      else if( ( double ) LONG_MIN <= lNumber && lNumber <= ( double ) LONG_MAX )\
      {\
         yylval.valLong.lNumber = lNumber;\
         yylval.valLong.szValue = yytext;\
         iRet = NUM_LONG;\
      }\
      else\
      {\
         /* NOTE: This will never happen */\
         yylval.valDouble.dNumber = lNumber;\
         yylval.valDouble.bWidth = HB_DEFAULT_WIDTH;\
         yylval.valDouble.bDec = 0;\
         yylval.valDouble.szValue = yytext;\
         iRet = NUM_DOUBLE;\
      }\
   }\
   else\
   {\
      yylval.valDouble.dNumber = atof( yytext );\
      tmpPtr = strchr( yytext, '.' );\
\
      if( tmpPtr )\
      {\
         yylval.valDouble.bDec = strlen( tmpPtr + 1 );\
         yylval.valDouble.bWidth = strlen( yytext ) - yylval.valDouble.bDec;\
         if( yylval.valDouble.bDec )\
	 {\
            yylval.valDouble.bWidth--;\
	 }\
         yylval.valDouble.szValue = yytext;\
         iRet = NUM_DOUBLE;\
      }\
      else\
      {\
         if( ( double )SHRT_MIN <= yylval.valDouble.dNumber && yylval.valDouble.dNumber <= ( double )SHRT_MAX )\
         {\
            yylval.valInteger.iNumber = ( int ) yylval.valDouble.dNumber;\
            yylval.valInteger.szValue = yytext;\
            iRet = NUM_INTEGER;\
         }\
         else if( ( double )LONG_MIN <= yylval.valDouble.dNumber && yylval.valDouble.dNumber <= ( double )LONG_MAX )\
         {\
            yylval.valLong.lNumber = ( long ) yylval.valDouble.dNumber;\
            yylval.valLong.szValue = yytext;\
            iRet = NUM_LONG;\
         }\
         else\
         {\
            yylval.valDouble.bWidth = strlen( yytext ) + 1;\
            yylval.valDouble.bDec = 0;\
            yylval.valDouble.szValue = yytext;\
            iRet = NUM_DOUBLE;\
         }\
      }\
   }

#undef CUSTOM_ACTION
   #define CUSTOM_ACTION(x) x = hb_lex_CustomAction(x, iWordLen, aiHold, &iHold, &bIgnoreWords, iLastToken, aiReturn, &iReturn )

#undef INIT_ACTION
   #define INIT_ACTION() hb_comp_bSimpLex = TRUE;

int yy_lex_input( char *buffer, int iBufferSize )
{
   HB_SYMBOL_UNUSED( buffer );
   HB_SYMBOL_UNUSED( iBufferSize );

   return hb_pp_Internal( hb_comp_bPPO ? hb_comp_yyppo : NULL, buffer );
}

long hb_lex_Hex2L( char* sHex )
{
   int i, iExp = 0, iLen = strlen( sHex ) - 1;
   long lVal, lSum = 0;
   char cChar;

   while( iLen >= 0 )
   {
      cChar = sHex[ iLen-- ];

      if( isalpha( (int) cChar ) )
      {
         lVal = cChar - 55;
      }
      else
      {
         lVal = cChar - 48;
      }

      if( lVal )
      {
	 i = 0;
	 while( i++ < iExp )
	 {
	    lVal *= 16;
	 }

         lSum += lVal;
      }

      iExp++;
   }

   return lSum;
}

int hb_lex_CustomAction( int x, int iWordLen, int aiHold[], int *ptr_iHold, BOOL *ptr_bIgnoreWords, int iLastToken, int aiReturn[], int *ptr_iReturn )
{
   BOOL bRestored = FALSE;
   static char sIdentifier[11];

   DEBUG_INFO( printf( "Custom Action for %i\n", x ) );

   sIdentifier[0] = '\0';

   switch ( x )
   {
      case HB_LIT_ACT :
         yylval.string = hb_compIdentifierNew( sPair, TRUE );
         x = LITERAL;
         break;

      case HB_QOUT_ACT :
	 /* iIdentifier++; */
         yylval.string = hb_compIdentifierNew( "QOUT", TRUE );
         aiReturn[ (*ptr_iReturn)++ ] = '(';
         aiReturn[ (*ptr_iReturn)++ ] = IDENTIFIER;
         x = HB_QOUT_LIT;
         break;

      case HB_RET_QOUT_LIT :
         yylval.string = hb_compIdentifierNew( sPair, TRUE );
         aiReturn[ (*ptr_iReturn)++ ] = '\n';
         aiReturn[ (*ptr_iReturn)++ ] = ')';
         aiReturn[ (*ptr_iReturn)++ ] = LITERAL;
	 x = 0;
	 break;

      case HB_FUNCTION :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = FUNCTION;
         x = 0;
         break;

      case HB_PROCEDURE :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = PROCEDURE;
         x = 0;
         break;

      case HB_EXTERN :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = EXTERN;
         x = 0;
         break;

      case HB_DECLARE :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = DECLARE;
         x = 0;
         break;

      case HB_PUBLIC :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = PUBLIC;
         x = 0;
         break;

      case HB_PRIVATE :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = PRIVATE_;
         x = 0;
         break;

      case HB_LOCAL :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = LOCAL;
         x = 0;
         break;

      case HB_MEMVAR :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = MEMVAR;
         x = 0;
         break;

      case HB_FIELD :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = FIELD_;
         x = 0;
         break;

      case HB_PARAM :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = PARAMETERS;
         x = 0;
         break;

      case HB_FOR :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = FOR;
         x = 0;
         break;

      case HB_OPTIONAL :
	 *ptr_bIgnoreWords = TRUE;
         aiHold[ (*ptr_iHold)++ ] = OPTIONAL;
         x = 0;
         break;

      case HB_CHK_NEXT :
         if( hb_comp_wForCounter == 0 )
            hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_NEXTFOR, NULL, NULL );
	 x = NEXT;
	 break;

      case HB_CHK_EXIT :
         if( hb_comp_wForCounter == 0 && hb_comp_wWhileCounter == 0 )
            hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_UNMATCHED_EXIT, "EXIT", NULL );
	 x = EXIT;
	 break;

      case HB_CHK_LOOP :
         if( hb_comp_wForCounter == 0 && hb_comp_wWhileCounter == 0 )
            hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_UNMATCHED_EXIT, "LOOP", NULL );
	 x = LOOP;
	 break;

      case HB_CHK_IN :
         if( iLastToken == IDENTIFIER )
	 {
	    x = IN;
	 }
	 else
	 {
            strcpy( (char*) sIdentifier, "IN" );
            x = IDENTIFIER;
	 }
	 break;

      case HB_INIT_PROC :
         aiReturn[ (*ptr_iReturn)++ ] = PROCEDURE;
         aiReturn[ (*ptr_iReturn)++ ] = INIT;
         x = 0;
         break;

      case HB_INIT_FUNC :
         aiReturn[ (*ptr_iReturn)++ ] = FUNCTION;
         aiReturn[ (*ptr_iReturn)++ ] = INIT;
         x = 0;
         break;

      case HB_EXIT_PROC :
         aiReturn[ (*ptr_iReturn)++ ] = PROCEDURE;
         aiReturn[ (*ptr_iReturn)++ ] = EXIT;
         x = 0;
         break;

      case HB_EXIT_FUNC :
         aiReturn[ (*ptr_iReturn)++ ] = FUNCTION;
         aiReturn[ (*ptr_iReturn)++ ] = EXIT;
         x = 0;
         break;

      case HB_RET_FUNID :
	 /* iIdentifier++; */
         aiReturn[ (*ptr_iReturn)++ ] = IDENTIFIER;
         aiReturn[ (*ptr_iReturn)++ ] = FUNCTION;
         x = 0;
         break;

      case HB_EXTERN_ID :
         strncpy( (char*) sIdentifier, "EXTERNAL", iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_WHILE_ID :
         strncpy( (char*) sIdentifier, "WHILE", iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_ARRAY_ID :
         strncpy( (char*) sIdentifier, "ARRAY" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_AS_ID :
         strcpy( (char*) sIdentifier, "AS" );
         x = IDENTIFIER;
         break;

      case HB_OF_ID :
         strcpy( (char*) sIdentifier, "OF" );
         x = IDENTIFIER;
         break;

      case HB_VARIANT_ID :
         strncpy( (char*) sIdentifier, "ANYTYPE" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_BLOCK_ID :
         strncpy( (char*) sIdentifier, "BLOCK" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_STRING_ID :
         strncpy( (char*) sIdentifier, "STRING" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_CLASS_ID :
         strncpy( (char*) sIdentifier, "CLASS" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_DATE_ID :
         strncpy( (char*) sIdentifier, "DATE" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_LOGICAL_ID :
         strncpy( (char*) sIdentifier, "LOGICAL" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_NUMEIC_ID :
         strncpy( (char*) sIdentifier, "NUMERIC" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_OBJECT_ID :
         strncpy( (char*) sIdentifier, "OBJECT" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_PUBLIC_ID :
         strncpy( (char*) sIdentifier, "PUBLIC" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_OTHERWISE_ID :
         strncpy( (char*) sIdentifier, "OTHERWISE" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_MEMVAR_ID :
         strncpy( (char*) sIdentifier, "MEMVAR" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_LOOP_ID :
         strcpy( (char*) sIdentifier, "LOOP" );
         x = IDENTIFIER;
         break;

      case HB_FOR_ID :
         strcpy( (char*) sIdentifier, "FOR" );
         x = IDENTIFIER;
         break;

      case HB_NEXT_ID :
         strcpy( (char*) sIdentifier, "NEXT" );
         x = IDENTIFIER;
         break;

      case HB_FIELD_ID :
         strncpy( (char*) sIdentifier, "FIELD" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB__FIELD_ID :
         strncpy( (char*) sIdentifier, "_FIELD" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_PARAMETERS_ID :
         strncpy( (char*) sIdentifier, "PARAMETERS" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_PRIVATE_ID :
         strncpy( (char*) sIdentifier, "PRIVATE" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_EXIT_ID :
         strcpy( (char*) sIdentifier, "EXIT" );
         x = IDENTIFIER;
         break;

      case HB_BEGIN_ID :
         strncpy( (char*) sIdentifier, "BEGIN" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_SEQUENCE_ID :
         strncpy( (char*) sIdentifier, "SEQUENCE" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_BREAK_ID :
         strncpy( (char*) sIdentifier, "BREAK" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_RECOVER_ID :
         strncpy( (char*) sIdentifier, "RECOVER" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_USING_ID :
         strncpy( (char*) sIdentifier, "USING" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_CASE_ID :
         strcpy( (char*) sIdentifier, "CASE" );
         x = IDENTIFIER;
         break;

      case HB_DO_ID :
         strcpy( (char*) sIdentifier, "DO" );
         x = IDENTIFIER;
         break;

      case HB_WITH_ID :
         strcpy( (char*) sIdentifier, "WITH" );
         x = IDENTIFIER;
         break;

      case HB_DECLARE_ID :
         strncpy( (char*) sIdentifier, "DECLARE" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_PROCREQ_ID :
         strncpy( (char*) sIdentifier, "PROCREQ" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_SELF_ID :
         strcpy( (char*) sIdentifier, "SELF" );
         x = IDENTIFIER;
         break;

      case HB_IF_ID :
         strcpy( (char*) sIdentifier, "IF" );
         x = IDENTIFIER;
         break;

      case HB_IIF_ID :
         strcpy( (char*) sIdentifier, "IIF" );
         x = IDENTIFIER;
         break;

      case HB_OPTIONAL_ID :
         strncpy( (char*) sIdentifier, "OPTIONAL" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_IN_ID :
         strcpy( (char*) sIdentifier, "IN" );
         x = IDENTIFIER;
         break;

      case HB_LINE_ID :
         strcpy( (char*) sIdentifier, "LINE" );
         x = IDENTIFIER;
         break;

      case HB_INIT_ID :
         strcpy( (char*) sIdentifier, "INIT" );
         x = IDENTIFIER;
         break;

      case HB_PROCEDURE_ID :
         strncpy( (char*) sIdentifier, "PROCEDURE" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_FUNCTION_ID :
         strncpy( (char*) sIdentifier, "FUNCTION" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_STATIC_ID :
         strncpy( (char*) sIdentifier, "STATIC" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_LOCAL_ID :
         strncpy( (char*) sIdentifier, "LOCAL" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_RETURN_ID :
         strncpy( (char*) sIdentifier, "RETURN" , iWordLen );
	 sIdentifier[iWordLen] = '\0';
         x = IDENTIFIER;
         break;

      case HB_END_ID :
         strcpy( (char*) sIdentifier, "END" );
         x = IDENTIFIER;
         break;

      case HB_MACRO_ERR :
	 hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_SYNTAX, "&", NULL );
         x = 0;
         break;

      /*
      case HB_ID_ON_HOLD :
	 bRestored = TRUE;
         yylval.string = sIdOnHold;
	 iIdentifier++;
         x = IDENTIFIER;
         break;
      */

      default:
         printf( "WARNING! No Handler for Custom Action %i\n", x );
   }

   if( x == IDENTIFIER && ! bRestored )
   {
      yylval.string = hb_compIdentifierNew( (char*) sIdentifier, TRUE );
      /* iIdentifier++; */
      aiHold[ (int)(*ptr_iHold)++ ] = x;
      x = 0;
   }

   return x;
}
