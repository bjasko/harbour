/*
 * $Id$
 */

/*
 * Harbour Project source code:
 * Compiler SimpLex rules
 *
 * Copyright 2000 Ron Pinkas <ronpinkas@profit-master.com>
 * www - http://www.harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version, with one exception:
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA (or visit
 * their web site at http://www.gnu.org/).
 */

#define NUMERALS_PER_LINE 512

//#define SHOW_LEX_TOKENS
//#define DEBUG_LEX

#ifdef DEBUG_LEX
   #undef DEBUG_INFO
      #define DEBUG_INFO(x) x
#endif

#undef LEX_ABBREVIATE
   #define LEX_ABBREVIATE 4

#undef YY_BUF_SIZE
   #define YY_BUF_SIZE HB_PP_STR_SIZE

static int iTexts = 0, iCloseSquare = 0, iWantsEOL, iWantsEXP, iWantsID, iWantsVAR;
static char *aTexts[ NUMERALS_PER_LINE ];
static unsigned char iIdentifier = 0;
static char *sIdOnHold, *s_sLastBlock = NULL;

char *     hb_comp_SLX_LastBlock( BOOL bReset );
long       hb_comp_SLX_Hex2L( char* sHex );
static int hb_comp_SLX_ElementToken( char* szToken, unsigned int iTokenLen );
static int hb_comp_SLX_InterceptAction( int iRet, char *sToken );
static int hb_comp_SLX_CustomAction( int x, int aiHold[], int *ptr_iHold, BOOL *ptr_bIgnoreWords, int iLastToken, char *sToken, char *s_szBuffer );

/* -----------------------------------------------------  Language Definitions. ---------------------------------------------------- */

/* Delimiters. */
ACCEPT_TOKEN_AND_DROP_DELIMITER_IF_ONE_OF_THESE( " \t" );

#define HB_CHK_BLOCK    LEX_CUSTOM_ACTION - 1

ACCEPT_TOKEN_AND_RETURN_DELIMITERS {
				     LEX_DELIMITER( ',' ) AS_TOKEN( ',' ),
				     LEX_DELIMITER( '(' ) AS_TOKEN( '(' ),
				     LEX_DELIMITER( ')' ) AS_TOKEN( ')' ),
				     LEX_DELIMITER( '[' ) AS_TOKEN( '[' ),
				     LEX_DELIMITER( ']' ) AS_TOKEN( ']'   + DONT_REDUCE ),
				     LEX_DELIMITER( '}' ) AS_TOKEN( '}'   + DONT_REDUCE ),
				     LEX_DELIMITER( ':' ) AS_TOKEN( ':' ),
				     LEX_DELIMITER( '=' ) AS_TOKEN( '=' ),
				     LEX_DELIMITER( '#' ) AS_TOKEN( NE1 ),
				     LEX_DELIMITER( '@' ) AS_TOKEN( '@' ),
				     LEX_DELIMITER( '<' ) AS_TOKEN( '<'   + DONT_REDUCE ),
				     LEX_DELIMITER( '>' ) AS_TOKEN( '>'   + DONT_REDUCE ),
				     LEX_DELIMITER( '!' ) AS_TOKEN( NOT   + DONT_REDUCE ),
				     LEX_DELIMITER( '{' ) AS_TOKEN( HB_CHK_BLOCK        ),
				     LEX_DELIMITER( '|' ) AS_TOKEN( '|'   + DONT_REDUCE ),
				     LEX_DELIMITER( '^' ) AS_TOKEN( POWER + DONT_REDUCE ),
				     LEX_DELIMITER( '%' ) AS_TOKEN( '%'   + DONT_REDUCE ),
				     LEX_DELIMITER( '*' ) AS_TOKEN( '*'   + DONT_REDUCE ),
				     LEX_DELIMITER( '/' ) AS_TOKEN( '/'   + DONT_REDUCE ),
				     LEX_DELIMITER( '+' ) AS_TOKEN( '+'   + DONT_REDUCE ),
				     LEX_DELIMITER( '-' ) AS_TOKEN( '-'   + DONT_REDUCE ),
				     LEX_DELIMITER( '$' ) AS_TOKEN( '$'   + DONT_REDUCE )
				   };

/* Custom Intermediate Token needed to be expanded. */
#define HB_LIT_ACT      LEX_CUSTOM_ACTION - 2
#define HB_NESTED_LIT   LEX_CUSTOM_ACTION - 3
#define HB_QOUT_ACT     LEX_CUSTOM_ACTION - 4
#define HB_RET_QOUT_LIT LEX_CUSTOM_ACTION - 5

/* Stream Pairs. */
DEFINE_STREAM_AS_ONE_OF_THESE {
                                START_WITH("\"")     END_WITH("\"" )  STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("'")      END_WITH("'")    STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("QOUT([") END_WITH("])\n") STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_QOUT_ACT),
                                START_WITH("[")      END_WITH("]" )   STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(TRUE ) AS_PAIR_TOKEN(HB_LIT_ACT),
                                START_WITH("[\"")    END_WITH("\"]" ) STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_NESTED_LIT),
                                START_WITH("['")     END_WITH("\']" ) STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_NESTED_LIT),
                                START_WITH("[[")     END_WITH("]]" )  STOP_IF_ONE_OF_THESE("\n") TEST_LEFT(FALSE) AS_PAIR_TOKEN(HB_NESTED_LIT)
                              };

START_NEW_LINE_IF_ONE_OF_THESE( "\n;" );

#define HB_SELF         LEX_CUSTOM_ACTION - 6

SELF_CONTAINED_WORDS_ARE {
                           LEX_WORD( ".AND." ) AS_TOKEN( AND     + DONT_REDUCE ),
                           LEX_WORD( ".NOT." ) AS_TOKEN( NOT     + DONT_REDUCE ),
                           LEX_WORD( ".OR."  ) AS_TOKEN( OR      + DONT_REDUCE ),
                           LEX_WORD( ":="    ) AS_TOKEN( INASSIGN   ),
                           LEX_WORD( "::"    ) AS_TOKEN( HB_SELF    ),
                           LEX_WORD( "=="    ) AS_TOKEN( EQ      + DONT_REDUCE ),
                           LEX_WORD( "<>"    ) AS_TOKEN( NE2     + DONT_REDUCE ),
                           LEX_WORD( "<="    ) AS_TOKEN( LE      + DONT_REDUCE ),
                           LEX_WORD( ">="    ) AS_TOKEN( GE      + DONT_REDUCE ),
                           LEX_WORD( "!="    ) AS_TOKEN( NE2     + DONT_REDUCE ),
                           LEX_WORD( "++"    ) AS_TOKEN( INC        ),
                           LEX_WORD( "+="    ) AS_TOKEN( PLUSEQ     ),
                           LEX_WORD( "--"    ) AS_TOKEN( DEC        ),
                           LEX_WORD( "-="    ) AS_TOKEN( MINUSEQ    ),
                           LEX_WORD( "->"    ) AS_TOKEN( ALIASOP    ),
                           LEX_WORD( "*="    ) AS_TOKEN( MULTEQ     ),
                           LEX_WORD( "**"    ) AS_TOKEN( POWER   + DONT_REDUCE ),
                           LEX_WORD( "/="    ) AS_TOKEN( DIVEQ      ),
                           LEX_WORD( "^="    ) AS_TOKEN( EXPEQ      ),
                           LEX_WORD( "%="    ) AS_TOKEN( MODEQ      )
                         };

/* Intermediate KeyWords when ambigious. */
#define DO_WHILE         701
#define DO_WHILE_WITH    702

/* KeyWords are grouped based on the next token they require. */
#define WANTS_VAR        703 /* Wants Variable (including Macros): DO, FOR, PRIVATE, PUBLIC */
#define WANTS_ID         704 /* Wants Identifier: ANNOUNCE, EXTERN, FIELD, FUNCTION, LOCAL, MEMVAR, PARAMETERS, PROCEDURE, STATIC */
#define WANTS_EOL        705 /* Wants EOL: ELSE, END, ENDCASE, ENDDO, ENDIF, EXIT, LOOP, NEXT, OTHERWISE, RECOVER */
#define WANTS_EXP        706 /* Wants Expression: BREAK, CASE, ELSEIF, IF, RETURN, WHILE */
#define REJECT_OP        707

#define HB_WANTS_VAR     LEX_CUSTOM_ACTION - 512
#define HB_WANTS_ID      LEX_CUSTOM_ACTION - 1024
#define HB_WANTS_EOL     LEX_CUSTOM_ACTION - 1536
#define HB_WANTS_EXP     LEX_CUSTOM_ACTION - 2048

/* When 2 identifiers are correct syntax like in class declaration, we have to temporarily store the 2nd identifier. */
#define HB_ID_ON_HOLD  LEX_CUSTOM_ACTION - 7

#define HB_MACRO_ERR   LEX_CUSTOM_ACTION - 8

#define HB_INIT_PROC   LEX_CUSTOM_ACTION - 9
#define HB_INIT_FUNC   LEX_CUSTOM_ACTION - 10
#define HB_EXIT_PROC   LEX_CUSTOM_ACTION - 11
#define HB_EXIT_FUNC   LEX_CUSTOM_ACTION - 12
#define HB_STATIC_PROC LEX_CUSTOM_ACTION - 13
#define HB_STATIC_FUNC LEX_CUSTOM_ACTION - 14

#define HB_DO_CASE_ID  LEX_CUSTOM_ACTION - 15

#define HB_DO_WHILE_ID   LEX_CUSTOM_ACTION - 16
#define HB_DO_WHILE_WITH LEX_CUSTOM_ACTION - 17

#define _WITH_ID_CR      LEX_CUSTOM_ACTION - 18
#define _WITH_ID_SEMI    LEX_CUSTOM_ACTION - 19

#define HB_IN            LEX_CUSTOM_ACTION - 20
#define HB_STEP          LEX_CUSTOM_ACTION - 21
#define HB_TO            LEX_CUSTOM_ACTION - 22
#define HB_WITH          LEX_CUSTOM_ACTION - 23

/* When reservered words are used as Identifier. */
#define HB_IDENTIFIER    LEX_CUSTOM_ACTION - 24

#define USE_KEYWORDS

/* Key Words. */
LANGUAGE_KEY_WORDS_ARE {
                         LEX_WORD( "ANNOUNCE"            ) AS_TOKEN( HB_WANTS_ID  - ANNOUNCE         ),
                         LEX_WORD( "BEGIN{WS}SEQUENCE"   ) AS_TOKEN( BEGINSEQ         ),
                         LEX_WORD( "BREAK"               ) AS_TOKEN( HB_WANTS_EXP - BREAK            ),
                         LEX_WORD( "CASE"                ) AS_TOKEN( HB_WANTS_EXP - CASE             ),
                         LEX_WORD( "DECLARE"             ) AS_TOKEN( DECLARE          ),
                         LEX_WORD( "DO"                  ) AS_TOKEN( HB_WANTS_VAR - DO               ),
                         LEX_WORD( "DO{WS}CASE"          ) AS_TOKEN( DOCASE           ),
                         LEX_WORD( "DO{WS}WHILE"         ) AS_TOKEN( DO_WHILE         ),
                         LEX_WORD( "DO{WS}WHILE{WS}WITH" ) AS_TOKEN( DO_WHILE_WITH    ),
                         LEX_WORD( "ELSE"                ) AS_TOKEN( HB_WANTS_EOL - ELSE             ),
                         LEX_WORD( "ELSEIF"              ) AS_TOKEN( HB_WANTS_EXP - ELSEIF           ),
                         LEX_WORD( "END"                 ) AS_TOKEN( HB_WANTS_EOL - END              ),
                         LEX_WORD( "ENDCASE"             ) AS_TOKEN( HB_WANTS_EOL - ENDCASE          ),
                         LEX_WORD( "ENDDO"               ) AS_TOKEN( HB_WANTS_EOL - ENDDO            ),
                         LEX_WORD( "ENDIF"               ) AS_TOKEN( HB_WANTS_EOL - ENDIF            ),
                         LEX_WORD( "EXIT"                ) AS_TOKEN( HB_WANTS_EOL - EXIT             ),
                         LEX_WORD( "EXIT{WS}FUNCTION"    ) AS_TOKEN( HB_EXIT_FUNC     ),
                         LEX_WORD( "EXIT{WS}PROCEDURE"   ) AS_TOKEN( HB_EXIT_PROC     ),
                         LEX_WORD( "EXTERNAL"            ) AS_TOKEN( HB_WANTS_ID  - EXTERN           ),
                         LEX_WORD( "FIELD"               ) AS_TOKEN( HB_WANTS_ID  - FIELD            ),
                         LEX_WORD( "FOR"                 ) AS_TOKEN( HB_WANTS_VAR - FOR              ),
                         LEX_WORD( "FUNCTION"            ) AS_TOKEN( HB_WANTS_ID  - FUNCTION         ),
                         LEX_WORD( "IF"                  ) AS_TOKEN( HB_WANTS_EXP - IF               ),
                         LEX_WORD( "INIT{WS}FUNCTION"    ) AS_TOKEN( HB_INIT_FUNC     ),
                         LEX_WORD( "INIT{WS}PROCEDURE"   ) AS_TOKEN( HB_INIT_PROC     ),
                         LEX_WORD( "LOCAL"               ) AS_TOKEN( HB_WANTS_ID  - LOCAL            ),
                         LEX_WORD( "LOOP"                ) AS_TOKEN( HB_WANTS_EOL - LOOP             ),
                         LEX_WORD( "MEMVAR"              ) AS_TOKEN( HB_WANTS_ID  - MEMVAR           ),
                         LEX_WORD( "NEXT"                ) AS_TOKEN( HB_WANTS_EOL - NEXT             ),
                         LEX_WORD( "OTHERWISE"           ) AS_TOKEN( HB_WANTS_EOL - OTHERWISE        ),
                         LEX_WORD( "PARAMETERS"          ) AS_TOKEN( HB_WANTS_ID  - PARAMETERS       ),
                         LEX_WORD( "PRIVATE"             ) AS_TOKEN( HB_WANTS_VAR - PRIVATE          ),
                         LEX_WORD( "PROCEDURE"           ) AS_TOKEN( HB_WANTS_ID  - PROCEDURE        ),
                         LEX_WORD( "PUBLIC"              ) AS_TOKEN( HB_WANTS_VAR - PUBLIC           ),
                         LEX_WORD( "RECOVER"             ) AS_TOKEN( HB_WANTS_EOL - RECOVER          ),
                         LEX_WORD( "RECOVER{WS}USING"    ) AS_TOKEN( RECOVERUSING     ),
                         LEX_WORD( "RETURN"              ) AS_TOKEN( HB_WANTS_EXP - RETURN           ),
                         LEX_WORD( "STATIC"              ) AS_TOKEN( HB_WANTS_ID  - STATIC           ),
                         LEX_WORD( "STATIC{WS}FUNCTION"  ) AS_TOKEN( HB_STATIC_FUNC   ),
                         LEX_WORD( "STATIC{WS}PROCEDURE" ) AS_TOKEN( HB_STATIC_PROC   ),
                         LEX_WORD( "WHILE"               ) AS_TOKEN( HB_WANTS_EXP - WHILE            ),
                         LEX_WORD( "_HB_CLASS"           ) AS_TOKEN( DECLARE_CLASS    ),
                         LEX_WORD( "_HB_MEMBER"          ) AS_TOKEN( DECLARE_MEMBER   ),
                         LEX_WORD( "_PROCREQ_"           ) AS_TOKEN( PROCREQ          )
                       };

/* Intermediate Words when ambigious. */
#define QSELF     801
#define _LINE_    802

/* Words. */
LANGUAGE_WORDS_ARE {
                     LEX_WORD( ".F."             		) AS_TOKEN( FALSEVALUE         + DONT_REDUCE ),
                     LEX_WORD( ".N."             		) AS_TOKEN( FALSEVALUE         + DONT_REDUCE ),
                     LEX_WORD( ".T."             		) AS_TOKEN( TRUEVALUE          + DONT_REDUCE ),
                     LEX_WORD( ".Y."             		) AS_TOKEN( TRUEVALUE          + DONT_REDUCE ),

                     LEX_WORD( "AS{WS}ANYTYPE"   		) AS_TOKEN( AS_VARIANT         + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY"     		) AS_TOKEN( AS_ARRAY           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}ANYTYPE"   ) AS_TOKEN( AS_ARRAY           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}ARRAY"     ) AS_TOKEN( AS_ARRAY_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}CHARACTER" ) AS_TOKEN( AS_CHARACTER_ARRAY + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}CLASS"     ) AS_TOKEN( AS_CLASS_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}CODEBLOCK" ) AS_TOKEN( AS_BLOCK_ARRAY     + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}DATE"      ) AS_TOKEN( AS_DATE_ARRAY      + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}LOGICAL"   ) AS_TOKEN( AS_LOGICAL_ARRAY   + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}NUMERIC"   ) AS_TOKEN( AS_NUMERIC_ARRAY   + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}OBJECT"    ) AS_TOKEN( AS_OBJECT_ARRAY    + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}STRING"    ) AS_TOKEN( AS_CHARACTER_ARRAY + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}ARRAY{WS}OF{WS}USUAL"     ) AS_TOKEN( AS_CHARACTER_ARRAY + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}CHARACTER" 		) AS_TOKEN( AS_CHARACTER       + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}CLASS"     		) AS_TOKEN( AS_CLASS           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}CODEBLOCK" 		) AS_TOKEN( AS_BLOCK           + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}DATE"      		) AS_TOKEN( AS_DATE            + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}LOGICAL"   		) AS_TOKEN( AS_LOGICAL         + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}NUMERIC"   		) AS_TOKEN( AS_NUMERIC         + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}OBJECT"    		) AS_TOKEN( AS_OBJECT          + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}STRING"    		) AS_TOKEN( AS_CHARACTER       + DONT_REDUCE ),
                     LEX_WORD( "AS{WS}USUAL"                    ) AS_TOKEN( AS_CHARACTER       + DONT_REDUCE ),

                     LEX_WORD( "FIELD"           		) AS_TOKEN( FIELD              ),
                     LEX_WORD( "IF"              		) AS_TOKEN( IIF                ),
                     LEX_WORD( "IIF"             		) AS_TOKEN( IIF                ),
                     LEX_WORD( "IN"              		) AS_TOKEN( HB_IN              ),
                     LEX_WORD( "LINE"                           ) AS_TOKEN( _LINE_             ),
                     LEX_WORD( "NIL"             		) AS_TOKEN( NIL                + DONT_REDUCE ),
                     LEX_WORD( "OPTIONAL"        		) AS_TOKEN( OPTIONAL           ),
                     LEX_WORD( "QSELF"           		) AS_TOKEN( QSELF              ),
                     LEX_WORD( "SELF"            		) AS_TOKEN( SELF               ),
                     LEX_WORD( "STEP"            		) AS_TOKEN( HB_STEP            ),
                     LEX_WORD( "TO"              		) AS_TOKEN( HB_TO              ),
                     LEX_WORD( "WITH"              		) AS_TOKEN( HB_WITH            ),
                     LEX_WORD( "_FIELD"          		) AS_TOKEN( FIELD              ),
                     LEX_WORD( "_GET_"          		) AS_TOKEN( GET                )
                   };

/* Intermediate Reductions when still ambigious or need further reductions. */
#define _ID_ARRAY         901
#define _ID_COMMA         902
#define _ID_CR            903
#define _ID_SEMI          904
#define _ID_ASSIGN        905
#define _WHL_ID_CR        906
#define _WHL_ID_SEMI      907
#define _QOUT_LIT         908

/* When 2 identifiers are correct syntax like in class declaration, we have to temporarily store the 2nd identifier. */
#define _ID_ON_HOLD       913

LANGUAGE_RULES_ARE {
		    /* Wants any Var. */
                    IF_SEQUENCE_IS( WANTS_VAR      , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , MACROVAR    , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , MACROTEXT   , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_VAR      , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

		    /* Wants Identifier. */
                    IF_SEQUENCE_IS( WANTS_ID       , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_ID       , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

		    /* Wants EOL */
                    IF_SEQUENCE_IS( WANTS_EOL      , '\n'        , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_EOL      , ';'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( WANTS_EOL      , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

		    /* Wants Expression ( DOESN'T WANT OPERATORS ) - At BOL, if followed by operator (other than logicals .t., .f., !) than Identifier else COMMAND. */
                    IF_SEQUENCE_IS( REJECT_OP      , INC         , '\n'   , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , INC         , ';'    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , DEC         , '\n'   , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , DEC         , ';'    , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , INASSIGN    , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , ALIASOP     , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , PLUSEQ      , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , MINUSEQ     , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , MULTEQ      , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , DIVEQ       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , EXPEQ       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , MODEQ       , 0      , 0          ) PASS_THROUGH(),
                 /* IF_SEQUENCE_IS( REJECT_OP      , '('         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , '['         , 0      , 0          ) PASS_THROUGH(), DONT uncomment!!!*/
                    IF_SEQUENCE_IS( REJECT_OP      , '='         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , ':'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( REJECT_OP      , 0           , 0      , 0          ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , 0             ),

                    IF_SEQUENCE_IS( REJECT_OP      , OPTIONAL     , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),
                    IF_SEQUENCE_IS( REJECT_OP      , WANTS_ID     , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),
                    IF_SEQUENCE_IS( REJECT_OP      , WANTS_EXP    , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),
                    IF_SEQUENCE_IS( REJECT_OP      , WANTS_VAR    , 0      , 0         ) REDUCE_TO( WANTS_EXP + DONT_REDUCE , HB_IDENTIFIER ),


		    /* Complex */

                    IF_SEQUENCE_IS( DOCASE       , '\n'       , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( DOCASE       , ';'        , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( DOCASE       , 0          , 0      , 0          ) REDUCE_TO( HB_DO_CASE_ID     , 0             ),

                    IF_SEQUENCE_IS( DO_WHILE_WITH, '\n'       , 0      , 0          ) REDUCE_TO( WHILE + DONT_REDUCE, _WITH_ID_CR  ),
                    IF_SEQUENCE_IS( DO_WHILE_WITH, ';'        , 0      , 0          ) REDUCE_TO( WHILE + DONT_REDUCE, _WITH_ID_SEMI),
                    IF_SEQUENCE_IS( DO_WHILE_WITH, 0          , 0      , 0          ) REDUCE_TO( HB_DO_WHILE_WITH  , 0             ),

                    IF_SEQUENCE_IS( DO_WHILE     , '\n'       , 0      , 0          ) REDUCE_TO( HB_DO_WHILE_ID    , '\n' + DONT_REDUCE        ),
                    IF_SEQUENCE_IS( DO_WHILE     , ';'        , 0      , 0          ) REDUCE_TO( HB_DO_WHILE_ID    , ';' + DONT_REDUCE         ),
                    IF_SEQUENCE_IS( DO_WHILE     , 0          , 0      , 0          ) REDUCE_TO( WHILE + DONT_REDUCE, 0             ),


		    /* DECLARE as PRIVATE. */
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , '['    , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_ARRAY     ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , ','    , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_COMMA     ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , '\n'   , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_CR        ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , ';'    , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_SEMI      ),
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  ,INASSIGN, 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , _ID_ASSIGN    ),
                    IF_SEQUENCE_IS( DECLARE     , MACROVAR    , 0      , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , MACROVAR      ),
                    IF_SEQUENCE_IS( DECLARE     , MACROTEXT   , 0      , 0          ) REDUCE_TO( PRIVATE    + DONT_REDUCE , MACROTEXT     ),

		    /* Any other DECLARE IDENTIFIER, must be Strong Type DECLARE. */
                    IF_SEQUENCE_IS( DECLARE     , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),

                    IF_SEQUENCE_IS( _ID_ON_HOLD , 0           , 0      , 0          ) REDUCE_TO( HB_ID_ON_HOLD      ,              ),

		    /* Any other DECLARE must be Identifier. */
                    IF_SEQUENCE_IS( DECLARE     , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER      ,              ),

		    /* Expnasions from DECLARE ...*/
                    IF_SEQUENCE_IS( _ID_ARRAY   , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , '[' + DONT_REDUCE      ),
                    IF_SEQUENCE_IS( _ID_COMMA   , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , ',' + DONT_REDUCE      ),
                    IF_SEQUENCE_IS( _ID_CR      , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , '\n' + DONT_REDUCE     ),
                    IF_SEQUENCE_IS( _ID_SEMI    , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , ';' + DONT_REDUCE      ),
                    IF_SEQUENCE_IS( _ID_ASSIGN  , 0           , 0      , 0          ) REDUCE_TO( IDENTIFIER + DONT_REDUCE , INASSIGN + DONT_REDUCE ),


		    /* This FIELD is NOT at BOL wants only ->. */
                    IF_SEQUENCE_IS( FIELD       , ALIASOP     , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( FIELD       , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),


                    IF_SEQUENCE_IS( SELF        , ':'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( SELF        , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( QSELF       , '('         , ')'    , 0          ) REDUCE_TO( SELF + DONT_REDUCE, 0             ),
                    IF_SEQUENCE_IS( QSELF       , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( IIF         , '('         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( IIF         , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER      , 0            ),

                    IF_SEQUENCE_IS( OPTIONAL    , IDENTIFIER  , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( OPTIONAL    , '@'         , 0      , 0          ) PASS_THROUGH(),
                    IF_SEQUENCE_IS( OPTIONAL    , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( PROCREQ     , '('         , 0      , 0          ) REDUCE_TO( PROCREQ + DONT_REDUCE, 0          ),
                    IF_SEQUENCE_IS( PROCREQ     , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( GET         , '('         , 0      , 0          ) REDUCE_TO( GET + DONT_REDUCE , 0             ),
                    IF_SEQUENCE_IS( GET         , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( NE1         , _LINE_      , 0      , 0          ) REDUCE_TO( LINE + DONT_REDUCE, 0             ),
                    IF_SEQUENCE_IS( _LINE_      , 0           , 0      , 0          ) REDUCE_TO( HB_IDENTIFIER     , 0             ),

                    IF_SEQUENCE_IS( '&'         , '\''        , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR      , 0             ),
                    IF_SEQUENCE_IS( '&'         , '"'         , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR      , 0             ),
                    IF_SEQUENCE_IS( '&'         , '['         , 0      , 0          ) REDUCE_TO( HB_MACRO_ERR      , 0             ),

                    IF_SEQUENCE_IS( _QOUT_LIT   , 0           , 0      , 0          ) REDUCE_TO( HB_RET_QOUT_LIT   , 0             )
                   };

/* -------------------------------------------------  End of Language Definitions. ------------------------------------------------ */

/* SimpLex Macros. */

#undef LEX_CASE
   #define LEX_CASE(x) ( (  ( iRet = (x) ) > 96 && iRet < 123 ) ? iRet - 32 : iRet )

#undef NEW_LINE_ACTION
   #define NEW_LINE_ACTION() \
		while( iTexts ) \
                { \
                   DEBUG_INFO( printf( "Releasing short term Text: %i = %s At: %i\n", iTexts, aTexts[iTexts - 1], aTexts[iTexts - 1] ) ); \
                   iTexts--; \
                   hb_xfree( aTexts[iTexts] ); \
                }\
		\
                if( ( hb_comp_iLine % 100 ) == 0 && hb_comp_bQuiet == FALSE ) \
                { \
                   printf( "\r%i", hb_comp_iLine ); \
                   fflush( stdout ); \
                }

#undef INTERCEPT_ACTION
   #define INTERCEPT_ACTION(x) x = hb_comp_SLX_InterceptAction( x, (char*) sToken )

#undef ELEMENT_TOKEN
  #define ELEMENT_TOKEN(x,y) hb_comp_SLX_ElementToken(x,y)

#undef YY_INPUT      /* to implement our own YY_INPUT function to manage PRGs without \n at the end */
   extern FILE * yyin;  /* currently yacc parsed file */
   int yy_lex_input( char *, int );
   #define YY_INPUT( buf, result, max_size ) result = yy_lex_input( buf, max_size );

#undef CUSTOM_ACTION
   #define CUSTOM_ACTION(x) x = hb_comp_SLX_CustomAction( x, aiHold, &iHold, &bIgnoreWords, iLastToken, (char*) sToken, s_szBuffer )

#undef STREAM_EXCEPTION
   #define STREAM_EXCEPTION( sPair, cChar ) \
	   if( sTerm[1] == ']' && iCloseSquare ) \
	   { \
              szBuffer -= ( ( strlen( sPair ) - iCloseSquare ) + 1 ); \
	      sPair[ iCloseSquare - 1 ] = '\0'; \
              aiHold[ iHold++ ] = HB_LIT_ACT; \
	   } \
	   else \
	   { \
	      hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_STRING_TERMINATOR, sPair, NULL ); \
              aiHold[ iHold++ ] = '\n'; \
              yylval.string = hb_compIdentifierNew( sPair, TRUE ); \
              aiHold[ iHold++ ] = LITERAL + DONT_REDUCE ; \
	   } \

#undef STREAM_APPEND
   #define STREAM_APPEND(x) \
      if( iPairLen == 0 && sStart[1] ) { sPair[ iPairLen++ ] = sStart[1]; } \
      if( x == ']' && iCloseSquare == 0 ) { iCloseSquare = iPairLen + 1; } sPair[ iPairLen++ ] = x;

#undef STREAM_OPEN
   #define STREAM_OPEN( sStarter ) \
      { \
         iCloseSquare = 0; \
	 \
         if( sStarter[0] == 'Q' ) \
           bTmp = FALSE /* TODO: hb_pp_bInsideTextBlock */; \
         else \
           bTmp = TRUE; \
      } \
      if( bTmp )

#undef IF_BELONG_LEFT
   #define IF_BELONG_LEFT(chr) if( iLastToken == IDENTIFIER || iLastToken == ']' || iLastToken == MACROVAR || iLastToken == MACROTEXT || iLastToken == ')' || iLastToken == '}' || iLastToken == WANTS_EOL || iLastToken == WANTS_ID || iLastToken == WANTS_VAR || iLastToken == DECLARE || iLastToken == FIELD || iLastToken == SELF || iLastToken == QSELF || iLastToken == IIF || iLastToken == PROCREQ )

/* Support Functions. */
int hb_comp_SLX_InterceptAction( int iRet, char *sToken )
{
   extern char *yytext;

   if( iRet < 256 )
   {
      yytext[0] = iRet;
      yytext[1] = '\0';
   }
   else if( iRet < 512 )
   {
      yytext = sToken;

      if( iRet == IDENTIFIER )
      {
         if( iIdentifier > 0 )
         {
            iIdentifier--;
         }
      }
   }
   else
   {
      yytext = sToken;

      if( iRet == WANTS_EXP )
         { iRet = iWantsEXP; }
      else if( iRet == WANTS_EOL )
         { iRet = iWantsEOL; }
      else if( iRet == WANTS_ID )
         { iRet = iWantsID; }
      else if( iRet == WANTS_VAR )
         { iRet = iWantsVAR; }
      else if( iRet == REJECT_OP )
         { yylval.string = hb_compIdentifierNew( (char*) sToken, TRUE ); iRet = IDENTIFIER; }
      else
         printf( "ERROR! [harbour.slx] - Missing Handler.\n" );
   }

   #ifdef SHOW_LEX_TOKENS
      if( iRet == IDENTIFIER )
         printf( "   IDENTIFIER = \"%s\"\n", yylval.string  );
      else if( iRet == LITERAL )
         printf( "   LITERAL = \"%s\"\n", yylval.string  );
      else if( iRet == MACROVAR )
         printf( "   MACROVAR = \"%s\"\n", yylval.string  );
      else if( iRet == MACROTEXT )
         printf( "   MACROTEXT = \"%s\"\n", yylval.string  );
      else if( iRet == NUM_INTEGER )
         printf( "   INTEGER = %i\n", yylval.valInteger.iNumber  );
      else if( iRet == NUM_LONG )
         printf( "   INTEGER = %il\n", yylval.valLong.lNumber  );
      else if( iRet == NUM_DOUBLE )
   	 printf( "   DOUBLE = %f\n", yylval.valDouble.dNumber  );
     else if( iRet < 256 )
     {
   	if( iRet == '\n' || iRet == ';' )
      	   printf( "***NEW LINE %i\n", hb_comp_iLine - 1  );
   	else
      	   printf( "   DELIMITER = \"%c\"\n", iRet  );
     }
     else
   	printf( "   TOKEN = %i\n", iRet  );
   #endif

   return iRet;
}

static int hb_comp_SLX_ElementToken( char* szToken, unsigned int iTokenLen )
{
   extern char *yytext;
   extern int yyleng;

   char* tmpPtr;
   int   iRet;

   yytext = szToken;
   yyleng = (int) iTokenLen;

   if( ( *yytext > 64 && *yytext < 91 ) || *yytext == '&' || *yytext == '_' )
   {
      /* Macro. */
      if( ( tmpPtr = strrchr( yytext, '&' ) ) != NULL ) /* Right Search. */
      {
         /* Is '&' the first char? - Since its was right search that would be the only '&'. */
         if( tmpPtr == yytext )
         {
            /* Maybe just the Macro Operator. */
            if( yyleng == 1 )
            {
               iRet = '&';
            }
            /* No '.' so Simple Macro. */
            else if( ( tmpPtr = strchr( yytext, '.' ) ) == NULL ) /* Left Search. */
            {
               /* Remove the '&'. */
               yytext++;
               yyleng--;

               yylval.string = hb_compIdentifierNew( yytext, TRUE );
               iRet = MACROVAR;
            }
            else if( tmpPtr == yytext + yyleng - 1 )
            {
               /* The only '.' is last char, so Simple Macro. */

               /* Remove the '&' and the '.' */
               yytext++;
               yyleng -= 2;
               yytext[yyleng] = '\0';

               yylval.string = hb_compIdentifierNew( yytext, TRUE );
               iRet = MACROVAR;
            }
            else
            {
               yytext = hb_compIdentifierNew( yytext, TRUE );

               yylval.string = yytext;
               iRet = MACROTEXT;
            }
         }
         else
         {
            yytext = hb_compIdentifierNew( yytext, TRUE );

            yylval.string = yytext;
            iRet = MACROTEXT;
         }
      }
      else
      {
   	 DEBUG_INFO( printf(  "Element \"%s\" is IDENTIFIER\n", yytext ) );

         if( yyleng > HB_SYMBOL_NAME_LEN )
         {
            yytext[ HB_SYMBOL_NAME_LEN ] = '\0';
            yyleng = HB_SYMBOL_NAME_LEN;
         }

         if( iIdentifier )
         {
            DEBUG_INFO( printf( "*** iDentifier = %i - Holding %s\n", iIdentifier, yytext ) );
            sIdOnHold = hb_compIdentifierNew( yytext, TRUE );
            iRet = _ID_ON_HOLD;
         }
         else
         {
            iIdentifier++;
            DEBUG_INFO( printf( "Primary Identifier %s Increased to: %i\n", yytext, iIdentifier ) );
            yylval.string = hb_compIdentifierNew( yytext, TRUE );
   	    iRet = IDENTIFIER;
         }
      }
   }
   else
   {
      /* ConverNumber */

      yylval.string = (char*) hb_xgrab( TOKEN_SIZE );
      yylval.string[0] = 0;
      aTexts[iTexts++] = yylval.string;

      /* Hex Number */
      if( yytext[0] == '0' && yytext[1] == 'X' )
      {
         long lNumber = hb_comp_SLX_Hex2L( yytext + 2 );

         if( ( double ) SHRT_MIN <= lNumber && lNumber <= ( double ) SHRT_MAX )
         {
       	    yylval.valInteger.iNumber = lNumber;
       	    yylval.valInteger.szValue = yytext;
       	    iRet = NUM_INTEGER;
         }
         else if( ( double ) LONG_MIN <= lNumber && lNumber <= ( double ) LONG_MAX )
         {
       	    yylval.valLong.lNumber = lNumber;
       	    yylval.valLong.szValue = yytext;
       	    iRet = NUM_LONG;
         }
         else
         {
       	    /* NOTE: This will never happen */
       	    yylval.valDouble.dNumber = lNumber;
       	    yylval.valDouble.bWidth = HB_DEFAULT_WIDTH;
       	    yylval.valDouble.bDec = 0;
       	    yylval.valDouble.szValue = yytext;
       	    iRet = NUM_DOUBLE;
         }
      }
      else
      {
         yylval.valDouble.dNumber = atof( yytext );
         tmpPtr = strchr( yytext, '.' );

         if( tmpPtr )
         {
       	    yylval.valDouble.bDec = strlen( tmpPtr + 1 );
       	    yylval.valDouble.bWidth = yyleng - yylval.valDouble.bDec;
       	    if( yylval.valDouble.bDec )
	    {
               yylval.valDouble.bWidth--;
	    }
       	    yylval.valDouble.szValue = yytext;
       	    iRet = NUM_DOUBLE;
         }
         else
         {
       	    if( ( double )SHRT_MIN <= yylval.valDouble.dNumber && yylval.valDouble.dNumber <= ( double )SHRT_MAX )
       	    {
               yylval.valInteger.iNumber = ( int ) yylval.valDouble.dNumber;
               yylval.valInteger.szValue = yytext;
               iRet = NUM_INTEGER;
       	    }
       	    else if( ( double )LONG_MIN <= yylval.valDouble.dNumber && yylval.valDouble.dNumber <= ( double )LONG_MAX )
       	    {
               yylval.valLong.lNumber = ( long ) yylval.valDouble.dNumber;
               yylval.valLong.szValue = yytext;
               iRet = NUM_LONG;
       	    }
       	    else
       	    {
               yylval.valDouble.bWidth = yyleng + 1;
               yylval.valDouble.bDec = 0;
               yylval.valDouble.szValue = yytext;
               iRet = NUM_DOUBLE;
       	    }
         }
      }

      iRet += DONT_REDUCE;
   }

   DEBUG_INFO( printf(  "Element \"%s\" is %i\n", szToken, iRet ) );
   return iRet;
}

long hb_comp_SLX_Hex2L( char* sHex )
{
   int i, iExp = 0, iLen = strlen( sHex ) - 1;
   long lVal, lSum = 0;
   char cChar;

   while( iLen >= 0 )
   {
      cChar = sHex[ iLen-- ];

      if( cChar > 64 && cChar < 91 )
      {
         lVal = cChar - 55;
      }
      else
      {
         lVal = cChar - 48;
      }

      if( lVal )
      {
	 i = 0;
	 while( i++ < iExp )
	 {
	    lVal *= 16;
	 }

         lSum += lVal;
      }

      iExp++;
   }

   return lSum;
}

int hb_comp_SLX_CustomAction( int x, int aiHold[], int *ptr_iHold, BOOL *ptr_bIgnoreWords, int iLastToken, char *sToken, char *s_szBuffer )
{
   DEBUG_INFO( printf( "Custom Action for %i\n", x ) );

   if( x < HB_WANTS_EXP )
   {
	   *ptr_bIgnoreWords = FALSE;
      iWantsEXP = (-x) + (HB_WANTS_EXP) ;
	   return REJECT_OP;
   }
   else if( x < HB_WANTS_EOL )
   {
      iWantsEOL = (-x) + (HB_WANTS_EOL) ;
      return WANTS_EOL;
   }
   else if( x < HB_WANTS_ID )
   {
      iWantsID = (-x) + (HB_WANTS_ID) ;
      return WANTS_ID;
   }
   else if( x < HB_WANTS_VAR )
   {
      iWantsVAR = (-x) + (HB_WANTS_VAR) ;
      return WANTS_VAR;
   }

   switch ( x )
   {
      case HB_IDENTIFIER :
         yylval.string = hb_compIdentifierNew( (char*) sToken, TRUE );
         iIdentifier++;
         DEBUG_INFO( printf( "Primary Identifier %s Increased to: %i\n", (char*) sToken, iIdentifier ) );
         return IDENTIFIER + DONT_REDUCE;

      case HB_SELF :
         aiHold[ (*ptr_iHold)++ ] = ':' + DONT_REDUCE ;
         yylval.string = hb_compIdentifierNew( "SELF", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_SELF, Primary Identifier %s Increased to: %i\n", "SELF", iIdentifier ) );
         return IDENTIFIER;

      case HB_CHK_BLOCK :
	 if( s_sLastBlock == NULL )
	 {
	    char *pTmp = (char *) s_szBuffer;

	    /* Skip White Space. */
	    while( *pTmp && ( *pTmp == ' ' || *pTmp == '\t' ) )
	    {
               pTmp++;
	    }

	    if( *pTmp == '|' )
	    {
	       unsigned int iBrackets = 1;
	       char cTmp;

               pTmp++;
	       while( *pTmp )
	       {
		  if( *pTmp == '}' )
		  {
		     iBrackets--;
		     if( iBrackets == 0 )
		     {
		        break;
		     }
		  }
		  else if( *pTmp == '{' )
		  {
		     iBrackets++;
		  }
                  pTmp++;
	       }

	       pTmp++;
	       cTmp = *pTmp;
	       *pTmp = '\0';

	       s_sLastBlock = hb_compIdentifierNew( s_szBuffer - 1, TRUE );

	       *pTmp = cTmp;
	    }
	 }
	 return '{' + DONT_REDUCE;

      case HB_LIT_ACT :
         yylval.string = hb_compIdentifierNew( sPair, TRUE );
         return LITERAL + DONT_REDUCE ;

      case HB_INIT_PROC :
         aiHold[ (*ptr_iHold)++ ] = PROCEDURE + DONT_REDUCE;
         return INIT + DONT_REDUCE;

      case HB_INIT_FUNC :
         aiHold[ (*ptr_iHold)++ ] = FUNCTION + DONT_REDUCE;
         return INIT + DONT_REDUCE;

      case HB_EXIT_PROC :
         aiHold[ (*ptr_iHold)++ ] = PROCEDURE + DONT_REDUCE;
         return EXIT + DONT_REDUCE;

      case HB_EXIT_FUNC :
         aiHold[ (*ptr_iHold)++ ] = FUNCTION + DONT_REDUCE;
         return EXIT + DONT_REDUCE;

      case HB_STATIC_PROC :
         aiHold[ (*ptr_iHold)++ ] = PROCEDURE + DONT_REDUCE;
         return STATIC + DONT_REDUCE;

      case HB_STATIC_FUNC :
         aiHold[ (*ptr_iHold)++ ] = FUNCTION + DONT_REDUCE;
         return STATIC + DONT_REDUCE;

      case HB_IN :
         *ptr_bIgnoreWords = FALSE;
	 if( iLastToken == IDENTIFIER )
	    { return IN + DONT_REDUCE; }
	 else
	 {
            yylval.string = hb_compIdentifierNew( "IN", TRUE );
            iIdentifier++;
            DEBUG_INFO( printf( "HB_IN, Primary Identifier %s Increased to: %i\n", "IN", iIdentifier ) );
            return IDENTIFIER;
	  }

      case HB_STEP :
         *ptr_bIgnoreWords = FALSE;
	 if( iLastToken == NUM_INTEGER || iLastToken == IDENTIFIER || iLastToken == MACROVAR || iLastToken == MACROTEXT || iLastToken == ')' || iLastToken == ']' )
	    { return STEP + DONT_REDUCE; }
	 else
            {
              yylval.string = hb_compIdentifierNew( "STEP", TRUE );
              iIdentifier++;
              DEBUG_INFO( printf( "HB_STEP, Primary Identifier %s Increased to: %i\n", "STEP", iIdentifier ) );
              return IDENTIFIER;
            }

      case HB_TO :
         *ptr_bIgnoreWords = FALSE;
	 if( iLastToken == NUM_INTEGER || iLastToken == IDENTIFIER || iLastToken == MACROVAR || iLastToken == MACROTEXT || iLastToken == ')' || iLastToken == ']' )
	    { return TO + DONT_REDUCE; }
	 else
            {
              yylval.string = hb_compIdentifierNew( "TO", TRUE );
              iIdentifier++;
              DEBUG_INFO( printf( "HB_TO, Primary Identifier %s Increased to: %i\n", "IN", iIdentifier ) );
              return IDENTIFIER;
            }

      case HB_WITH :
         *ptr_bIgnoreWords = FALSE;
	 if( iLastToken == IDENTIFIER || iLastToken == MACROVAR || iLastToken == MACROTEXT )
	    { return WITH + DONT_REDUCE; }
	 else
	 {
            yylval.string = hb_compIdentifierNew( "WITH", TRUE );
            iIdentifier++;
            DEBUG_INFO( printf( "HB_WITH, Primary Identifier %s Increased to: %i\n", "WITH", iIdentifier ) );
            return IDENTIFIER;
	  }

      case _WITH_ID_CR :
         aiHold[ (*ptr_iHold)++ ] = '\n' + DONT_REDUCE;
         yylval.string = hb_compIdentifierNew( "WITH", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "_WITH_ID_CR, Primary Identifier %s Increased to: %i\n", "WITH", iIdentifier ) );
         return IDENTIFIER + DONT_REDUCE;

      case _WITH_ID_SEMI :
         aiHold[ (*ptr_iHold)++ ] = ';' + DONT_REDUCE;
         yylval.string = hb_compIdentifierNew( "WITH", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "_WITH_ID_SEMI, Primary Identifier %s Increased to: %i\n", "WITH", iIdentifier ) );
         return IDENTIFIER + DONT_REDUCE;

      case HB_NESTED_LIT :
      {
	 int iPairLen = strlen( sPair );

	 sPair[ iPairLen ] = sTerm[0];
	 sPair[ iPairLen + 1 ] = '\0';
         yylval.string = hb_compIdentifierNew( sPair, TRUE );
         return LITERAL + DONT_REDUCE ;
      }

      case HB_QOUT_ACT :
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_QOUT_ACT, Primary Identifier %s Increased to: %i\n", "QOUT", iIdentifier ) );
         yylval.string = hb_compIdentifierNew( "QOUT", TRUE );
         aiHold[ (*ptr_iHold)++ ] = '(' + DONT_REDUCE;
         aiHold[ (*ptr_iHold)++ ] = IDENTIFIER + DONT_REDUCE;
         return _QOUT_LIT;

      case HB_RET_QOUT_LIT :
         yylval.string = hb_compIdentifierNew( sPair, TRUE );
         aiHold[ (*ptr_iHold)++ ] = '\n' + DONT_REDUCE;
         aiHold[ (*ptr_iHold)++ ] = ')' + DONT_REDUCE;
         return LITERAL + DONT_REDUCE ;

      case HB_DO_WHILE_ID :
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_DO_WHILE_ID, Primary Identifier %s Increased to: %i\n", "WHILE", iIdentifier ) );
         yylval.string = hb_compIdentifierNew( "WHILE", TRUE );
         aiHold[ (*ptr_iHold)++ ] = IDENTIFIER + DONT_REDUCE;
         return DO + DONT_REDUCE;

      case HB_DO_WHILE_WITH :
         aiHold[ (*ptr_iHold)++ ] = WITH + DONT_REDUCE;
         yylval.string = hb_compIdentifierNew( "WHILE", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_DO_WHILE_WITH, Primary Identifier %s Increased to: %i\n", "WHILE", iIdentifier ) );
         aiHold[ (*ptr_iHold)++ ] = IDENTIFIER + DONT_REDUCE;
         return DO + DONT_REDUCE;

      case HB_DO_CASE_ID :
         yylval.string = hb_compIdentifierNew( "CASE", TRUE );
	 iIdentifier++;
	 DEBUG_INFO( printf( "HB_DO_CASE_ID, Primary Identifier %s Increased to: %i\n", "CASE", iIdentifier ) );
         aiHold[ (*ptr_iHold)++ ] = IDENTIFIER + DONT_REDUCE;
         return DO + DONT_REDUCE;

      case HB_MACRO_ERR :
	 hb_compGenError( hb_comp_szErrors, 'E', HB_COMP_ERR_SYNTAX, "&", NULL );
         return  0;

      case HB_ID_ON_HOLD :
         yylval.string = sIdOnHold;
	 iIdentifier++;
	 DEBUG_INFO( printf( "RELEASED ID_ON_HOLD: %s - Increased to: %i\n", sIdOnHold, iIdentifier ) );
         return IDENTIFIER;

      default:
         printf( "WARNING! No Handler for Custom Action %i\n", x );
   }

   return x;
}

int yy_lex_input( char *buffer, int iBufferSize )
{
   HB_SYMBOL_UNUSED( buffer );
   HB_SYMBOL_UNUSED( iBufferSize );

   return hb_pp_Internal( hb_comp_bPPO ? hb_comp_yyppo : NULL, buffer );
}

char * hb_comp_SLX_LastBlock( BOOL bReset )
{
   if( bReset && s_sLastBlock )
   {
      //hb_xfree( s_sLastBlock );
      s_sLastBlock = NULL;
   }

   return s_sLastBlock;
}
