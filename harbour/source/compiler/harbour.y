%pure-parser
%parse-param { HB_COMP_PTR pComp }
%lex-param   { HB_COMP_PTR pComp }
%{
/*
 * $Id$
 */

/*
 * Harbour Project source code:
 * Compiler YACC rules and actions
 *
 * Copyright 1999 Antonio Linares <alinares@fivetech.com>
 * www - http://www.harbour-project.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA (or visit
 * their web site at http://www.gnu.org/).
 *
 */

/* TODO list
 * 1) Change the pcode generated by ::cVar from Self:cVar to QSELF():cVar
 *    The major problem to solve is how to support QSELF() inside a codeblock.
 */

#include "hbcomp.h"
#undef alloca
#define alloca  hb_xgrab
#undef malloc
#define malloc  hb_xgrab
#undef realloc
#define realloc hb_xrealloc
#undef free
#define free    hb_xfree

/* Compile using: bison -d -v harbour.y */

static void hb_compLoopStart( HB_COMP_DECL );
static void hb_compLoopEnd( HB_COMP_DECL );
static void hb_compLoopLoop( HB_COMP_DECL );
static void hb_compLoopExit( HB_COMP_DECL );
static void hb_compLoopHere( HB_COMP_DECL );

static void * hb_compElseIfGen( HB_COMP_DECL, void * pFirstElseIf, ULONG ulOffset ); /* generates a support structure for elseifs pcode fixups */
static void hb_compElseIfFix( HB_COMP_DECL, void * pIfElseIfs ); /* implements the ElseIfs pcode fixups */

static void hb_compRTVariableAdd( HB_COMP_DECL, HB_EXPR_PTR, BOOL );
static void hb_compRTVariableGen( HB_COMP_DECL, char * );

static void hb_compVariableDim( char *, HB_EXPR_PTR, HB_COMP_DECL );

static void hb_compForStart( HB_COMP_DECL, char *szVarName, BOOL bForEach );
static void hb_compForEnd( HB_COMP_DECL, char *szVarName );
static void hb_compEnumStart( HB_COMP_DECL, HB_EXPR_PTR pVars, HB_EXPR_PTR pExprs, int descend );
static void hb_compEnumNext( HB_COMP_DECL, HB_EXPR_PTR pExpr, int descend );
static void hb_compEnumEnd( HB_COMP_DECL, HB_EXPR_PTR pExpr );

static void hb_compSwitchStart( HB_COMP_DECL );
static void hb_compSwitchAdd( HB_COMP_DECL, HB_EXPR_PTR );
static void hb_compSwitchEnd( HB_COMP_DECL );

static HB_EXPR_PTR hb_compCheckPassByRef( HB_COMP_DECL, HB_EXPR_PTR pExpr );

#ifdef HARBOUR_YYDEBUG
   #define YYDEBUG        1 /* Parser debug information support */
#endif

/* Controls if passing by reference '@' is allowed */
#define HB_PASSBYREF_OFF      0
#define HB_PASSBYREF_FUNCALL  1
#define HB_PASSBYREF_ARRAY    2

static void hb_compDebugStart( void ) { };

%}

%union                  /* special structure used by lex and yacc to share info */
{
   char *  string;      /* to hold a string returned by lex */
   int     iNumber;     /* to hold a temporary integer number */
   HB_LONG lNumber;     /* to hold a temporary long number */
   BOOL    bTrue;
   struct
   {
      HB_LONG  lNumber;    /* to hold a long number returned by lex */
      UCHAR    bWidth;     /* to hold the width of the value */
   } valLong;
   struct
   {
      double   dNumber;    /* to hold a double number returned by lex */
      /* NOTE: Intentionally using "unsigned char" instead of "BYTE" */
      UCHAR    bWidth;     /* to hold the width of the value */
      UCHAR    bDec;       /* to hold the number of decimal points in the value */
   } valDouble;
   HB_EXPR_PTR asExpr;
   struct
   {
      char *   string;
      int      length;
      BOOL     dealloc;
   } valChar;
   struct
   {
      char *   string;
      int      length;
      BOOL     lateEval; /* Flag for early {|| &macro} (0) or late {|| &(macro)} (1) binding */
      BOOL     isMacro;
   } asCodeblock;
   struct
   {
      BOOL bMacro;
      union 
      {
         char * string;
         HB_EXPR_PTR macro;
      } value;
   } asMessage;
   void * pVoid;        /* to hold any memory structure we may need */
};

%{
/* This must be placed after the above union - the union is
 * typedef-ined to YYSTYPE
 */
extern int  yylex( YYSTYPE *, HB_COMP_DECL );    /* main lex token function, called by yyparse() */
extern int  yyparse( HB_COMP_DECL );             /* main yacc parsing function */
extern void yyerror( HB_COMP_DECL, char * );     /* parsing error management function */
%}


%token FUNCTION PROCEDURE IDENTIFIER RETURN NIL NUM_DOUBLE INASSIGN NUM_LONG
%token LOCAL STATIC IIF IF ELSE ELSEIF END ENDIF LITERAL TRUEVALUE FALSEVALUE
%token ANNOUNCE EXTERN INIT EXIT AND OR NOT PUBLIC EQ NE1 NE2
%token INC DEC ALIASOP DOCASE CASE OTHERWISE ENDCASE ENDDO MEMVAR
%token WHILE LOOP FOR NEXT TO STEP LE GE FIELD IN PARAMETERS
%token PLUSEQ MINUSEQ MULTEQ DIVEQ POWER EXPEQ MODEQ
%token PRIVATE BEGINSEQ BREAK RECOVER RECOVERUSING DO WITH SELF LINE
%token MACROVAR MACROTEXT
%token AS_ARRAY AS_BLOCK AS_CHARACTER AS_CLASS AS_DATE AS_LOGICAL AS_NUMERIC AS_OBJECT AS_VARIANT DECLARE OPTIONAL DECLARE_CLASS DECLARE_MEMBER
%token AS_ARRAY_ARRAY AS_BLOCK_ARRAY AS_CHARACTER_ARRAY AS_CLASS_ARRAY AS_DATE_ARRAY AS_LOGICAL_ARRAY AS_NUMERIC_ARRAY AS_OBJECT_ARRAY
%token PROCREQ
%token CBSTART DOIDENT
%token FOREACH DESCEND
%token DOSWITCH WITHOBJECT
%token NUM_DATE
%token EPSILON 

/*the lowest precedence*/
/*postincrement and postdecrement*/
%left  POST
/*assigment - from right to left*/
%right INASSIGN
%right  PLUSEQ MINUSEQ
%right  MULTEQ DIVEQ MODEQ
%right  EXPEQ
/*logical operators*/
%right  OR
%right  AND
%right  NOT
/*relational operators*/
%right  '=' '<' '>' EQ NE1 NE2 LE GE '$'
/*mathematical operators*/
%right  '+' '-'
%right  '*' '/' '%'
%right  POWER
%right UNARY
/*preincrement and predecrement*/
%right  PRE
/*special operators*/
%right  ALIASOP '&' '@'
%right '\n' ';' ','
/*the highest precedence*/

%type <string>  IdentName IDENTIFIER MACROVAR MACROTEXT CompTimeStr
%type <string>  DOIDENT WHILE
%type <valChar> LITERAL
%type <valDouble>  NUM_DOUBLE
%type <valLong>    NUM_LONG
%type <valLong>    NUM_DATE
%type <iNumber> FunScope
%type <iNumber> Params ParamList
%type <iNumber> IfBegin VarList ExtVarList
%type <iNumber> FieldList
%type <iNumber> Descend
%type <lNumber> WhileBegin
%type <pVoid>   IfElseIf Cases
%type <asExpr>  ArgList ElemList BlockExpList BlockVarList BlockNoVar
%type <asExpr>  DoName DoProc DoArgument DoArgList
%type <asExpr>  PareExpList1 PareExpList2 PareExpList3 PareExpListN
%type <asExpr>  ExpList ExpList1 ExpList2 ExpList3
%type <asExpr>  NumValue NumAlias
%type <asExpr>  NilValue NilAlias
%type <asExpr>  LiteralValue LiteralAlias
%type <asExpr>  CodeBlock CodeBlockAlias
%type <asExpr>  Logical LogicalAlias
%type <asExpr>  SelfValue SelfAlias
%type <asExpr>  Array ArrayAlias
%type <asExpr>  ArrayAt ArrayAtAlias
%type <asExpr>  Variable VarAlias
%type <asExpr>  MacroVar MacroVarAlias
%type <asExpr>  MacroExpr MacroExprAlias
%type <asExpr>  AliasId AliasVar AliasExpr
%type <asExpr>  VariableAt VariableAtAlias
%type <asExpr>  FunIdentCall FunCall FunCallAlias
%type <asExpr>  ObjectData ObjectDataAlias
%type <asExpr>  ObjectMethod ObjectMethodAlias
%type <asExpr>  IfInline IfInlineAlias
%type <asExpr>  PareExpList PareExpListAlias
%type <asExpr>  Expression SimpleExpression LValue
%type <asExpr>  EmptyExpression
%type <asExpr>  ExprAssign ExprOperEq ExprPreOp ExprPostOp
%type <asExpr>  ExprEqual ExprMath ExprBool ExprRelation ExprUnary
%type <asExpr>  ExprPlusEq ExprMinusEq ExprMultEq ExprDivEq ExprModEq ExprExpEq
%type <asExpr>  ArrayIndex IndexList
%type <asExpr>  DimIndex DimList
%type <asExpr>  FieldAlias FieldVarAlias
%type <asExpr>  PostOp
%type <asExpr>  ForVar ForList ForExpr
%type <asCodeblock> CBSTART
%type <asExpr>  DateValue
%type <asMessage> SendId

/* NOTE: direct using of hb_comp_data is not MT safe but
   the version of bison (1.875c) I'm using now does not
   support %parse-param for destructors. I can create a
   work around for it but documentation says that %destructor
   should respect pure parser parameters so probably it will
   be (already is?) fixed in next releases do now I'm leaving 
   it as is. [druzus]
 */
%destructor { 
               hb_compExprDelete( $$, hb_comp_data );
            }
            ArgList ElemList BlockExpList BlockVarList BlockNoVar
            DoName DoProc DoArgument DoArgList
            PareExpList1 PareExpList2 PareExpList3 PareExpListN
            ExpList ExpList1 ExpList2 ExpList3
            NumValue NumAlias
            NilValue NilAlias
            DateValue
            LiteralValue LiteralAlias
            CodeBlock CodeBlockAlias
            Logical LogicalAlias
            SelfValue SelfAlias
            Array ArrayAlias
            ArrayAt ArrayAtAlias
            Variable VarAlias
            MacroVar MacroVarAlias
            MacroExpr MacroExprAlias
            AliasId AliasVar AliasExpr
            VariableAt VariableAtAlias
            FunIdentCall FunCall FunCallAlias
            ObjectData ObjectDataAlias
            ObjectMethod ObjectMethodAlias
            IfInline IfInlineAlias
            PareExpList PareExpListAlias
            Expression SimpleExpression LValue
            EmptyExpression
            ExprAssign ExprOperEq ExprPreOp ExprPostOp
            ExprEqual ExprMath ExprBool ExprRelation ExprUnary
            ExprPlusEq ExprMinusEq ExprMultEq ExprDivEq ExprModEq ExprExpEq
            ArrayIndex IndexList
            DimIndex DimList
            FieldAlias FieldVarAlias
            PostOp
            ForVar ForList ForExpr

%destructor { hb_xfree( $$.string ); } CBSTART
%destructor { if( $$.dealloc ) hb_xfree( $$.string ); } LITERAL

%%

Main       : { hb_compLinePush( HB_COMP_PARAM ); } Source       { }
           | /* empty file */
           ;

Source     : Crlf
           | VarDefs
           | FieldsDef
           | MemvarDef
           | Declaration
           | Function
           | Statement
           | Line
           | ProcReq
           | error  Crlf  { yyclearin; yyerrok; }
           | Source Crlf
           | Source VarDefs
           | Source FieldsDef
           | Source MemvarDef
           | Source Declaration
           | Source Function
           | Source Statement
           | Source Line
           | Source ProcReq
           | Source error Crlf  { yyclearin; yyerrok; }
           ;

Line       : LINE NUM_LONG LITERAL Crlf
           | LINE NUM_LONG LITERAL '@' LITERAL Crlf   /* Xbase++ style */
           ;

ProcReq    : PROCREQ CompTimeStr ')' Crlf { HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           ;

CompTimeStr: LITERAL {
               if( $1.dealloc )
               {
                  $1.string = hb_compIdentifierNew( HB_COMP_PARAM, $1.string, FALSE );
                  $1.dealloc = FALSE;
               }
               hb_compAutoOpenAdd( HB_COMP_PARAM, $1.string );
            }
           | LITERAL '+' LITERAL {
               {
                  char szFileName[ _POSIX_PATH_MAX + 1 ];
                  hb_strncat( hb_strncpy( szFileName, $1.string, _POSIX_PATH_MAX ), $3.string, _POSIX_PATH_MAX );
                  hb_compAutoOpenAdd( HB_COMP_PARAM, hb_compIdentifierNew( HB_COMP_PARAM, szFileName, TRUE ) );
                  if( $1.dealloc )
                     hb_xfree( $1.string );
                  if( $3.dealloc )
                     hb_xfree( $3.string );
               }
            }
           ;

Function   : FunScope FUNCTION  IdentName { HB_COMP_PARAM->cVarType = ' '; hb_compFunctionAdd( HB_COMP_PARAM, $3, ( HB_SYMBOLSCOPE ) $1, 0 ); } Crlf {}
           | FunScope PROCEDURE IdentName { HB_COMP_PARAM->cVarType = ' '; hb_compFunctionAdd( HB_COMP_PARAM, $3, ( HB_SYMBOLSCOPE ) $1, FUN_PROCEDURE ); } Crlf {}
           | FunScope FUNCTION  IdentName { HB_COMP_PARAM->cVarType = ' '; hb_compFunctionAdd( HB_COMP_PARAM, $3, ( HB_SYMBOLSCOPE ) $1, 0 ); HB_COMP_PARAM->iVarScope = VS_PARAMETER; } '(' Params ')' Crlf {}
           | FunScope PROCEDURE IdentName { HB_COMP_PARAM->cVarType = ' '; hb_compFunctionAdd( HB_COMP_PARAM, $3, ( HB_SYMBOLSCOPE ) $1, FUN_PROCEDURE ); HB_COMP_PARAM->iVarScope = VS_PARAMETER;} '(' Params ')' Crlf {}
           ;

FunScope   :                  { $$ = HB_FS_PUBLIC; }
           | STATIC           { $$ = HB_FS_STATIC; }
           | INIT             { $$ = HB_FS_INIT; }
           | EXIT             { $$ = HB_FS_EXIT; }
           ;

Params     : /*no parameters */ { $$ = 0; }
           | EPSILON { HB_COMP_PARAM->functions.pLast->pCode[0] = HB_P_VFRAME; $$ = 0; }
           | ParamList { $$ = $1; }
           | ParamList ',' EPSILON { HB_COMP_PARAM->functions.pLast->pCode[0] = HB_P_VFRAME; $$ = $1; }
           ;

AsType     : /* not specified */           { HB_COMP_PARAM->cVarType = ' '; }
           | StrongType
           ;

StrongType : AS_NUMERIC                    { HB_COMP_PARAM->cVarType = 'N'; }
           | AS_CHARACTER                  { HB_COMP_PARAM->cVarType = 'C'; }
           | AS_DATE                       { HB_COMP_PARAM->cVarType = 'D'; }
           | AS_LOGICAL                    { HB_COMP_PARAM->cVarType = 'L'; }
           | AS_BLOCK                      { HB_COMP_PARAM->cVarType = 'B'; }
           | AS_OBJECT                     { HB_COMP_PARAM->cVarType = 'O'; }
           | AS_CLASS IdentName            { HB_COMP_PARAM->cVarType = 'S'; HB_COMP_PARAM->szFromClass = $2; }
           | AS_VARIANT                    { HB_COMP_PARAM->cVarType = ' '; }
           | AsArray
           ;

AsArray    : AS_ARRAY                      { HB_COMP_PARAM->cVarType = 'A'; }
           | AS_NUMERIC_ARRAY              { HB_COMP_PARAM->cVarType = 'n'; }
           | AS_CHARACTER_ARRAY            { HB_COMP_PARAM->cVarType = 'c'; }
           | AS_DATE_ARRAY                 { HB_COMP_PARAM->cVarType = 'd'; }
           | AS_LOGICAL_ARRAY              { HB_COMP_PARAM->cVarType = 'l'; }
           | AS_ARRAY_ARRAY                { HB_COMP_PARAM->cVarType = 'a'; }
           | AS_BLOCK_ARRAY                { HB_COMP_PARAM->cVarType = 'b'; }
           | AS_OBJECT_ARRAY               { HB_COMP_PARAM->cVarType = 'o'; }
           | AS_CLASS_ARRAY IdentName      { HB_COMP_PARAM->cVarType = 's'; HB_COMP_PARAM->szFromClass = $2; }
           ;

ParamList  : IdentName AsType                { hb_compVariableAdd( HB_COMP_PARAM, $1, HB_COMP_PARAM->cVarType ); $$ = 1; }
           | ParamList ',' IdentName AsType  { hb_compVariableAdd( HB_COMP_PARAM, $3, HB_COMP_PARAM->cVarType ); $$++; }
           ;

/* NOTE: This allows the use of Expression as a statement.
 *    The Expression is validated later in reduction phase of
 *    hb_compExprGenStatement(). With this solution we don't have to
 *    stop compilation if invalid syntax will be used.
 */
Statement  : ExecFlow { HB_COMP_PARAM->fDontGenLineNum = TRUE; } CrlfStmnt     { }
           | WithObject CrlfStmnt   { }
           | IfInline CrlfStmnt     { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | FunCall CrlfStmnt      { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | AliasExpr CrlfStmnt    { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | ObjectMethod CrlfStmnt { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | MacroVar CrlfStmnt     { if( HB_COMP_ISSUPPORTED( HB_COMPFLAG_XBASE ) )
                                         hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM );
                                      else
                                         hb_compExprDelete( hb_compErrorSyntax( HB_COMP_PARAM, $1 ), HB_COMP_PARAM );
                                       HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
                                    }
           | MacroExpr CrlfStmnt    { if( HB_COMP_ISSUPPORTED( HB_COMPFLAG_XBASE ) )
                                         hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM );
                                      else
                                         hb_compExprDelete( hb_compErrorSyntax( HB_COMP_PARAM, $1 ), HB_COMP_PARAM );
                                       HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
                                    }
           | PareExpList CrlfStmnt  { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | ExprPreOp CrlfStmnt    { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | ExprPostOp CrlfStmnt   { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | ExprOperEq CrlfStmnt   { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | ExprEqual CrlfStmnt    { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | ExprAssign CrlfStmnt   { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | DoProc CrlfStmnt       { hb_compExprDelete( hb_compExprGenStatement( $1, HB_COMP_PARAM ), HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN; }
           | BREAK CrlfStmnt        { hb_compGenBreak( HB_COMP_PARAM ); hb_compGenPCode2( HB_P_DOSHORT, 0, HB_COMP_PARAM );
                                      HB_COMP_PARAM->functions.pLast->bFlags |= FUN_BREAK_CODE; }
           | BREAK { hb_compLinePushIfInside( HB_COMP_PARAM ); } Expression Crlf  { hb_compGenBreak( HB_COMP_PARAM ); hb_compExprDelete( hb_compExprGenPush( $3, HB_COMP_PARAM ), HB_COMP_PARAM );
                                           hb_compGenPCode2( HB_P_DOSHORT, 1, HB_COMP_PARAM );
                                           HB_COMP_PARAM->functions.pLast->bFlags |= FUN_BREAK_CODE;
                                         }
           | RETURN CrlfStmnt {
                     if( HB_COMP_PARAM->wSeqCounter )
                        {
                           hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "RETURN", NULL );
                        }
                        hb_compGenPCode1( HB_P_ENDPROC, HB_COMP_PARAM );
                        if( (HB_COMP_PARAM->functions.pLast->bFlags & FUN_PROCEDURE) == 0 )
                        { /* return from a function without a return value */
                           hb_compGenWarning( HB_COMP_PARAM, hb_comp_szWarnings, 'W', HB_COMP_WARN_NO_RETURN_VALUE, NULL, NULL );
                        }
                        HB_COMP_PARAM->functions.pLast->bFlags |= FUN_WITH_RETURN;
                        HB_COMP_PARAM->fDontGenLineNum = TRUE;
                        HB_COMP_PARAM->functions.pLast->bFlags |= FUN_BREAK_CODE;
                     }
           | RETURN { hb_compLinePushIfInside( HB_COMP_PARAM ); HB_COMP_PARAM->cVarType = ' '; } Expression Crlf {

                        HB_COMP_PARAM->cCastType = HB_COMP_PARAM->cVarType;
                        HB_COMP_PARAM->cVarType = ' ';

                        if( HB_COMP_PARAM->wSeqCounter )
                        {
                           hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "RETURN", NULL );
                        }
                        hb_compExprDelete( hb_compExprGenPush( $3, HB_COMP_PARAM ), HB_COMP_PARAM );   /* TODO: check if return value agree with declared value */
                        hb_compGenPCode2( HB_P_RETVALUE, HB_P_ENDPROC, HB_COMP_PARAM );
                        if( HB_COMP_PARAM->functions.pLast->bFlags & FUN_PROCEDURE )
                        { /* procedure returns a value */
                           hb_compGenWarning( HB_COMP_PARAM, hb_comp_szWarnings, 'W', HB_COMP_WARN_PROC_RETURN_VALUE, NULL, NULL );
                        }
                        HB_COMP_PARAM->functions.pLast->bFlags |= FUN_WITH_RETURN;
                        HB_COMP_PARAM->fDontGenLineNum = TRUE;
                        HB_COMP_PARAM->functions.pLast->bFlags |= FUN_BREAK_CODE;
                     }
           | PUBLIC { hb_compLinePushIfInside( HB_COMP_PARAM ); HB_COMP_PARAM->iVarScope = VS_PUBLIC; }
                     ExtVarList
                    { hb_compRTVariableGen( HB_COMP_PARAM, "__MVPUBLIC" ); 
                      HB_COMP_PARAM->cVarType = ' ';  HB_COMP_PARAM->iVarScope = VS_NONE; 
                      HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
                    } Crlf
           | PRIVATE { hb_compLinePushIfInside( HB_COMP_PARAM ); HB_COMP_PARAM->iVarScope = VS_PRIVATE; }
                     ExtVarList
                    { hb_compRTVariableGen( HB_COMP_PARAM, "__MVPRIVATE" ); 
                      HB_COMP_PARAM->cVarType = ' '; HB_COMP_PARAM->iVarScope = VS_NONE; 
                      HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
                    } Crlf

           | EXIT { HB_COMP_PARAM->fDontGenLineNum = !HB_COMP_PARAM->fDebugInfo; } CrlfStmnt { hb_compLoopExit( HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags |= FUN_BREAK_CODE; }
           | LOOP { HB_COMP_PARAM->fDontGenLineNum = !HB_COMP_PARAM->fDebugInfo; } CrlfStmnt { hb_compLoopLoop( HB_COMP_PARAM ); HB_COMP_PARAM->functions.pLast->bFlags |= FUN_BREAK_CODE; }
           | EXTERN ExtList Crlf
           | ANNOUNCE IdentName {
               if( HB_COMP_PARAM->szAnnounce == NULL )
               {
                  /* check for reserved name
                  * NOTE: Clipper doesn't check for it
                  */
                  char * szFunction = hb_compReservedName( $2 );
                  if( szFunction )
                     hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_FUNC_RESERVED, szFunction, $2 );
                  HB_COMP_PARAM->szAnnounce = $2;
               }
               else
                  hb_compGenWarning( HB_COMP_PARAM, hb_comp_szWarnings, 'W', HB_COMP_WARN_DUPL_ANNOUNCE, $2, NULL );
             } Crlf
           ;

CrlfStmnt  : { hb_compLinePushIfInside( HB_COMP_PARAM ); } Crlf
           ;

LineStat   : Crlf          { $<lNumber>$ = 0; HB_COMP_PARAM->fDontGenLineNum = TRUE; }
           | Statement     { $<lNumber>$ = 1; }
           | Declaration   { $<lNumber>$ = 1; }
           | Line          { $<lNumber>$ = 1; }
           ;

Statements : LineStat                  { $<lNumber>$ = $<lNumber>1; }
           | Statements LineStat       { $<lNumber>$ += $<lNumber>2; }
           ;

ExtList    : IdentName                 { hb_compExternAdd( HB_COMP_PARAM, $1 ); }
           | ExtList ',' IdentName     { hb_compExternAdd( HB_COMP_PARAM, $3 ); }
           ;

IdentName  : IDENTIFIER       { $$ = $1; }
           | STEP             { $$ = "STEP"; }
           | TO               { $$ = "TO"; }
           | OPTIONAL         { $$ = $<string>1; }
           | LOOP             { $$ = "LOOP"; }
           | EXIT             { $$ = "EXIT"; }
           | IN               { $$ = "IN"; }
           | EXTERN           { $$ = $<string>1; }
           | ANNOUNCE         { $$ = $<string>1; }
           | LOCAL            { $$ = $<string>1; }
           | MEMVAR           { $$ = $<string>1; }
           | STATIC           { $$ = $<string>1; }
           | PRIVATE          { $$ = $<string>1; }
           | PUBLIC           { $$ = $<string>1; }
           | PARAMETERS       { $$ = $<string>1; }
           | PROCREQ          { $$ = $<string>1; }
           | DESCEND          { $$ = $<string>1; }
           ;

/* Numeric values
 */
NumValue   : NUM_DOUBLE          { $$ = hb_compExprNewDouble( $1.dNumber, $1.bWidth, $1.bDec, HB_COMP_PARAM ); }
           | NUM_LONG            { $$ = hb_compExprNewLong( $1.lNumber, HB_COMP_PARAM ); }
           ;

DateValue  : NUM_DATE            { $$ = hb_compExprNewDate( $1.lNumber, HB_COMP_PARAM );
                                    if( $1.lNumber == 0 )
                                    {
                                       hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_INVALID_DATE, HB_COMP_PARAM->pLex->lasttok, NULL );
                                    }
                                 }
           ;
           
NumAlias   : NUM_LONG    ALIASOP    { $$ = hb_compExprNewLong( $1.lNumber, HB_COMP_PARAM ); }
           | NUM_DOUBLE  ALIASOP    { $$ = hb_compErrorAlias( HB_COMP_PARAM, hb_compExprNewDouble( $1.dNumber, $1.bWidth, $1.bDec, HB_COMP_PARAM ) ); }
           ;

/* NIL value
 */
NilValue   : NIL                    { $$ = hb_compExprNewNil( HB_COMP_PARAM ); }
           ;

NilAlias   : NilValue ALIASOP       { $$ = $1; }
           ;

/* Literal string value
 */
LiteralValue : LITERAL        {
                                 $$ = hb_compExprNewString( $1.string, $1.length, $1.dealloc, HB_COMP_PARAM );
                              }
             ;

LiteralAlias : LiteralValue ALIASOP       { $$ = $1; }
             ;

/* Codeblock value
 */
CodeBlockAlias : CodeBlock ALIASOP        { $$ = $1; }
               ;

/* Logical value
 */
Logical    : TRUEVALUE              { $$ = hb_compExprNewLogical( TRUE, HB_COMP_PARAM ); }
           | FALSEVALUE             { $$ = hb_compExprNewLogical( FALSE, HB_COMP_PARAM ); }
           ;

LogicalAlias : Logical ALIASOP      { $$ = $1; }
;

/* SELF value and expressions
 */
SelfValue  : SELF                   { $$ = hb_compExprNewSelf( HB_COMP_PARAM ); }
;

SelfAlias  : SelfValue ALIASOP      { $$ = $1; }
           ;

/* Literal array
 */
Array      : '{' {$<bTrue>$=HB_COMP_PARAM->iPassByRef;HB_COMP_PARAM->iPassByRef=HB_PASSBYREF_ARRAY;} ElemList '}'          { $$ = hb_compExprNewArray( $3, HB_COMP_PARAM ); HB_COMP_PARAM->iPassByRef=$<bTrue>2; }
           ;

ArrayAlias  : Array ALIASOP         { $$ = $1; }
            ;

/* Literal array access
 */
ArrayAt     : Array ArrayIndex      { $$ = $2; }
            ;

ArrayAtAlias : ArrayAt ALIASOP      { $$ = $1; }
             ;

/* Variables
 */
Variable    : IdentName             { $$ = hb_compExprNewVar( $1, HB_COMP_PARAM ); }
            ;

VarAlias    : IdentName ALIASOP     { $$ = hb_compExprNewAlias( $1, HB_COMP_PARAM ); }
            ;

/* Macro variables
 */
MacroVar    : MACROVAR        { $$ = hb_compExprNewMacro( NULL, '&', $1, HB_COMP_PARAM ); }
            | MACROTEXT       { $$ = hb_compExprNewMacro( NULL, 0, $1, HB_COMP_PARAM ); }
            ;

MacroVarAlias  : MacroVar ALIASOP   { $$ = $1; }
               ;

/* Macro expressions
 */
MacroExpr  : '&' PareExpList       { $$ = hb_compExprNewMacro( $2, 0, NULL, HB_COMP_PARAM ); }
           ;

MacroExprAlias : MacroExpr ALIASOP     { $$ = $1; }
               ;

/* Aliased variables
 */
/* special case: _FIELD-> and FIELD-> can be nested
 */
FieldAlias  : FIELD ALIASOP               { $$ = hb_compExprNewAlias( "FIELD", HB_COMP_PARAM ); }
            | FIELD ALIASOP FieldAlias    { $$ = $3; }
            ;

/* ignore _FIELD-> or FIELD-> if a real alias is specified
 */
FieldVarAlias  : FieldAlias VarAlias            { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = $2; }
               | FieldAlias NumAlias            { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = $2; }
               | FieldAlias PareExpListAlias    { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = $2; }
               | FieldAlias MacroVarAlias       { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = $2; }
               | FieldAlias MacroExprAlias      { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = $2; }
               | FieldAlias NilAlias            { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $2 ); }
               | FieldAlias LiteralAlias        { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $2 ); }
               | FieldAlias LogicalAlias        { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $2 ); }
               | FieldAlias CodeBlockAlias      { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $2 ); }
               | FieldAlias SelfAlias           { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $2 ); }
               | FieldAlias ArrayAlias          { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $2 ); }
               | FieldAlias ArrayAtAlias        { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $2 ); }
               | FieldAlias IfInlineAlias       { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $2 ); }
               ;

AliasId     : IdentName       { $$ = hb_compExprNewVar( $1, HB_COMP_PARAM ); }
            | MacroVar        { $$ = $1; }
            | MacroExpr       { $$ = $1; }
            ;

AliasVar   : NumAlias AliasId          { $$ = hb_compExprNewAliasVar( $1, $2, HB_COMP_PARAM ); }
           | MacroVarAlias AliasId     { $$ = hb_compExprNewAliasVar( $1, $2, HB_COMP_PARAM ); }
           | MacroExprAlias AliasId    { $$ = hb_compExprNewAliasVar( $1, $2, HB_COMP_PARAM ); }
           | PareExpListAlias AliasId  { $$ = hb_compExprNewAliasVar( $1, $2, HB_COMP_PARAM ); }
           | NilAlias AliasId          { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }
           | LiteralAlias AliasId      { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }
           | LogicalAlias AliasId      { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }
           | CodeBlockAlias AliasId    { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }
           | SelfAlias AliasId         { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }
           | ArrayAlias AliasId        { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }
           | ArrayAtAlias AliasId      { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }  /* QUESTION: Clipper reports error here - we can handle this */
           | VariableAtAlias AliasId   { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }  /* QUESTION: Clipper reports error here - we can handle this */
           | IfInlineAlias AliasId     { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }  /* QUESTION: Clipper reports error here - we can handle this */
           | FunCallAlias AliasId      { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }  /* QUESTION: Clipper reports error here - we can handle this */
           | ObjectDataAlias AliasId   { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }  /* QUESTION: Clipper reports error here - we can handle this */
           | ObjectMethodAlias AliasId { hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $1 ); }  /* QUESTION: Clipper reports error here - we can handle this */
           | VarAlias AliasId          { $$ = hb_compExprNewAliasVar( $1, $2, HB_COMP_PARAM ); }
           | FieldAlias AliasId        { $$ = hb_compExprNewAliasVar( $1, $2, HB_COMP_PARAM ); }
           | FieldVarAlias AliasId     { $$ = hb_compExprNewAliasVar( $1, $2, HB_COMP_PARAM ); }
           ;

/* Aliased expressions
 */
/* NOTE: In the case:
 * alias->( Expression )
 * alias always selects a workarea at runtime
 */
AliasExpr  : NumAlias PareExpList         { $$ = hb_compExprNewAliasExpr( $1, $2, HB_COMP_PARAM ); }
           | VarAlias PareExpList         { $$ = hb_compExprNewAliasExpr( $1, $2, HB_COMP_PARAM ); }
           | MacroVarAlias PareExpList    { $$ = hb_compExprNewAliasExpr( $1, $2, HB_COMP_PARAM ); }
           | MacroExprAlias PareExpList   { $$ = hb_compExprNewAliasExpr( $1, $2, HB_COMP_PARAM ); }
           | PareExpListAlias PareExpList { $$ = hb_compExprNewAliasExpr( $1, $2, HB_COMP_PARAM ); }
           | FieldAlias PareExpList       { hb_compExprDelete( $1, HB_COMP_PARAM ); $$ = hb_compErrorAlias( HB_COMP_PARAM, $2 ); } /* QUESTION: Clipper reports error here - we can handle it */
           ;

/* Array expressions access
 */
VariableAt  : NilValue      ArrayIndex    { $$ = $2; }
            | LiteralValue  ArrayIndex    { $$ = $2; }
            | CodeBlock     ArrayIndex    { $$ = $2; }
            | Logical       ArrayIndex    { $$ = $2; }
            | SelfValue     ArrayIndex    { $$ = $2; }
            | Variable      ArrayIndex    { $$ = $2; }
            | AliasVar      ArrayIndex    { $$ = $2; }
            | AliasExpr     ArrayIndex    { $$ = $2; }
            | MacroVar      ArrayIndex    { $$ = $2; }
            | MacroExpr     ArrayIndex    { $$ = $2; }
            | ObjectData    ArrayIndex    { $$ = $2; }
            | ObjectMethod  ArrayIndex    { $$ = $2; }
            | FunCall       ArrayIndex    { $$ = $2; }
            | IfInline      ArrayIndex    { $$ = $2; }
            | PareExpList   ArrayIndex    { $$ = $2; }
            ;

VariableAtAlias : VariableAt ALIASOP      { $$ = $1; }
                ;

/* Function call
 */
FunIdentCall: IdentName '(' {$<bTrue>$=HB_COMP_PARAM->iPassByRef;HB_COMP_PARAM->iPassByRef=HB_PASSBYREF_FUNCALL;} ArgList ')'  { $$ = hb_compExprNewFunCall( hb_compExprNewFunName( $1, HB_COMP_PARAM ), $4, HB_COMP_PARAM ); HB_COMP_PARAM->iPassByRef=$<bTrue>3; }
            ;
           
FunCall    : FunIdentCall  { $$ = $1; }
           | MacroVar '(' {$<bTrue>$=HB_COMP_PARAM->iPassByRef;HB_COMP_PARAM->iPassByRef=HB_PASSBYREF_FUNCALL;} ArgList ')'  { $$ = hb_compExprNewFunCall( $1, $4, HB_COMP_PARAM ); HB_COMP_PARAM->iPassByRef=$<bTrue>3; }
           | MacroExpr '(' {$<bTrue>$=HB_COMP_PARAM->iPassByRef;HB_COMP_PARAM->iPassByRef=HB_PASSBYREF_FUNCALL;} ArgList ')'  { $$ = hb_compExprNewFunCall( $1, $4, HB_COMP_PARAM ); HB_COMP_PARAM->iPassByRef=$<bTrue>3; }
           ;

ArgList    : EmptyExpression                     { $$ = hb_compExprNewArgList( $1, HB_COMP_PARAM ); }
           | ArgList ',' EmptyExpression         { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

FunCallAlias : FunCall ALIASOP        { $$ = $1; }
             ;


/* Object's instance variable
 */
SendId      : IdentName      { $$.value.string = $1; $$.bMacro=FALSE; }
            | MacroVar       { $$.value.macro  = $1; $$.bMacro=TRUE;  }
            | MacroExpr      { $$.value.macro  = $1; $$.bMacro=TRUE;  }
            ;

ObjectData  : NumValue ':' SendId        { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | NilValue ':' SendId        { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | DateValue ':' SendId       { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | LiteralValue ':' SendId    { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | Variable ':' SendId        { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | CodeBlock ':' SendId       { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | Logical ':' SendId         { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | SelfValue ':' SendId       { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | Array ':' SendId           { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | ArrayAt ':' SendId         { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | AliasVar ':' SendId        { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | AliasExpr ':' SendId       { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | MacroVar ':' SendId        { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | MacroExpr ':' SendId       { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | FunCall ':' SendId         { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | IfInline ':' SendId        { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | PareExpList ':' SendId     { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | VariableAt ':' SendId      { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | ObjectMethod ':' SendId    { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | ObjectData ':' SendId      { $$ = ($3.bMacro ? hb_compExprNewSend( $1, NULL, $3.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( $1, $3.value.string, NULL, HB_COMP_PARAM )); }
            | ':' SendId                 { if( HB_COMP_PARAM->wWithObjectCnt == 0 ) 
                                             hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_WITHOBJECT, NULL, NULL );
                                           $$ = ($2.bMacro ? hb_compExprNewSend( NULL, NULL, $2.value.macro, HB_COMP_PARAM ) : hb_compExprNewSend( NULL, $2.value.string, NULL, HB_COMP_PARAM ));
                                         }
            ;

ObjectDataAlias : ObjectData ALIASOP            { $$ = $1; }
                ;

/* Object's method
 */
ObjectMethod : ObjectData '(' {$<bTrue>$=HB_COMP_PARAM->iPassByRef;HB_COMP_PARAM->iPassByRef=HB_PASSBYREF_FUNCALL;} ArgList ')'    { $$ = hb_compExprNewMethodCall( $1, $4 ); HB_COMP_PARAM->iPassByRef=$<bTrue>3; }
             ;

ObjectMethodAlias : ObjectMethod ALIASOP        { $$ = $1; }
                  ;


/* NOTE: We have to distinguish IdentName here because it is repeated
 * in DoArgument (a part of DO <proc> WITH .. statement)
 * where it generates different action.
 */
SimpleExpression :
             NumValue
           | NilValue                         { $$ = $1; }
           | DateValue                        { $$ = $1; }
           | LiteralValue                     { $$ = $1; }
           | CodeBlock                        { $$ = $1; }
           | Logical                          { $$ = $1; }
           | SelfValue                        { $$ = $1; }
           | SelfValue    {HB_COMP_PARAM->cVarType = ' ';} StrongType { $$ = $1; }
           | Array                            { $$ = $1; }
           | ArrayAt                          { $$ = $1; }
           | AliasVar                         { $$ = $1; }
           | MacroVar                         { $$ = $1; }
           | MacroExpr                        { $$ = $1; }
           | VariableAt                       { $$ = $1; }
           | FunCall                          { $$ = $1; }
           | FunCall      {HB_COMP_PARAM->cVarType = ' ';} StrongType { $$ = $1; }
           | IfInline                         { $$ = $1; }
           | ObjectData                       { $$ = $1; }
           | ObjectData   {HB_COMP_PARAM->cVarType = ' ';} StrongType { $$ = $1; }
           | ObjectMethod                     { $$ = $1; }
           | ObjectMethod {HB_COMP_PARAM->cVarType = ' ';} StrongType { $$ = $1; }
           | AliasExpr                        { $$ = $1; }
           | ExprAssign                       { $$ = $1; }
           | ExprOperEq                       { $$ = $1; }
           | ExprPostOp                       { $$ = $1; }
           | ExprPreOp                        { $$ = $1; }
           | ExprUnary                        { $$ = $1; }
           | ExprMath                         { $$ = $1; }
           | ExprBool                         { $$ = $1; }
           | ExprRelation                     { $$ = $1; }
           ;

Expression : Variable         { $$ = $1; }
           | SimpleExpression { $$ = $1; }
           | PareExpList      { $$ = $1; }
           | Variable         { HB_COMP_PARAM->cVarType = ' ';} StrongType { $$ = $1; }
           | PareExpList      { HB_COMP_PARAM->cVarType = ' ';} StrongType { $$ = $1; }
           | '@' IdentName    { $$ = hb_compCheckPassByRef( HB_COMP_PARAM, hb_compExprNewVarRef( $2, HB_COMP_PARAM ) ); }
           | '@' FunIdentCall { int bPassByRef=HB_COMP_PARAM->iPassByRef;HB_COMP_PARAM->iPassByRef=HB_PASSBYREF_FUNCALL;$<string>$ = hb_compExprAsSymbol( $2 ); hb_compExprDelete( $2, HB_COMP_PARAM ); $$ = hb_compCheckPassByRef( HB_COMP_PARAM, hb_compExprNewFunRef( $<string>$, HB_COMP_PARAM ) ); HB_COMP_PARAM->iPassByRef=bPassByRef; }
           | '@' MacroVar     { $$ = hb_compCheckPassByRef( HB_COMP_PARAM, hb_compExprNewRef( $2, HB_COMP_PARAM ) ); }
           | '@' AliasVar     { $$ = hb_compCheckPassByRef( HB_COMP_PARAM, hb_compExprNewRef( $2, HB_COMP_PARAM ) ); }
           | '@' ObjectData   { $$ = hb_compExprNewRef( $2, HB_COMP_PARAM ); }
           ;

EmptyExpression : /* nothing => nil */    { $$ = hb_compExprNewEmpty( HB_COMP_PARAM ); }
                | Expression
                ;

LValue      : IdentName                   { $$ = hb_compExprNewVar( $1, HB_COMP_PARAM ); }
            | AliasVar
            | MacroVar
            | MacroExpr
            | ObjectData
            | VariableAt
            | PareExpList           { $$ = hb_compExprListStrip( $1, NULL ); }
            ;

/* NOTE: PostOp can be used in one context only - it uses $0 rule
 *    (the rule that stands before PostOp)
 */
PostOp      : INC    { $$ = hb_compExprNewPostInc( $<asExpr>0, HB_COMP_PARAM ); }
            | DEC    { $$ = hb_compExprNewPostDec( $<asExpr>0, HB_COMP_PARAM ); }
            ;

/* NOTE: The rule: Expression Operator Expression
 * that can be used standalone as a statement have to be written
 * using all possible left values to resolve shift/reduce conflicts
 */
ExprPostOp  : NumValue     PostOp %prec POST  { $$ = $2; }
            | NilValue     PostOp %prec POST  { $$ = $2; }
            | LiteralValue PostOp %prec POST  { $$ = $2; }
            | CodeBlock    PostOp %prec POST  { $$ = $2; }
            | Logical      PostOp %prec POST  { $$ = $2; }
            | SelfValue    PostOp %prec POST  { $$ = $2; }
            | Array        PostOp %prec POST  { $$ = $2; }
            | ArrayAt      PostOp %prec POST  { $$ = $2; }
            | Variable     PostOp %prec POST  { $$ = $2; }
            | MacroVar     PostOp %prec POST  { $$ = $2; }
            | MacroExpr    PostOp %prec POST  { $$ = $2; }
            | AliasVar     PostOp %prec POST  { $$ = $2; }
            | AliasExpr    PostOp %prec POST  { $$ = $2; }
            | VariableAt   PostOp %prec POST  { $$ = $2; }
            | PareExpList  PostOp %prec POST  { $$ = $2; }
            | IfInline     PostOp %prec POST  { $$ = $2; }
            | FunCall      PostOp %prec POST  { $$ = $2; }
            | ObjectData   PostOp %prec POST  { $$ = $2; }
            | ObjectMethod PostOp %prec POST  { $$ = $2; }
            ;

ExprPreOp   : INC Expression  %prec PRE      { $$ = hb_compExprNewPreInc( $2, HB_COMP_PARAM ); }
            | DEC Expression  %prec PRE      { $$ = hb_compExprNewPreDec( $2, HB_COMP_PARAM ); }
            ;

ExprUnary   : NOT Expression                 { $$ = hb_compExprNewNot( $2, HB_COMP_PARAM ); }
            | '-' Expression  %prec UNARY    { $$ = hb_compExprNewNegate( $2, HB_COMP_PARAM ); }
            | '+' Expression  %prec UNARY    { $$ = $2; }
            ;
/*
ExprAssign  : Expression INASSIGN Expression    { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
;
*/

ExprAssign  : NumValue     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | NilValue     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | LiteralValue INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | CodeBlock    INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | Logical      INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | SelfValue    INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | Array        INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | ArrayAt      INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | Variable     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); HB_COMP_PARAM->cCastType = HB_COMP_PARAM->cVarType; HB_COMP_PARAM->cVarType = ' ';}
            | MacroVar     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | MacroExpr    INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | AliasVar     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | AliasExpr    INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | VariableAt   INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); HB_COMP_PARAM->cCastType = HB_COMP_PARAM->cVarType; HB_COMP_PARAM->cVarType = ' ';}
            | PareExpList  INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | IfInline     INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | FunCall      INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | ObjectData   INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); HB_COMP_PARAM->cCastType = HB_COMP_PARAM->cVarType; HB_COMP_PARAM->cVarType = ' ';}
            | ObjectMethod INASSIGN Expression   { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            ;

ExprEqual   : NumValue     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | NilValue     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | DateValue    '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | LiteralValue '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | CodeBlock    '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | Logical      '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | SelfValue    '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | Array        '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | ArrayAt      '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | Variable     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | MacroVar     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | MacroExpr    '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | AliasVar     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | AliasExpr    '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | VariableAt   '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | PareExpList  '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | IfInline     '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | FunCall      '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | ObjectData   '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            | ObjectMethod '=' Expression %prec INASSIGN  { $$ = hb_compExprAssign( $1, $3, HB_COMP_PARAM ); }
            ;

ExprPlusEq  : NumValue     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | NilValue     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | LiteralValue PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | CodeBlock    PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Logical      PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | SelfValue    PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Array        PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ArrayAt      PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Variable     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroVar     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroExpr    PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasVar     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasExpr    PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | VariableAt   PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | PareExpList  PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | IfInline     PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | FunCall      PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectData   PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectMethod PLUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPlusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            ;

ExprMinusEq : NumValue     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | NilValue     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | LiteralValue MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | CodeBlock    MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Logical      MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | SelfValue    MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Array        MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ArrayAt      MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Variable     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroVar     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroExpr    MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasVar     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasExpr    MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | VariableAt   MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | PareExpList  MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | IfInline     MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | FunCall      MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectData   MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectMethod MINUSEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMinusEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            ;

ExprMultEq  : NumValue     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | NilValue     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | LiteralValue MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | CodeBlock    MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Logical      MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | SelfValue    MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Array        MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ArrayAt      MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Variable     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroVar     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroExpr    MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasVar     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasExpr    MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | VariableAt   MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | PareExpList  MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | IfInline     MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | FunCall      MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectData   MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectMethod MULTEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewMultEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            ;

ExprDivEq   : NumValue     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | NilValue     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | LiteralValue DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | CodeBlock    DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Logical      DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | SelfValue    DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Array        DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ArrayAt      DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Variable     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroVar     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroExpr    DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasVar     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasExpr    DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | VariableAt   DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | PareExpList  DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | IfInline     DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | FunCall      DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectData   DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectMethod DIVEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewDivEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            ;

ExprModEq   : NumValue     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | NilValue     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | LiteralValue MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | CodeBlock    MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Logical      MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | SelfValue    MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Array        MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ArrayAt      MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Variable     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroVar     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroExpr    MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasVar     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasExpr    MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | VariableAt   MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | PareExpList  MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | IfInline     MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | FunCall      MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectData   MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectMethod MODEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewModEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            ;

ExprExpEq   : NumValue     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | NilValue     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | LiteralValue EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | CodeBlock    EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Logical      EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | SelfValue    EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Array        EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ArrayAt      EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Variable     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroVar     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | MacroExpr    EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasVar     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | AliasExpr    EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | VariableAt   EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | PareExpList  EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | IfInline     EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | FunCall      EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectData   EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | ObjectMethod EXPEQ Expression   { $$ = hb_compExprSetOperand( hb_compExprNewExpEq( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            ;

ExprOperEq  : ExprPlusEq        { $$ = $1; }
            | ExprMinusEq       { $$ = $1; }
            | ExprMultEq        { $$ = $1; }
            | ExprDivEq         { $$ = $1; }
            | ExprModEq         { $$ = $1; }
            | ExprExpEq         { $$ = $1; }
            ;

ExprMath    : Expression '+' Expression     { $$ = hb_compExprSetOperand( hb_compExprNewPlus( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression '-' Expression     { $$ = hb_compExprSetOperand( hb_compExprNewMinus( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression '*' Expression     { $$ = hb_compExprSetOperand( hb_compExprNewMult( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression '/' Expression     { $$ = hb_compExprSetOperand( hb_compExprNewDiv( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression '%' Expression     { $$ = hb_compExprSetOperand( hb_compExprNewMod( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression POWER Expression   { $$ = hb_compExprSetOperand( hb_compExprNewPower( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            ;

ExprBool    : Expression AND Expression   { $$ = hb_compExprSetOperand( hb_compExprNewAnd( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression OR  Expression   { $$ = hb_compExprSetOperand( hb_compExprNewOr( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            ;

ExprRelation: Expression EQ  Expression   { $$ = hb_compExprSetOperand( hb_compExprNewEQ( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression '<' Expression   { $$ = hb_compExprSetOperand( hb_compExprNewLT( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression '>' Expression   { $$ = hb_compExprSetOperand( hb_compExprNewGT( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression LE  Expression   { $$ = hb_compExprSetOperand( hb_compExprNewLE( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression GE  Expression   { $$ = hb_compExprSetOperand( hb_compExprNewGE( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression NE1 Expression   { $$ = hb_compExprSetOperand( hb_compExprNewNE( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression NE2 Expression   { $$ = hb_compExprSetOperand( hb_compExprNewNE( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression '$' Expression   { $$ = hb_compExprSetOperand( hb_compExprNewIN( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            | Expression '=' Expression   { $$ = hb_compExprSetOperand( hb_compExprNewEqual( $1, HB_COMP_PARAM ), $3, HB_COMP_PARAM ); }
            ;

ArrayIndex : IndexList ']'                   { $$ = $1; }
           ;

/* NOTE: $0 represents the expression before ArrayIndex
 *    Don't use ArrayIndex in other context than as an array index!
 */
IndexList  : '[' Expression               { $$ = hb_compExprNewArrayAt( $<asExpr>0, $2, HB_COMP_PARAM ); }
           | IndexList ',' Expression     { $$ = hb_compExprNewArrayAt( $1, $3, HB_COMP_PARAM ); }
           | IndexList ']' '[' Expression { $$ = hb_compExprNewArrayAt( $1, $4, HB_COMP_PARAM ); }
           ;

ElemList   : EmptyExpression                { $$ = hb_compExprNewList( $1, HB_COMP_PARAM ); }
           | ElemList ',' EmptyExpression   { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

CodeBlock  : CBSTART { $<asExpr>$ = hb_compExprNewCodeBlock( $1.string, $1.isMacro, $1.lateEval, HB_COMP_PARAM ); } BlockNoVar
             '|' BlockExpList '}'   { $$ = $<asExpr>2; }
           | CBSTART { $<asExpr>$ = hb_compExprNewCodeBlock( $1.string, $1.isMacro, $1.lateEval, HB_COMP_PARAM ); } BlockVarList
             '|' BlockExpList '}'   { $$ = $<asExpr>2; }
           ;

/* NOTE: This uses $-2 then don't use BlockExpList in other context
 */
BlockExpList : Expression                    { $$ = hb_compExprAddCodeblockExpr( $<asExpr>-2, $1 ); }
             | BlockExpList ',' Expression   { $$ = hb_compExprAddCodeblockExpr( $<asExpr>-2, $3 ); }
             ;

/* NOTE: This is really not needed however it allows the use of $-2 item
 * in BlockExpList to refer the same rule defined in Codeblock
 */
BlockNoVar : /* empty list */    { $$ = NULL; }
           ;

BlockVarList : IdentName AsType                 { HB_COMP_PARAM->iVarScope = VS_LOCAL; $$ = hb_compExprCBVarAdd( $<asExpr>0, $1, HB_COMP_PARAM->cVarType, HB_COMP_PARAM ); HB_COMP_PARAM->cVarType = ' '; }
           | BlockVarList ',' IdentName AsType  { HB_COMP_PARAM->iVarScope = VS_LOCAL; $$ = hb_compExprCBVarAdd( $<asExpr>0, $3, HB_COMP_PARAM->cVarType, HB_COMP_PARAM ); HB_COMP_PARAM->cVarType = ' '; }
           ;

/* There is a conflict between the use of IF( Expr1, Expr2, Expr3 )
 * and parenthesized expression ( Expr1, Expr2, Expr3 )
 * To solve this conflict we have to split the definitions into more
 * atomic ones.
 *   Also the generation of pcodes have to be delayed and moved to the
 * end of whole parenthesized expression.
 */
PareExpList1: ExpList1 ')'        { $$ = $1; }
            ;

PareExpList2: ExpList2 ')'        { $$ = $1; }
            ;

PareExpList3: ExpList3 ')'        { $$ = $1; }
            ;

PareExpListN: ExpList ')'         { $$ = $1; }
            ;

PareExpList : PareExpList1        { $$ = $1; }
            | PareExpList2        { $$ = $1; }
            | PareExpList3        { $$ = $1; }
            | PareExpListN        { $$ = $1; }
            ;

PareExpListAlias : PareExpList ALIASOP     { $$ = $1; }
                 ;

ExpList1   : '(' EmptyExpression             { $$ = hb_compExprNewList( $2, HB_COMP_PARAM ); }
           ;

ExpList2   : ExpList1 ',' EmptyExpression    { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

ExpList3   : ExpList2 ',' EmptyExpression    { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

ExpList    : ExpList3 ',' EmptyExpression    { $$ = hb_compExprAddListExpr( $1, $3 ); }
           | ExpList  ',' EmptyExpression    { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

IfInline   : IIF PareExpList3         { $$ = hb_compExprNewIIF( $2, HB_COMP_PARAM ); }
           | IF  ExpList1 ',' EmptyExpression ','
             { $<asExpr>$ = hb_compExprAddListExpr( $2, $4 ); }
             EmptyExpression ')'
             { $$ = hb_compExprNewIIF( hb_compExprAddListExpr( $<asExpr>6, $7 ), HB_COMP_PARAM ); }
           ;

IfInlineAlias : IfInline ALIASOP      { $$ = $1; }
              ;

VarDefs    : LOCAL { HB_COMP_PARAM->iVarScope = VS_LOCAL; hb_compLinePush( HB_COMP_PARAM ); } VarList Crlf { HB_COMP_PARAM->cVarType = ' '; }
           | STATIC { HB_COMP_PARAM->iVarScope = VS_STATIC; hb_compLinePush( HB_COMP_PARAM ); } VarList Crlf { HB_COMP_PARAM->cVarType = ' '; }
           | PARAMETERS { if( HB_COMP_PARAM->functions.pLast->bFlags & FUN_USES_LOCAL_PARAMS )
                             hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_PARAMETERS_NOT_ALLOWED, NULL, NULL );
                          else
                             HB_COMP_PARAM->functions.pLast->wParamNum=0; HB_COMP_PARAM->iVarScope = ( VS_PRIVATE | VS_PARAMETER ); }
                             MemvarList Crlf { HB_COMP_PARAM->iVarScope = VS_NONE; }
           ;

VarList    : VarDef                                  { $$ = 1; }
           | VarList ',' VarDef                      { $$++; }
           ;

ExtVarList : ExtVarDef                               { $$ = 1; }
           | ExtVarList ',' ExtVarDef                { $$++; }
           ;

/* NOTE: if STATIC or LOCAL variables are declared and initialized then we can
 * assign a value immediately - however for PRIVATE and PUBLIC variables
 * initialization have to be delayed because we have to create these variables
 * first.
 */
ExtVarDef  : VarDef
           | MacroVar AsType
               { hb_compRTVariableAdd( HB_COMP_PARAM, hb_compExprNewRTVar( NULL, $1, HB_COMP_PARAM ), FALSE ); }
           | MacroVar AsType INASSIGN Expression
               { hb_compExprDelete( hb_compExprGenPush( $4, HB_COMP_PARAM ), HB_COMP_PARAM );
                 hb_compRTVariableAdd( HB_COMP_PARAM, hb_compExprNewRTVar( NULL, $1, HB_COMP_PARAM ), TRUE );
               }
           | MacroVar DimList
               {
                  USHORT uCount = (USHORT) hb_compExprListLen( $2 );
                  hb_compExprDelete( hb_compExprGenPush( $2, HB_COMP_PARAM ), HB_COMP_PARAM );
                  hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), HB_COMP_PARAM );
                  hb_compRTVariableAdd( HB_COMP_PARAM, hb_compExprNewRTVar( NULL, $1, HB_COMP_PARAM ), TRUE );
               }
           | MacroVar DimList AsArray
               {
                  USHORT uCount = (USHORT) hb_compExprListLen( $2 );
                  hb_compExprDelete( hb_compExprGenPush( $2, HB_COMP_PARAM ), HB_COMP_PARAM );
                  hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), HB_COMP_PARAM );
                  hb_compRTVariableAdd( HB_COMP_PARAM, hb_compExprNewRTVar( NULL, $1, HB_COMP_PARAM ), TRUE );
               }
           ;

VarDef     : IdentName AsType { hb_compVariableAdd( HB_COMP_PARAM, $1, HB_COMP_PARAM->cVarType ); }
               {
                  if( HB_COMP_PARAM->iVarScope == VS_STATIC )
                  {
                     hb_compStaticDefStart( HB_COMP_PARAM );   /* switch to statics pcode buffer */
                     hb_compStaticDefEnd( HB_COMP_PARAM );
                     hb_compGenStaticName( $1, HB_COMP_PARAM );
                  }
                  else if( HB_COMP_PARAM->iVarScope == VS_PUBLIC || HB_COMP_PARAM->iVarScope == VS_PRIVATE )
                  {
                     hb_compRTVariableAdd( HB_COMP_PARAM, hb_compExprNewRTVar( $1, NULL, HB_COMP_PARAM ), FALSE );
                  }
               }

           | IdentName AsType { $<iNumber>$ = HB_COMP_PARAM->iVarScope;
                                hb_compVariableAdd( HB_COMP_PARAM, $1, HB_COMP_PARAM->cVarType );
                              }
             INASSIGN {HB_COMP_PARAM->cVarType = ' ';} Expression
               {
                  HB_COMP_PARAM->cCastType = HB_COMP_PARAM->cVarType;
                  HB_COMP_PARAM->cVarType = ' ';

                  HB_COMP_PARAM->iVarScope = $<iNumber>3;
                  if( HB_COMP_PARAM->iVarScope == VS_STATIC )
                  {
                     hb_compStaticDefStart( HB_COMP_PARAM );   /* switch to statics pcode buffer */
                     hb_compExprDelete( hb_compExprGenStatement( hb_compExprAssignStatic( hb_compExprNewVar( $1, HB_COMP_PARAM ), $6, HB_COMP_PARAM ), HB_COMP_PARAM ), HB_COMP_PARAM );
                     hb_compStaticDefEnd( HB_COMP_PARAM );
                     hb_compGenStaticName( $1, HB_COMP_PARAM );
                  }
                  else if( HB_COMP_PARAM->iVarScope == VS_PUBLIC || HB_COMP_PARAM->iVarScope == VS_PRIVATE )
                  {
                     hb_compExprDelete( hb_compExprGenPush( $6, HB_COMP_PARAM ), HB_COMP_PARAM );
                     hb_compRTVariableAdd( HB_COMP_PARAM, hb_compExprNewRTVar( $1, NULL, HB_COMP_PARAM ), TRUE );
                  }
                  else
                  {
                     hb_compExprDelete( hb_compExprGenStatement( hb_compExprAssign( hb_compExprNewVar( $1, HB_COMP_PARAM ), $6, HB_COMP_PARAM ), HB_COMP_PARAM ), HB_COMP_PARAM );
                  }
                  HB_COMP_PARAM->iVarScope = $<iNumber>3;
               }

           | IdentName DimList          { hb_compVariableDim( $1, $2, HB_COMP_PARAM ); }
           | IdentName DimList AsArray  { hb_compVariableDim( $1, $2, HB_COMP_PARAM ); }
           ;

/* NOTE: DimList and DimIndex is the same as ArrayIndex and IndexList
 *       however we are using quite different actions here
 */
DimList    : DimIndex ']'                   { $$ = $1; }
           ;

DimIndex   : '[' Expression               { $$ = hb_compExprNewArgList( $2, HB_COMP_PARAM ); }
           | DimIndex ',' Expression      { $$ = hb_compExprAddListExpr( $1, $3 ); }
           | DimIndex ']' '[' Expression  { $$ = hb_compExprAddListExpr( $1, $4 ); }
           ;


FieldsDef  : FIELD { HB_COMP_PARAM->iVarScope = VS_FIELD; } FieldList Crlf { HB_COMP_PARAM->cVarType = ' '; }
           ;

FieldList  : IdentName AsType               { $$=hb_compFieldsCount( HB_COMP_PARAM ); hb_compVariableAdd( HB_COMP_PARAM, $1, HB_COMP_PARAM->cVarType ); }
           | FieldList ',' IdentName AsType { hb_compVariableAdd( HB_COMP_PARAM, $3, HB_COMP_PARAM->cVarType ); }
           | FieldList IN IdentName { hb_compFieldSetAlias( HB_COMP_PARAM, $3, $<iNumber>1 ); }
           ;

MemvarDef  : MEMVAR { HB_COMP_PARAM->iVarScope = VS_MEMVAR; } MemvarList Crlf { HB_COMP_PARAM->cVarType = ' '; }
           ;

MemvarList : IdentName AsType                     { hb_compVariableAdd( HB_COMP_PARAM, $1, HB_COMP_PARAM->cVarType ); }
           | MemvarList ',' IdentName AsType      { hb_compVariableAdd( HB_COMP_PARAM, $3, HB_COMP_PARAM->cVarType ); }
           ;

Declaration: DECLARE IdentName '(' { hb_compDeclaredAdd( HB_COMP_PARAM, $2 ); HB_COMP_PARAM->szDeclaredFun = $2; } DecList ')' AsType Crlf
             {
               if( HB_COMP_PARAM->pLastDeclared )
               {
                 HB_COMP_PARAM->pLastDeclared->cType = HB_COMP_PARAM->cVarType;

                 if ( toupper( HB_COMP_PARAM->cVarType ) == 'S' )
                 {
                   HB_COMP_PARAM->pLastDeclared->pClass = hb_compClassFind( HB_COMP_PARAM, HB_COMP_PARAM->szFromClass );
                   if( ! HB_COMP_PARAM->pLastDeclared->pClass )
                   {
                     hb_compGenWarning( HB_COMP_PARAM, hb_comp_szWarnings, 'W', HB_COMP_WARN_CLASS_NOT_FOUND, HB_COMP_PARAM->szFromClass, HB_COMP_PARAM->pLastDeclared->szName );
                     HB_COMP_PARAM->pLastDeclared->cType = ( isupper(  ( int ) HB_COMP_PARAM->cVarType ) ? 'O' : 'o' );
                   }

                   /* Resetting */
                   HB_COMP_PARAM->szFromClass = NULL;
                 }
               }
               HB_COMP_PARAM->szDeclaredFun = NULL;
               HB_COMP_PARAM->cVarType = ' ';
               HB_COMP_PARAM->iVarScope = VS_NONE;
             }
           | DECLARE IdentName { HB_COMP_PARAM->pLastClass = hb_compClassAdd( HB_COMP_PARAM, $2 ); } ClassInfo Crlf { HB_COMP_PARAM->iVarScope = VS_NONE; }
           | DECLARE_CLASS IdentName Crlf { HB_COMP_PARAM->pLastClass = hb_compClassAdd( HB_COMP_PARAM, $2 ); HB_COMP_PARAM->iVarScope = VS_NONE; }
           | DECLARE_MEMBER DecMethod Crlf { HB_COMP_PARAM->iVarScope = VS_NONE; }
           | DECLARE_MEMBER '{' AsType { HB_COMP_PARAM->cDataListType = HB_COMP_PARAM->cVarType; } DecDataList '}' Crlf { HB_COMP_PARAM->cDataListType = 0; HB_COMP_PARAM->iVarScope = VS_NONE; }
           ;

DecDataList: DecData
           | DecDataList ',' DecData
           ;

ClassInfo  : DecMethod
           | ClassInfo DecMethod
           | DecData
           | ClassInfo DecData
           ;

DecMethod  : IdentName '(' { HB_COMP_PARAM->pLastMethod = hb_compMethodAdd( HB_COMP_PARAM, HB_COMP_PARAM->pLastClass, $1 ); } DecList ')' AsType
             {
               if( HB_COMP_PARAM->pLastMethod )
               {
                 HB_COMP_PARAM->pLastMethod->cType = HB_COMP_PARAM->cVarType;
                 if ( toupper( HB_COMP_PARAM->cVarType ) == 'S' )
                 {
                   HB_COMP_PARAM->pLastMethod->pClass = hb_compClassFind( HB_COMP_PARAM, HB_COMP_PARAM->szFromClass );
                   if( ! HB_COMP_PARAM->pLastMethod->pClass )
                   {
                     hb_compGenWarning( HB_COMP_PARAM, hb_comp_szWarnings, 'W', HB_COMP_WARN_CLASS_NOT_FOUND, HB_COMP_PARAM->szFromClass, HB_COMP_PARAM->pLastMethod->szName );
                     HB_COMP_PARAM->pLastMethod->cType = ( isupper(  ( int ) HB_COMP_PARAM->cVarType ) ? 'O' : 'o' );
                   }

                   HB_COMP_PARAM->szFromClass = NULL;
                 }
               }
               HB_COMP_PARAM->pLastMethod = NULL;
               HB_COMP_PARAM->cVarType = ' ';
             }
           ;

DecData    : IdentName { HB_COMP_PARAM->pLastMethod = hb_compMethodAdd( HB_COMP_PARAM, HB_COMP_PARAM->pLastClass, $1 ); } AsType
             {
               if( HB_COMP_PARAM->pLastMethod )
               {
                 PCOMCLASS pClass;
                 char * szSetData = ( char * ) hb_xgrab( strlen( $1 ) + 2 );

                 /* List Type overrides if exists. */
                 if( HB_COMP_PARAM->cDataListType ) HB_COMP_PARAM->cVarType = HB_COMP_PARAM->cDataListType;

                 HB_COMP_PARAM->pLastMethod->cType = HB_COMP_PARAM->cVarType;
                 if ( toupper( HB_COMP_PARAM->cVarType ) == 'S' )
                 {
                   pClass = hb_compClassFind( HB_COMP_PARAM, HB_COMP_PARAM->szFromClass );
                   HB_COMP_PARAM->pLastMethod->pClass = pClass;
                   if( ! HB_COMP_PARAM->pLastMethod->pClass )
                   {
                     hb_compGenWarning( HB_COMP_PARAM, hb_comp_szWarnings, 'W', HB_COMP_WARN_CLASS_NOT_FOUND, HB_COMP_PARAM->szFromClass, HB_COMP_PARAM->pLastMethod->szName );
                     HB_COMP_PARAM->pLastMethod->cType = ( isupper(  ( int ) HB_COMP_PARAM->cVarType ) ? 'O' :'o' );
                   }
                 }
                 else
                   pClass = NULL;

                 sprintf( szSetData, "_%s", $1 );

                 HB_COMP_PARAM->pLastMethod = hb_compMethodAdd( HB_COMP_PARAM, HB_COMP_PARAM->pLastClass, szSetData );
                 HB_COMP_PARAM->pLastMethod->cType = HB_COMP_PARAM->cVarType;
                 HB_COMP_PARAM->pLastMethod->iParamCount = 1;

                 HB_COMP_PARAM->pLastMethod->cParamTypes = ( BYTE * ) hb_xgrab( 1 );
                 HB_COMP_PARAM->pLastMethod->cParamTypes[0] = HB_COMP_PARAM->cVarType;

                 HB_COMP_PARAM->pLastMethod->pParamClasses = ( PCOMCLASS * ) hb_xgrab( sizeof( COMCLASS ) );
                 HB_COMP_PARAM->pLastMethod->pParamClasses[0] = pClass;

                 if ( toupper( HB_COMP_PARAM->cVarType ) == 'S' )
                 {
                   HB_COMP_PARAM->pLastMethod->pClass = pClass;
                   HB_COMP_PARAM->szFromClass = NULL;
                 }
               }

               HB_COMP_PARAM->pLastMethod = NULL;
               HB_COMP_PARAM->cVarType = ' ';
             }
           ;

DecList    : /* Nothing */ {}
           | FormalList
           | OptList
           | FormalList ',' OptList
           ;

DummyArgList : DummyArgument                    {}
             | DummyArgList ',' DummyArgument   {}
             ;

DummyArgument : EmptyExpression                 {}
              ;
/*              
              | '@' IdentName                      {}
              | '@' IdentName '(' DummyArgList ')' {}
*/
FormalList : IdentName AsType                                  { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $1, HB_COMP_PARAM->cVarType ); }
           | '@' IdentName AsType                              { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $2, HB_COMP_PARAM->cVarType + VT_OFFSET_BYREF ); }
           | '@' IdentName '(' DummyArgList ')'                { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $2, 'F' );  hb_compExprDelete( $<asExpr>4, HB_COMP_PARAM );}
           | FormalList ',' IdentName AsType                   { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $3, HB_COMP_PARAM->cVarType ); }
           | FormalList ',' '@' IdentName AsType               { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $4, HB_COMP_PARAM->cVarType + VT_OFFSET_BYREF ); }
           | FormalList ',' '@' IdentName '(' DummyArgList ')' { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $4, 'F' ); hb_compExprDelete( $<asExpr>6, HB_COMP_PARAM ); }
           ;

OptList    : OPTIONAL IdentName AsType                               { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $2, HB_COMP_PARAM->cVarType + VT_OFFSET_OPTIONAL ); }
           | OPTIONAL '@' IdentName AsType                           { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $3, HB_COMP_PARAM->cVarType + VT_OFFSET_OPTIONAL + VT_OFFSET_BYREF ); }
           | OPTIONAL '@' IdentName '(' DummyArgList ')'             { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $3, HB_COMP_PARAM->cVarType + VT_OFFSET_OPTIONAL + VT_OFFSET_BYREF ); }
           | OptList ',' OPTIONAL IdentName AsType                   { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $4, HB_COMP_PARAM->cVarType + VT_OFFSET_OPTIONAL ); }
           | OptList ',' OPTIONAL '@' IdentName AsType               { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $5, HB_COMP_PARAM->cVarType + VT_OFFSET_OPTIONAL + VT_OFFSET_BYREF ); }
           | OptList ',' OPTIONAL '@' IdentName '(' DummyArgList ')' { hb_compDeclaredParameterAdd( HB_COMP_PARAM, $5, HB_COMP_PARAM->cVarType + VT_OFFSET_OPTIONAL + VT_OFFSET_BYREF ); }
           ;

ExecFlow   : IfEndif
           | DoCase
           | DoWhile
           | ForNext
           | BeginSeq
           | ForEach
           | DoSwitch
           ;

IfEndif    : IfBegin EndIf                    { hb_compGenJumpHere( $1, HB_COMP_PARAM ); }
           | IfBegin IfElse EndIf             { hb_compGenJumpHere( $1, HB_COMP_PARAM ); }
           | IfBegin IfElseIf EndIf           { hb_compGenJumpHere( $1, HB_COMP_PARAM ); hb_compElseIfFix( HB_COMP_PARAM, $2 ); }
           | IfBegin IfElseIf IfElse EndIf    { hb_compGenJumpHere( $1, HB_COMP_PARAM ); hb_compElseIfFix( HB_COMP_PARAM, $2 ); }
           ;

EmptyStatements : LineStat             { $<lNumber>$ = $<lNumber>1; }
           | EmptyStatements LineStat  { $<lNumber>$ += $<lNumber>2; }
           ;

EmptyStats : /* empty */           { $<lNumber>$ = 0; }
           | EmptyStatements       { $<lNumber>$ = $<lNumber>1; }
           ;

IfBegin    : IF SimpleExpression { ++HB_COMP_PARAM->wIfCounter; hb_compLinePush( HB_COMP_PARAM ); } Crlf { hb_compExprDelete( hb_compExprGenPush( $2, HB_COMP_PARAM ), HB_COMP_PARAM ); $$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM ); }
                EmptyStats
                { $$ = hb_compGenJump( 0, HB_COMP_PARAM ); hb_compGenJumpHere( $<iNumber>5, HB_COMP_PARAM ); }

           | IF Variable { ++HB_COMP_PARAM->wIfCounter; hb_compLinePush( HB_COMP_PARAM ); } Crlf { hb_compExprDelete( hb_compExprGenPush( $2, HB_COMP_PARAM ), HB_COMP_PARAM ); $$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM ); }
                EmptyStats
                { $$ = hb_compGenJump( 0, HB_COMP_PARAM ); hb_compGenJumpHere( $<iNumber>5, HB_COMP_PARAM ); }

           | IF PareExpList1 { ++HB_COMP_PARAM->wIfCounter; hb_compLinePush( HB_COMP_PARAM ); } Crlf { hb_compExprDelete( hb_compExprGenPush( $2, HB_COMP_PARAM ), HB_COMP_PARAM ); $$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM ); }
                EmptyStats
                { $$ = hb_compGenJump( 0, HB_COMP_PARAM ); hb_compGenJumpHere( $<iNumber>5, HB_COMP_PARAM ); }

           | IF PareExpList2 { ++HB_COMP_PARAM->wIfCounter; hb_compLinePush( HB_COMP_PARAM ); } Crlf { hb_compExprDelete( hb_compExprGenPush( $2, HB_COMP_PARAM ), HB_COMP_PARAM ); $$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM ); }
                EmptyStats
                { $$ = hb_compGenJump( 0, HB_COMP_PARAM ); hb_compGenJumpHere( $<iNumber>5, HB_COMP_PARAM ); }

           | IF PareExpListN { ++HB_COMP_PARAM->wIfCounter; hb_compLinePush( HB_COMP_PARAM ); } Crlf { hb_compExprDelete( hb_compExprGenPush( $2, HB_COMP_PARAM ), HB_COMP_PARAM ); $$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM ); }
                EmptyStats
                { $$ = hb_compGenJump( 0, HB_COMP_PARAM ); hb_compGenJumpHere( $<iNumber>5, HB_COMP_PARAM ); }
           ;

IfElse     : ELSE Crlf { HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE; }
                EmptyStats
           ;

IfElseIf   : ELSEIF { HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE; hb_compLinePush( HB_COMP_PARAM ); } 
                Expression Crlf
                { hb_compExprDelete( hb_compExprGenPush( $3, HB_COMP_PARAM ), HB_COMP_PARAM );
                  $<iNumber>$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM );
                }
                EmptyStats
                { $$ = hb_compElseIfGen( HB_COMP_PARAM, NULL, hb_compGenJump( 0, HB_COMP_PARAM ) );
                  hb_compGenJumpHere( $<iNumber>5, HB_COMP_PARAM );
                }

           | IfElseIf ELSEIF { HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE; hb_compLinePush( HB_COMP_PARAM ); } 
                Expression Crlf
                { hb_compExprDelete( hb_compExprGenPush( $4, HB_COMP_PARAM ), HB_COMP_PARAM );
                  $<iNumber>$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM );
                }
                EmptyStats
                { $$ = hb_compElseIfGen( HB_COMP_PARAM, $1, hb_compGenJump( 0, HB_COMP_PARAM ) );
                  hb_compGenJumpHere( $<iNumber>6, HB_COMP_PARAM );
                }
           ;

EndIf      : ENDIF    { --HB_COMP_PARAM->wIfCounter; HB_COMP_PARAM->functions.pLast->bFlags &= ~ ( /*FUN_WITH_RETURN |*/ FUN_BREAK_CODE ); }
           | END      { --HB_COMP_PARAM->wIfCounter; HB_COMP_PARAM->functions.pLast->bFlags &= ~ ( /*FUN_WITH_RETURN |*/ FUN_BREAK_CODE ); }
           ;

DoCase     : DoCaseBegin
                Cases
             EndCase                  { hb_compElseIfFix( HB_COMP_PARAM, $2 ); }

           | DoCaseBegin
                Otherwise
             EndCase

           | DoCaseBegin
             EndCase

           | DoCaseBegin
                Cases
                Otherwise
             EndCase                   { hb_compElseIfFix( HB_COMP_PARAM, $2 ); }
           ;

EndCase    : ENDCASE
               { --HB_COMP_PARAM->wCaseCounter;
                  HB_COMP_PARAM->functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE );
                }
           | END
               { --HB_COMP_PARAM->wCaseCounter;
                  HB_COMP_PARAM->functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE );
               }
           ;

DoCaseStart : DOCASE { ++HB_COMP_PARAM->wCaseCounter; hb_compLinePushIfDebugger( HB_COMP_PARAM );} Crlf
            ;

DoCaseBegin : DoCaseStart            { }
            | DoCaseStart Statements {
                        if( $<lNumber>2 > 0 )
                        {
                           hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_MAYHEM_IN_CASE, NULL, NULL );
                        }
                     }
           ;

Cases      : CASE { hb_compLinePush( HB_COMP_PARAM ); } Expression Crlf
               {
                  hb_compExprDelete( hb_compExprGenPush( $3, HB_COMP_PARAM ), HB_COMP_PARAM );
                  $<iNumber>$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM );
               }
             EmptyStats
               {
                  HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $$ = hb_compElseIfGen( HB_COMP_PARAM, NULL, hb_compGenJump( 0, HB_COMP_PARAM ) );
                  hb_compGenJumpHere( $<iNumber>5, HB_COMP_PARAM );
               }

           | Cases CASE { hb_compLinePush( HB_COMP_PARAM ); } Expression Crlf
               {
                  hb_compExprDelete( hb_compExprGenPush( $4, HB_COMP_PARAM ), HB_COMP_PARAM );
                  $<iNumber>$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM );
               }
             EmptyStats
               {
                  HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $$ = hb_compElseIfGen( HB_COMP_PARAM, $1, hb_compGenJump( 0, HB_COMP_PARAM ) );
                  hb_compGenJumpHere( $<iNumber>6, HB_COMP_PARAM );
               }
           ;

Otherwise  : OTHERWISE {hb_compLinePushIfDebugger( HB_COMP_PARAM ); } Crlf { HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE; }
                EmptyStats
           | Otherwise OTHERWISE { hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_MAYHEM_IN_CASE, NULL, NULL ); } Crlf
                EmptyStats
           ;

DoWhile    : WhileBegin Expression Crlf
               {
                  hb_compExprDelete( hb_compExprGenPush( $2, HB_COMP_PARAM ), HB_COMP_PARAM );
                  $<lNumber>$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM );
                }
             EmptyStats
               {
                  hb_compLoopHere( HB_COMP_PARAM );
                  hb_compGenJump( $1 - HB_COMP_PARAM->functions.pLast->lPCodePos, HB_COMP_PARAM );
               }
             EndWhile
               {
                  hb_compGenJumpHere( $<lNumber>4, HB_COMP_PARAM ); --HB_COMP_PARAM->wWhileCounter;
                  hb_compLoopEnd( HB_COMP_PARAM );
                  HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
                }
           ;

WhileBegin : WHILE    { $$ = HB_COMP_PARAM->functions.pLast->lPCodePos; hb_compLinePushIfInside( HB_COMP_PARAM ); ++HB_COMP_PARAM->wWhileCounter; hb_compLoopStart( HB_COMP_PARAM ); }
           ;

EndWhile   : END   { HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE; }
           | ENDDO { HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE; }
           ;

ForNext    : FOR LValue ForAssign Expression          /* 1  2  3  4 */
               {
                  hb_compLinePush( HB_COMP_PARAM );
                  hb_compDebugStart();
                  ++HB_COMP_PARAM->wForCounter;              /* 5 */
                  $<asExpr>$ = hb_compExprGenStatement( hb_compExprAssign( $2, $4, HB_COMP_PARAM ), HB_COMP_PARAM );
                  if( hb_compExprAsSymbol($<asExpr>2) )
                  {
                     hb_compForStart( HB_COMP_PARAM, hb_compExprAsSymbol($<asExpr>2), FALSE );
                  }
               }
             TO Expression StepExpr                   /* 6  7  8 */
               {
                  hb_compLoopStart( HB_COMP_PARAM );
                  $<lNumber>$ = hb_compGenJump( 0, HB_COMP_PARAM );  /* 9 */
               }
             Crlf                                     /* 10 */
               {
                  $<lNumber>$ = HB_COMP_PARAM->functions.pLast->lPCodePos;  /* 11 */
               }
             ForStatements                            /* 12 */
               {
                  short iStep, iLocal;

                  hb_compLoopHere( HB_COMP_PARAM );

                  if( $<asExpr>8 )
                  {
                     if( hb_compExprIsInteger($<asExpr>8) )
                        iStep = hb_compExprAsInteger($<asExpr>8);
                     else
                        iStep = 0;
                  }
                  else
                  {
                     iStep = 1;
                  }

                  if( iStep && ( iLocal = hb_compLocalGetPos( HB_COMP_PARAM, hb_compExprAsSymbol($<asExpr>2) ) ) > 0 && iLocal < 256 )
                  {
                     hb_compGenPCode4( HB_P_LOCALNEARADDINT, ( BYTE ) iLocal, HB_LOBYTE( iStep ), HB_HIBYTE( iStep ), HB_COMP_PARAM );
                  }
                  else if( $<asExpr>8 )
                  {
                     hb_compExprClear( hb_compExprGenStatement( hb_compExprSetOperand( hb_compExprNewPlusEq( $2, HB_COMP_PARAM ), $<asExpr>8, HB_COMP_PARAM ), HB_COMP_PARAM ) );
                  }
                  else
                  {
                     hb_compExprClear( hb_compExprGenStatement( hb_compExprNewPreInc( $2, HB_COMP_PARAM ), HB_COMP_PARAM ) );
                  }

                  hb_compGenJumpHere( $<lNumber>9, HB_COMP_PARAM );

                  hb_compExprGenPush( $2, HB_COMP_PARAM );              /* counter */
                  hb_compExprGenPush( $7, HB_COMP_PARAM );              /* end */
                  if( $<asExpr>8 )
                  {
                     hb_compExprGenPush( $<asExpr>8, HB_COMP_PARAM );   /* step */
                     hb_compGenPCode1( HB_P_FORTEST, HB_COMP_PARAM );
                  }
                  else
                     hb_compGenPCode1( HB_P_GREATER, HB_COMP_PARAM );

                  hb_compGenJumpFalse( $<lNumber>11 - HB_COMP_PARAM->functions.pLast->lPCodePos, HB_COMP_PARAM );
                  hb_compLoopEnd( HB_COMP_PARAM );
                  if( hb_compExprAsSymbol($<asExpr>2) )
                  {
                     hb_compForEnd( HB_COMP_PARAM, hb_compExprAsSymbol($<asExpr>2) );
                  }
                  hb_compExprDelete( $7, HB_COMP_PARAM );
                  hb_compExprDelete( $<asExpr>5, HB_COMP_PARAM ); /* deletes $5, $2, $4 */
                  if( $<asExpr>8 )
                     hb_compExprDelete( $<asExpr>8, HB_COMP_PARAM );
                  HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
               }
           ;

ForAssign  : '='
           | INASSIGN
           ;

StepExpr   : /* default step expression */       { $<asExpr>$ = NULL; }
           | STEP Expression                     { $<asExpr>$ = hb_compExprReduce( $2, HB_COMP_PARAM ); }
           ;

ForStatements : EmptyStats NEXT                     { hb_compLinePush( HB_COMP_PARAM ); --HB_COMP_PARAM->wForCounter; }
           | EmptyStats NEXT IdentName              { hb_compLinePush( HB_COMP_PARAM ); --HB_COMP_PARAM->wForCounter; }
           | EmptyStats END                         { hb_compLinePush( HB_COMP_PARAM ); --HB_COMP_PARAM->wForCounter; }
           | EmptyStats END IdentName               { hb_compLinePush( HB_COMP_PARAM ); --HB_COMP_PARAM->wForCounter; }
           ;

ForVar     : IdentName     { $$ = hb_compExprNewVarRef( $1, HB_COMP_PARAM ); }
           | AliasVar      { $$ = hb_compExprNewRef( $1, HB_COMP_PARAM ); }
           ;
           
ForList    : ForVar                { $$ = hb_compExprNewArgList( $1, HB_COMP_PARAM ); }
           | ForList ',' ForVar    { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

ForExpr    : Expression              { $$ = hb_compExprNewArgList( $1, HB_COMP_PARAM ); }
           | ForExpr ',' Expression  { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;           
           
ForEach    : FOREACH ForList IN ForExpr          /* 1  2  3  4 */
             {
                ++HB_COMP_PARAM->wForCounter;              /* 5 */
                hb_compLinePush( HB_COMP_PARAM );
                hb_compDebugStart();
             }
             Descend    /* 6 */
             {
                /* 7
                */
                hb_compEnumStart( HB_COMP_PARAM, $2, $4, $6 );
                
                hb_compLoopStart( HB_COMP_PARAM );
                $<lNumber>$ = HB_COMP_PARAM->functions.pLast->lPCodePos;
             }
             Crlf                                     /* 8 */
             {
                /* 9
                */
                $<lNumber>$ = hb_compGenJumpFalse( 0, HB_COMP_PARAM );
             }
             ForStatements                            /* 10 */
             {
                hb_compLoopHere( HB_COMP_PARAM );
                hb_compEnumNext( HB_COMP_PARAM, $2, $6 );
                hb_compGenJump( $<lNumber>7 - HB_COMP_PARAM->functions.pLast->lPCodePos, HB_COMP_PARAM );

                hb_compGenJumpHere( $<lNumber>9, HB_COMP_PARAM );
                hb_compLoopEnd( HB_COMP_PARAM );
                HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
                hb_compEnumEnd( HB_COMP_PARAM, $2 );
                hb_compExprDelete( $2, HB_COMP_PARAM );
                hb_compExprDelete( $4, HB_COMP_PARAM );
             }
           ;

Descend    : /* default up */     { $$ =  1; }
           | DESCEND              { $$ = -1; }
           ;

DoSwitch   : SwitchBegin
             {
                hb_compLoopStart( HB_COMP_PARAM );
                hb_compSwitchStart( HB_COMP_PARAM );
                hb_compGenJump( 0, HB_COMP_PARAM );
             }
             SwitchCases
             EndSwitch
             {
                hb_compSwitchEnd( HB_COMP_PARAM );
                hb_compLoopEnd( HB_COMP_PARAM );
             }

           | SwitchBegin
             EndSwitch
             {
                hb_compGenPData1( HB_P_POP, HB_COMP_PARAM );
             }

           ;
           
EndSwitch  : END
             {
                --HB_COMP_PARAM->wSwitchCounter; 
                HB_COMP_PARAM->functions.pLast->bFlags &= ~ ( FUN_WITH_RETURN | FUN_BREAK_CODE );
             }
           ;

SwitchStart : DOSWITCH 
              { ++HB_COMP_PARAM->wSwitchCounter; 
                 hb_compLinePush( HB_COMP_PARAM );
              } 
              Expression Crlf
              {
                 hb_compExprDelete( hb_compExprGenPush( $3, HB_COMP_PARAM ), HB_COMP_PARAM );
              }
            ;

SwitchBegin : SwitchStart            { }
            | SwitchStart Statements {
                        if( $<lNumber>2 > 0 )
                        {
                           hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_MAYHEM_IN_CASE, NULL, NULL );
                        }
                     }
            ;

SwitchCases : CASE Expression { hb_compSwitchAdd( HB_COMP_PARAM, $2 ); hb_compLinePush( HB_COMP_PARAM ); } Crlf
             EmptyStats

           | SwitchCases CASE Expression { hb_compSwitchAdd( HB_COMP_PARAM, $3 ); hb_compLinePush( HB_COMP_PARAM ); }Crlf
             EmptyStats

           | SwitchDefault

           | SwitchCases SwitchDefault
           ;

SwitchDefault : OTHERWISE { hb_compSwitchAdd( HB_COMP_PARAM, NULL ); hb_compLinePush( HB_COMP_PARAM ); } Crlf { HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE; }
                EmptyStats
           ;
           
BeginSeq   : BEGINSEQ { ++HB_COMP_PARAM->wSeqCounter; $<lNumber>$ = hb_compSequenceBegin( HB_COMP_PARAM ); } Crlf
                EmptyStats
                {
                  /* Set jump address for HB_P_SEQBEGIN opcode - this address
                   * will be used in BREAK code if there is no RECOVER clause
                   */
                  hb_compGenJumpHere( $<lNumber>2, HB_COMP_PARAM );
                  $<lNumber>$ = hb_compSequenceEnd( HB_COMP_PARAM );
                }
                RecoverSeq
                {
                   /* Replace END address with RECOVER address in
                    * HB_P_SEQBEGIN opcode if there is RECOVER clause
                    */
                   if( $<lNumber>6 )
                      hb_compGenJumpThere( $<lNumber>2, $<lNumber>6, HB_COMP_PARAM );
                }
             END
             {
                /* Fix END address
                 * There is no line number after HB_P_SEQEND in case no
                 * RECOVER clause is used
                 */
                hb_compGenJumpThere( $<lNumber>5, HB_COMP_PARAM->functions.pLast->lPCodePos, HB_COMP_PARAM );
                if( !$<lNumber>6 )   /* only if there is no RECOVER clause */
                   --HB_COMP_PARAM->wSeqCounter;  /* RECOVER is also considered as end of sequence */
                hb_compSequenceFinish( $<lNumber>2, $<lNumber>4, HB_COMP_PARAM );
                HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_WITH_RETURN;
             }
           ;

RecoverSeq : /* no recover */  { $<lNumber>$ = 0; }
           | RecoverEmpty Crlf { $<lNumber>$ = $<lNumber>1; } EmptyStats
           | RecoverUsing Crlf { $<lNumber>$ = $<lNumber>1; } EmptyStats
           ;

RecoverEmpty : RECOVER
               {
                  HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $<lNumber>$ = HB_COMP_PARAM->functions.pLast->lPCodePos;
                  --HB_COMP_PARAM->wSeqCounter;
                  hb_compLinePush( HB_COMP_PARAM );
                  hb_compGenPCode2( HB_P_SEQRECOVER, HB_P_POP, HB_COMP_PARAM );
               }
             ;

RecoverUsing : RECOVERUSING IdentName
               {
                  HB_COMP_PARAM->functions.pLast->bFlags &= ~ FUN_BREAK_CODE;
                  $<lNumber>$ = HB_COMP_PARAM->functions.pLast->lPCodePos;
                  --HB_COMP_PARAM->wSeqCounter;
                  hb_compLinePush( HB_COMP_PARAM );
                  hb_compGenPCode1( HB_P_SEQRECOVER, HB_COMP_PARAM );
                  hb_compGenPopVar( $2, HB_COMP_PARAM );
               }
             ;

/* NOTE: In Clipper all variables used in DO .. WITH are passed by reference
 * however if they are part of an expression then they are passed by value
 * for example:
 * DO .. WITH ++variable
 * will pass the value of variable not a reference
 */
DoName     : IdentName        { $$ = hb_compExprNewFunName( $1, HB_COMP_PARAM ); hb_compAutoOpenAdd( HB_COMP_PARAM, $1 ); }
           | MacroVar         { $$ = $1; }
           | MacroExpr        { $$ = $1; }
           ;

DoProc     : DO DoName
               { $$ = hb_compExprNewFunCall( $2, NULL, HB_COMP_PARAM ); }
           | DO DoName WITH DoArgList
               { $$ = hb_compExprNewFunCall( $2, $4, HB_COMP_PARAM ); }
           | DOIDENT
               { 
                  /* DOIDENT is the only one identifier which can be returned in lower letters */
                  hb_compAutoOpenAdd( HB_COMP_PARAM, $1 ); $$ = hb_compExprNewFunCall( hb_compExprNewFunName( hb_compIdentifierNew( HB_COMP_PARAM, hb_strupr( hb_strdup( $1 ) ), FALSE ), HB_COMP_PARAM ), NULL, HB_COMP_PARAM );
               }
           | DOIDENT WITH DoArgList
               {
                  /* DOIDENT is the only one identifier which can be returned in lower letters */
                  hb_compAutoOpenAdd( HB_COMP_PARAM, $1 ); $$ = hb_compExprNewFunCall( hb_compExprNewFunName( hb_compIdentifierNew( HB_COMP_PARAM, hb_strupr( hb_strdup( $1 ) ), FALSE ), HB_COMP_PARAM ), $3, HB_COMP_PARAM );
               }
           ;

DoArgList  : ','                       { $$ = hb_compExprAddListExpr( hb_compExprNewArgList( hb_compExprNewNil( HB_COMP_PARAM ), HB_COMP_PARAM ), hb_compExprNewNil( HB_COMP_PARAM ) ); }
           | ',' DoArgument            { $$ = hb_compExprAddListExpr( hb_compExprNewArgList( hb_compExprNewNil( HB_COMP_PARAM ), HB_COMP_PARAM ), $2 ); }
           | DoArgument                { $$ = hb_compExprNewArgList( $1, HB_COMP_PARAM ); }
           | DoArgList ','             { $$ = hb_compExprAddListExpr( $1, hb_compExprNewNil( HB_COMP_PARAM ) ); }
           | DoArgList ',' DoArgument  { $$ = hb_compExprAddListExpr( $1, $3 ); }
           ;

DoArgument : IdentName                     { $$ = hb_compExprNewVarRef( $1, HB_COMP_PARAM ); }
           | '@' FunIdentCall              { $$ = $2; }
           | '@' IdentName                 { $$ = hb_compExprNewVarRef( $2, HB_COMP_PARAM ); }
           | SimpleExpression              { $$ = $1; }
           | PareExpList                   { $$ = $1; }
           | '@' MacroVar                  { $$ = hb_compExprNewRef( $2, HB_COMP_PARAM ); }
           | '@' AliasVar                  { $$ = hb_compExprNewRef( $2, HB_COMP_PARAM ); }
           ;

WithObject : WITHOBJECT Expression Crlf
               {
                  hb_compExprDelete( hb_compExprGenPush( $2, HB_COMP_PARAM ), HB_COMP_PARAM );
                  hb_compGenPCode1( HB_P_WITHOBJECTSTART, HB_COMP_PARAM );
                  HB_COMP_PARAM->wWithObjectCnt++;
               }
             EmptyStatements 
             END
               {
                  --HB_COMP_PARAM->wWithObjectCnt;
                  hb_compGenPCode1( HB_P_WITHOBJECTEND, HB_COMP_PARAM );
                }
           | WITHOBJECT Expression Crlf END { hb_compExprDelete( $2, HB_COMP_PARAM ); }
           ;

Crlf       : '\n'          { HB_COMP_PARAM->fError = FALSE; }
           | ';'           { HB_COMP_PARAM->fDontGenLineNum = TRUE; }
           ;

%%

/*
 ** ------------------------------------------------------------------------ **
 */

/*
 * Avoid tracing in preprocessor/compiler.
 */
#if ! defined(HB_TRACE_UTILS)
   #if defined(HB_TRACE_LEVEL)
      #undef HB_TRACE_LEVEL
   #endif
#endif


/* ************************************************************************* */

/*
 * This function stores the position in pcode buffer where the FOR/WHILE
 * loop starts. It will be used to fix any LOOP/EXIT statements
 */
static void hb_compLoopStart( HB_COMP_DECL )
{
   HB_LOOPEXIT_PTR pLoop = ( HB_LOOPEXIT_PTR ) hb_xgrab( sizeof( HB_LOOPEXIT ) );

   if( HB_COMP_PARAM->pLoops )
   {
      HB_LOOPEXIT_PTR pLast = HB_COMP_PARAM->pLoops;

      while( pLast->pNext )
         pLast = pLast->pNext;
      pLast->pNext = pLoop;
   }
   else
      HB_COMP_PARAM->pLoops = pLoop;

   pLoop->pNext       = NULL;
   pLoop->pExitList   = NULL;
   pLoop->pLoopList   = NULL;
   pLoop->ulOffset    = HB_COMP_PARAM->functions.pLast->lPCodePos;  /* store the start position */
   pLoop->wSeqCounter = HB_COMP_PARAM->wSeqCounter;  /* store current SEQUENCE counter */
}

/*
 * Stores the position of LOOP statement to fix it later at the end of loop
 */
static void hb_compLoopLoop( HB_COMP_DECL )
{
   if( ! HB_COMP_PARAM->pLoops )
   {
      hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_UNMATCHED_EXIT, "LOOP", NULL );
   }
   else
   {
      HB_LOOPEXIT_PTR pLast, pLoop;

      pLoop = ( HB_LOOPEXIT_PTR ) hb_xgrab( sizeof( HB_LOOPEXIT ) );

      pLoop->pLoopList = NULL;
      pLoop->ulOffset = HB_COMP_PARAM->functions.pLast->lPCodePos;  /* store the position to fix */

      pLast = HB_COMP_PARAM->pLoops;
      while( pLast->pNext )
         pLast = pLast->pNext;

      if( pLast->wSeqCounter != HB_COMP_PARAM->wSeqCounter )
      {
         /* Attempt to LOOP from BEGIN/END sequence
         * Current SEQUENCE counter is different then at the beginning of loop
         * Notice that LOOP is allowed in RECOVER code.
         */
         hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "LOOP", NULL );
      }
      else
      {
         while( pLast->pLoopList )
            pLast = pLast->pLoopList;

         pLast->pLoopList = pLoop;

         hb_compGenJump( 0, HB_COMP_PARAM );
      }
   }
}

/*
 * Stores the position of EXIT statement to fix it later at the end of loop
 */
static void hb_compLoopExit( HB_COMP_DECL )
{
   if( ! HB_COMP_PARAM->pLoops )
   {
      hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_UNMATCHED_EXIT, "EXIT", NULL );
   }
   else
   {
      HB_LOOPEXIT_PTR pLast, pLoop;

      pLoop = ( HB_LOOPEXIT_PTR ) hb_xgrab( sizeof( HB_LOOPEXIT ) );

      pLoop->pExitList = NULL;
      pLoop->ulOffset = HB_COMP_PARAM->functions.pLast->lPCodePos;  /* store the position to fix */

      pLast = HB_COMP_PARAM->pLoops;
      while( pLast->pNext )
         pLast = pLast->pNext;

      if( pLast->wSeqCounter != HB_COMP_PARAM->wSeqCounter )
      {
         /* Attempt to LOOP from BEGIN/END sequence
         * Current SEQUENCE counter is different then at the beginning of loop
         * Notice that LOOP is allowed in RECOVER code.
         */
         hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_EXIT_IN_SEQUENCE, "EXIT", NULL );
      }
      else
      {
         while( pLast->pExitList )
            pLast = pLast->pExitList;

         pLast->pExitList = pLoop;

         hb_compGenJump( 0, HB_COMP_PARAM );
      }
   }
}

/*
 * Fixes the LOOP statement
 */
static void hb_compLoopHere( HB_COMP_DECL )
{
   HB_LOOPEXIT_PTR pLoop = HB_COMP_PARAM->pLoops, pFree, pLast;

   if( pLoop )
   {
      while( pLoop->pNext )
         pLoop = pLoop->pNext;

      pLast = pLoop;
      pLoop = pLoop->pLoopList;
      while( pLoop )
      {
         hb_compGenJumpHere( pLoop->ulOffset + 1, HB_COMP_PARAM );
         pFree = pLoop;
         pLoop = pLoop->pLoopList;
         hb_xfree( ( void * ) pFree );
      }
      pLast->pLoopList = NULL;
   }
}

/*
 * Fixes the EXIT statements and releases memory allocated for current loop
 */
static void hb_compLoopEnd( HB_COMP_DECL )
{
   HB_LOOPEXIT_PTR pExit, pLoop = HB_COMP_PARAM->pLoops, pLast = HB_COMP_PARAM->pLoops, pFree;

   if( pLoop )
   {
      while( pLoop->pNext )
      {
         pLast = pLoop;
         pLoop = pLoop->pNext;
      }

      pExit = pLoop->pExitList;
      while( pExit )
      {
         hb_compGenJumpHere( pExit->ulOffset + 1, HB_COMP_PARAM );
         pFree = pExit;
         pExit = pExit->pExitList;
         hb_xfree( ( void * ) pFree );
      }

      pLast->pNext = NULL;
      if( pLoop == HB_COMP_PARAM->pLoops )
         HB_COMP_PARAM->pLoops = NULL;
      hb_xfree( ( void * ) pLoop );
   }
}

void hb_compLoopKill( HB_COMP_DECL )
{
   HB_LOOPEXIT_PTR pLoop;
   HB_LOOPEXIT_PTR pExit;
   
   while( HB_COMP_PARAM->pLoops )   
   {
      pLoop = HB_COMP_PARAM->pLoops;
      while( pLoop->pExitList )
      {
         pExit = pLoop->pExitList;
         pLoop->pExitList = pExit->pExitList;
         hb_xfree( ( void * ) pExit );
      }
      HB_COMP_PARAM->pLoops = pLoop->pNext;
      hb_xfree( ( void * ) pLoop );
   }
}

static void * hb_compElseIfGen( HB_COMP_DECL, void * pFirst, ULONG ulOffset )
{
   HB_ELSEIF_PTR pElseIf = ( HB_ELSEIF_PTR ) hb_xgrab( sizeof( HB_ELSEIF ) ), pLast;

   pElseIf->ulOffset = ulOffset;
   pElseIf->pPrev   = NULL;
   pElseIf->pElseif = NULL;

   if( pFirst )
   {
      pLast = ( HB_ELSEIF_PTR ) pFirst;
      while( pLast->pElseif )
         pLast = pLast->pElseif;
      pLast->pElseif = pElseIf;
   }
   else
   {
      if( HB_COMP_PARAM->elseif )
      {
         pElseIf->pPrev = HB_COMP_PARAM->elseif;
      }
      pFirst = pElseIf;
      HB_COMP_PARAM->elseif = pElseIf;
   }
   return pFirst;
}


static void hb_compElseIfFix( HB_COMP_DECL, void * pFixElseIfs )
{
   HB_ELSEIF_PTR pFix = ( HB_ELSEIF_PTR ) pFixElseIfs;
   HB_ELSEIF_PTR pDel;
   
   HB_COMP_PARAM->elseif = pFix->pPrev;
   while( pFix )
   {
      hb_compGenJumpHere( pFix->ulOffset, HB_COMP_PARAM );
      pDel = pFix;
      pFix = pFix->pElseif;
      hb_xfree( pDel );
   }
}

void hb_compElseIfKill( HB_COMP_DECL )
{
   HB_ELSEIF_PTR pFix;
   HB_ELSEIF_PTR pDel;
   
   while( HB_COMP_PARAM->elseif )
   {
      pFix = HB_COMP_PARAM->elseif;
      HB_COMP_PARAM->elseif = pFix->pPrev;
      while( pFix )
      {
         pDel = pFix;
         pFix = pFix->pElseif;
         hb_xfree( pDel );
      }
   }
}

static void hb_compRTVariableAdd( HB_COMP_DECL, HB_EXPR_PTR pVar, BOOL bPopInitValue )
{
   HB_RTVAR_PTR pRTvar = ( HB_RTVAR_PTR ) hb_xgrab( sizeof( HB_RTVAR ) );

   pRTvar->pVar = pVar;
   pRTvar->bPopValue = bPopInitValue;
   pRTvar->pNext = NULL;
   pRTvar->pPrev = NULL;

   if( HB_COMP_PARAM->rtvars )
   {
      HB_RTVAR_PTR pLast = HB_COMP_PARAM->rtvars;
      while( pLast->pNext )
         pLast = pLast->pNext;
      pLast->pNext = pRTvar;
      pRTvar->pPrev = pLast;
   }
   else
      HB_COMP_PARAM->rtvars = pRTvar;
}

static void hb_compRTVariableGen( HB_COMP_DECL, char * szCreateFun )
{
   USHORT usCount = 0;
   HB_RTVAR_PTR pVar = HB_COMP_PARAM->rtvars;
   HB_RTVAR_PTR pDel;

   /* generate the function call frame */
   hb_compGenPushSymbol( szCreateFun, TRUE, FALSE, HB_COMP_PARAM );
   hb_compGenPushNil( HB_COMP_PARAM );

   /* push variable names to create */
   while( pVar->pNext )
   {
      hb_compExprGenPush( pVar->pVar, HB_COMP_PARAM );
      pVar = pVar->pNext;
      ++usCount;
   }
   hb_compExprGenPush( pVar->pVar, HB_COMP_PARAM );
   ++usCount;

   /* call function that will create either PUBLIC or PRIVATE variables */
   if( usCount > 255 )
      hb_compGenPCode3( HB_P_DO, HB_LOBYTE( usCount ), HB_HIBYTE( usCount ), HB_COMP_PARAM );
   else
      hb_compGenPCode2( HB_P_DOSHORT, ( BYTE ) usCount, HB_COMP_PARAM );

   /* pop initial values */
   while( pVar )
   {
      if( pVar->bPopValue )
         hb_compExprDelete( hb_compExprGenPop( pVar->pVar, HB_COMP_PARAM ), HB_COMP_PARAM );
      else
         hb_compExprDelete( pVar->pVar, HB_COMP_PARAM );
      pDel = pVar;
      pVar = pVar->pPrev;
      hb_xfree( pDel );
   }
   HB_COMP_PARAM->rtvars = NULL;
}

void hb_compRTVariableKill( HB_COMP_DECL )
{
   HB_RTVAR_PTR pVar;
   
   while( HB_COMP_PARAM->rtvars )
   {
      pVar = HB_COMP_PARAM->rtvars;

      hb_compExprDelete( pVar->pVar, HB_COMP_PARAM );
      HB_COMP_PARAM->rtvars = pVar->pPrev;
      hb_xfree( pVar );
   }
   HB_COMP_PARAM->rtvars = NULL;
}

static void hb_compVariableDim( char * szName, HB_EXPR_PTR pInitValue, HB_COMP_DECL )
{
  if( HB_COMP_PARAM->iVarScope == VS_PUBLIC || HB_COMP_PARAM->iVarScope == VS_PRIVATE )
  {
     USHORT uCount = (USHORT) hb_compExprListLen( pInitValue );
     hb_compVariableAdd( HB_COMP_PARAM, szName, 'A' );
     hb_compExprDelete( hb_compExprGenPush( pInitValue, HB_COMP_PARAM ), HB_COMP_PARAM );
     hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), HB_COMP_PARAM );
     hb_compRTVariableAdd( HB_COMP_PARAM, hb_compExprNewRTVar( szName, NULL, HB_COMP_PARAM ), TRUE );
  }
  else if( HB_COMP_PARAM->iVarScope == VS_STATIC )
  {
     USHORT uCount = (USHORT) hb_compExprListLen( pInitValue );
     HB_EXPR_PTR pVar = hb_compExprNewVar( szName, HB_COMP_PARAM );
     HB_EXPR_PTR pAssign;

     /* create a static variable */
     hb_compVariableAdd( HB_COMP_PARAM, szName, 'A' );
     hb_compStaticDefStart( HB_COMP_PARAM );   /* switch to statics pcode buffer */
     /* create an array */
     hb_compExprGenPush( pInitValue, HB_COMP_PARAM );
     hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), HB_COMP_PARAM );
     /* check if valid initializers were used but don't generate any code */
     pAssign = hb_compExprAssignStatic( pVar, pInitValue, HB_COMP_PARAM );
     /* now pop an array */
     hb_compExprGenPop( pVar, HB_COMP_PARAM );
     /* delete all used expressions */
     hb_compExprDelete( pAssign, HB_COMP_PARAM );
     hb_compStaticDefEnd( HB_COMP_PARAM );
  }
  else
  {
     USHORT uCount = (USHORT) hb_compExprListLen( pInitValue );

     hb_compVariableAdd( HB_COMP_PARAM, szName, 'A' );
     hb_compExprDelete( hb_compExprGenPush( pInitValue, HB_COMP_PARAM ), HB_COMP_PARAM );
     hb_compGenPCode3( HB_P_ARRAYDIM, HB_LOBYTE( uCount ), HB_HIBYTE( uCount ), HB_COMP_PARAM );
     hb_compExprDelete( hb_compExprGenPop( hb_compExprNewVar( szName, HB_COMP_PARAM ), HB_COMP_PARAM ), HB_COMP_PARAM );
  }
}

static void hb_compForStart( HB_COMP_DECL, char *szVarName, BOOL bForEach )
{
   HB_ENUMERATOR_PTR pEnumVar;
   
   pEnumVar = HB_COMP_PARAM->functions.pLast->pEnum;
   if( pEnumVar == NULL )
   {
      HB_COMP_PARAM->functions.pLast->pEnum = (HB_ENUMERATOR_PTR) hb_xgrab( sizeof(HB_ENUMERATOR) );
      pEnumVar = HB_COMP_PARAM->functions.pLast->pEnum;
   }
   else
   {
      BOOL bWarn = TRUE;
      HB_ENUMERATOR_PTR pLast = pEnumVar;

      while( pEnumVar )
      {
         if( strcmp( pEnumVar->szName, szVarName ) == 0 )
         {
            /* Enumerator variable exists already - throw warning */
            if( bWarn == TRUE )
            {
               hb_compGenWarning( HB_COMP_PARAM, hb_comp_szWarnings, 'W', HB_COMP_WARN_FORVAR_DUPL, szVarName, NULL );
               bWarn = FALSE;
            }
         }
         pLast = pEnumVar;
         pEnumVar = pEnumVar->pNext;
      }
      pLast->pNext = (HB_ENUMERATOR_PTR) hb_xgrab( sizeof(HB_ENUMERATOR) );
      pEnumVar = pLast->pNext;
   }
   pEnumVar->szName   = szVarName;
   pEnumVar->bForEach = bForEach;
   pEnumVar->pNext    = NULL;
}

BOOL hb_compForEachVarError( HB_COMP_DECL, char *szVarName )
{
   HB_ENUMERATOR_PTR pEnumVar;
   
   pEnumVar = HB_COMP_PARAM->functions.pLast->pEnum;
   if( pEnumVar )
   {
      while( pEnumVar )
      {
         if( strcmp( pEnumVar->szName, szVarName ) == 0 )
         {
            if( pEnumVar->bForEach )
            {
               /* only if it is FOR EACH enumerator 
                * generate warning if it is FOR/NEXT loop
               */
               return FALSE;
            }
         }
         pEnumVar = pEnumVar->pNext;
      }
   }

   hb_compGenWarning( HB_COMP_PARAM, hb_comp_szWarnings, 'W', HB_COMP_WARN_ENUM_INVALID, szVarName, NULL );
   return TRUE;            
}

static void hb_compForEnd( HB_COMP_DECL, char *szVar )
{
   HB_ENUMERATOR_PTR pEnumVar;
   
   HB_SYMBOL_UNUSED( HB_COMP_PARAM );
   HB_SYMBOL_UNUSED( szVar );
   
   pEnumVar = HB_COMP_PARAM->functions.pLast->pEnum;
   if( pEnumVar->pNext )
   {
      HB_ENUMERATOR_PTR pLast = pEnumVar;
      
      while( pEnumVar->pNext )
      {
         pLast = pEnumVar;
         pEnumVar = pEnumVar->pNext;
      }
      hb_xfree( pEnumVar );
      pLast->pNext = NULL;
   }
   else
   {
      hb_xfree( pEnumVar );
      HB_COMP_PARAM->functions.pLast->pEnum = NULL;
   }
}

static HB_CARGO2_FUNC( hb_compEnumEvalStart )
{
   char * szName = hb_compExprAsSymbol( (HB_EXPR_PTR)cargo );
   if( szName )
      hb_compForStart( HB_COMP_PARAM, szName, TRUE );
      
   hb_compExprGenPush( (HB_EXPR_PTR)dummy, HB_COMP_PARAM );  /* expression */
   hb_compExprGenPush( (HB_EXPR_PTR)cargo, HB_COMP_PARAM );  /* variable */
}

static void hb_compEnumStart( HB_COMP_DECL, HB_EXPR_PTR pVars, HB_EXPR_PTR pExprs, int descend )
{
   ULONG ulLen;
   
   if( hb_compExprListLen(pVars) != hb_compExprListLen(pExprs) )
   {
      hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_FORVAR_DIFF, NULL, NULL );
   }

   ulLen = hb_compExprListEval2( HB_COMP_PARAM, pVars, pExprs, hb_compEnumEvalStart );
   
   if( ulLen > 255 )
   {
      hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_FORVAR_TOOMANY, NULL, NULL );
   }
   else
   {
      BYTE Len;
      Len = (BYTE) (ulLen & 0xFF);
      hb_compGenPCode3( HB_P_ENUMSTART, Len, descend > 0 ? 1 : 0, HB_COMP_PARAM );
   }
}

static void hb_compEnumNext( HB_COMP_DECL, HB_EXPR_PTR pExpr, int descend )
{
   HB_SYMBOL_UNUSED( pExpr );
   if( descend > 0 )
   {
      hb_compGenPCode1( HB_P_ENUMNEXT, HB_COMP_PARAM );
   }
   else
   {
      hb_compGenPCode1( HB_P_ENUMPREV, HB_COMP_PARAM );
   }
}

static HB_CARGO_FUNC( hb_compEnumEvalEnd )
{
   char * szName = hb_compExprAsSymbol( (HB_EXPR_PTR)cargo );

   if( szName )
      hb_compForEnd( HB_COMP_PARAM, szName );
}

static void hb_compEnumEnd( HB_COMP_DECL, HB_EXPR_PTR pExpr )
{
   hb_compExprListEval( HB_COMP_PARAM, pExpr, hb_compEnumEvalEnd );
   hb_compGenPCode1( HB_P_ENUMEND, HB_COMP_PARAM );
}

static void hb_compSwitchStart( HB_COMP_DECL )
{
   HB_SWITCHCMD_PTR pSwitch = (HB_SWITCHCMD_PTR) hb_xgrab( sizeof(HB_SWITCHCMD) );

   pSwitch->pCases = NULL;
   pSwitch->pLast  = NULL;
   pSwitch->ulDefault = 0;
   pSwitch->ulOffset = HB_COMP_PARAM->functions.pLast->lPCodePos;
   pSwitch->iCount = 0;
   pSwitch->pPrev = HB_COMP_PARAM->pSwitch;
   HB_COMP_PARAM->pSwitch = pSwitch;
}

static void hb_compSwitchAdd( HB_COMP_DECL, HB_EXPR_PTR pExpr )
{
   HB_SWITCHCASE_PTR pCase;
   
   if( pExpr )
   {
      /* normal CASE */
      pCase = (HB_SWITCHCASE_PTR) hb_xgrab( sizeof(HB_SWITCHCASE) );
      pCase->ulOffset = HB_COMP_PARAM->functions.pLast->lPCodePos;
      pCase->pNext = NULL;
      pExpr = hb_compExprReduce( pExpr, HB_COMP_PARAM );
      if( !(hb_compExprIsLong(pExpr) || hb_compExprIsString(pExpr)) )
      {
         hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_NOT_LITERAL_CASE, NULL, NULL );
      }
      pCase->pExpr = pExpr;

      if( HB_COMP_PARAM->pSwitch->pLast )
      {
         HB_COMP_PARAM->pSwitch->pLast->pNext = pCase;
         HB_COMP_PARAM->pSwitch->pLast = pCase;
      }
      else
      {
         HB_COMP_PARAM->pSwitch->pCases = HB_COMP_PARAM->pSwitch->pLast = pCase;
      }
      HB_COMP_PARAM->pSwitch->iCount++;
      if( hb_compExprIsString( pExpr ) && hb_compExprAsStringLen(pExpr) > 255 )
      {
         hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_INVALID_STR, NULL, NULL );
      }
   }
   else
   {
      /* DEFAULT */
      if( HB_COMP_PARAM->pSwitch->ulDefault )
      {
         /* more than one default clause */
         hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_MAYHEM_IN_CASE, NULL, NULL );
      }
      else
      {
         HB_COMP_PARAM->pSwitch->ulDefault = HB_COMP_PARAM->functions.pLast->lPCodePos;
         HB_COMP_PARAM->pSwitch->iCount++;
      }
   }
   
}

static void hb_compSwitchEnd( HB_COMP_DECL )
{ 
   BOOL fLongOptimize = HB_COMP_PARAM->fLongOptimize;
   BOOL fTextSubst = HB_COMP_PARAM->fTextSubst;
   HB_SWITCHCASE_PTR pCase = HB_COMP_PARAM->pSwitch->pCases;
   HB_SWITCHCASE_PTR pTmp;
   HB_SWITCHCMD_PTR pTmpSw;
   ULONG ulExitPos;
   ULONG ulDef;

   /* skip switch pcode if there was no EXIT in the last CASE
    * or in the DEFAULT case
   */
   ulExitPos = hb_compGenJump( 0, HB_COMP_PARAM ); 
   
   hb_compGenJumpHere( HB_COMP_PARAM->pSwitch->ulOffset + 1, HB_COMP_PARAM );
   hb_compGenPCode3( HB_P_SWITCH, HB_LOBYTE(HB_COMP_PARAM->pSwitch->iCount), HB_HIBYTE(HB_COMP_PARAM->pSwitch->iCount), HB_COMP_PARAM );
   HB_COMP_PARAM->fLongOptimize = FALSE;   
   HB_COMP_PARAM->fTextSubst = FALSE;
   while( pCase )
   {
      if( pCase->pExpr )
      {
         if( hb_compExprIsLong(pCase->pExpr) || hb_compExprIsString(pCase->pExpr) )
         {
            hb_compExprDelete( hb_compExprGenPush( pCase->pExpr, HB_COMP_PARAM ), HB_COMP_PARAM );
            hb_compGenJumpThere( hb_compGenJump( 0, HB_COMP_PARAM ), pCase->ulOffset, HB_COMP_PARAM );
         }
         else
         {
            hb_compExprDelete( pCase->pExpr, HB_COMP_PARAM );
         }
      }
      pCase = pCase->pNext;
   }
   hb_compGenPData1( HB_P_PUSHNIL, HB_COMP_PARAM );    /* end of cases */
   ulDef = hb_compGenJump( 0, HB_COMP_PARAM );
   
   if( HB_COMP_PARAM->pSwitch->ulDefault )
   {
      hb_compGenJumpThere( ulDef, HB_COMP_PARAM->pSwitch->ulDefault, HB_COMP_PARAM );
   }
   else
      hb_compGenJumpHere( ulDef, HB_COMP_PARAM );

   HB_COMP_PARAM->fLongOptimize = fLongOptimize;
   HB_COMP_PARAM->fTextSubst = fTextSubst;

   hb_compGenJumpHere( ulExitPos, HB_COMP_PARAM );
   
   pCase = HB_COMP_PARAM->pSwitch->pCases;
   while( pCase )
   {
      pTmp = pCase->pNext;
      hb_xfree( (void *)pCase );
      pCase = pTmp;
   }
   pTmpSw = HB_COMP_PARAM->pSwitch;
   HB_COMP_PARAM->pSwitch = HB_COMP_PARAM->pSwitch->pPrev;
   hb_xfree( pTmpSw );
}

/* Release all switch statements
*/
void hb_compSwitchKill( HB_COMP_DECL )
{
   HB_SWITCHCASE_PTR pCase;
   HB_SWITCHCMD_PTR pSwitch;

   while( HB_COMP_PARAM->pSwitch )
   {
      while( HB_COMP_PARAM->pSwitch->pCases )
      {
         pCase = HB_COMP_PARAM->pSwitch->pCases;
         hb_compExprDelete( pCase->pExpr, HB_COMP_PARAM );
         HB_COMP_PARAM->pSwitch->pCases = pCase->pNext;
         hb_xfree( (void *) pCase );
      }
      pSwitch = HB_COMP_PARAM->pSwitch;
      HB_COMP_PARAM->pSwitch = pSwitch->pPrev;
      hb_xfree( (void *) pSwitch );
   }
}

static HB_EXPR_PTR hb_compCheckPassByRef( HB_COMP_DECL, HB_EXPR_PTR pExpr )
{
   if( !( HB_COMP_PARAM->iPassByRef & (HB_PASSBYREF_FUNCALL | HB_PASSBYREF_ARRAY) ) )
   {
      hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_INVALID_REFER, hb_compExprAsSymbol( pExpr ), NULL );
   }
   return pExpr;
}

/* ************************************************************************* */

void yyerror( HB_COMP_DECL, char * s )
{
   HB_SYMBOL_UNUSED( pComp );

   if( !HB_COMP_PARAM->pLex->lasttok || HB_COMP_PARAM->pLex->lasttok[ 0 ] == '\n' )
      hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_YACC, s, "<eol>" );
   else
      hb_compGenError( HB_COMP_PARAM, hb_comp_szErrors, 'E', HB_COMP_ERR_YACC, s, HB_COMP_PARAM->pLex->lasttok );
}
