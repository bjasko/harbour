//	rdd.api
//
#ifndef  _RDD_API
#define _RDD_API

//+
//	Harbour project 	The free Clipper(tm) compatible xbase compiler
//
//	Harbour RDD.API
//
//	this file is highly compatible with the CA-Clipper RDD.API
//
//
//	NOTE:		the defines in the first part of this file
//			are included from rddsys.ch take care changing
//			the #define
//
//
//
//	99.04.25	initial posting.
//
//	all structures are ordered alphabetically (if possible)
//
//
//-


#define HARBOUR_MAX_RDD_DRIVERNAME_LENGTH	32
#define HARBOUR_MAX_ALIAS_LENGTH		32

// Flags for DBTRANSINFO
#define DBTF_MATCH	0x0001
#define DBTF_PUTREC	0x0002


// Codes for Locking methods

#define DBLM_EXCLUSIVE	   1
#define DBLM_MULTIPLE	   2
#define DBLM_FILE	   3

// Codes for SELF_ORDINFO()

#define DBOI_CONDITION	   1  // Get the order condition
#define DBOI_EXPRESSION    2  // Get the order expression
#define DBOI_POSITION	   3  // Get the order position
#define DBOI_RECNO	   4  // Get the order record number
#define DBOI_NAME	   5  // Get the order list name
#define DBOI_NUMBER	   6  // Get the order list position
#define DBOI_BAGNAME	   7  // Get the order Bag name
#define DBOI_BAGEXT	   8  // Get the order Bag Extension
#define DBOI_INDEXEXT	   DBOI_BAGEXT
#define DBOI_INDEXNAME	   DBOI_BAGNAME
#define DBOI_ORDERCOUNT    9  // Get the number of orders in the index file
#define DBOI_FILEHANDLE   10  // Get the handle of the index file
#define DBOI_ISCOND	  11  // Get the flag if the order has a for condition
#define DBOI_ISDESC	  12  // Get the flag if the order is descending
#define DBOI_UNIQUE	  13  // Get the flag if the order has the unique attribute set

// Codes for SELF_INFO()

#define DBI_ISDBF	   1  // Logical: RDD support DBF file format?
#define DBI_CANPUTREC	   2  // Logical: RDD support Putting Records?
#define DBI_GETHEADERSIZE  3  // Numeric: Get header size of the file
#define DBI_LASTUPDATE	   4  // Date:	  Last date RDD file updated
#define DBI_GETDELIMITER   5  // String:  Get default delimiter
#define DBI_SETDELIMITER   6  // String:  Set default delimiter
#define DBI_GETRECSIZE	   7  // Numeric: Get record size of the file
#define DBI_GETLOCKARRAY   8  // Array: Get an array of locked records
#define DBI_TABLEEXT	   9  // String:  Get table file extension

#define DBI_ISFLOCK	  20  // Get file lock status

#define DBI_CHILDCOUNT	  22  // Number of opened relations
#define DBI_FILEHANDLE	  23  // Handle of opened file

#define DBI_BOF 	  26  // BOF flag - alternate to bof()
#define DBI_EOF 	  27  // EOF flag - alternate to eof()
#define DBI_DBFILTER	  28  // Filter expression
#define DBI_FOUND	  29  // FOUND flag - alternate to found
#define DBI_FCOUNT	  30  // Number of fields
#define DBI_LOCKCOUNT	  31  // Get record size of the file
#define DBI_VALIDBUFFER   32  // Is the current buffer valid
#define DBI_ALIAS	  33  // Alias name of workarea
#define DBI_GETSCOPE	  34  // Locate codeblock
#define DBI_LOCKOFFSET	  35  // New locking offset
#define DBI_SHARED	  36  // Gets/Sets the shared flag

#define DBI_MEMOEXT	  37  // Gets/Sets the shared flag
#define DBI_MEMOHANDLE	  38  // Dos handle for memo file
#define DBI_MEMOBLOCKSIZE 39  // Blocksize in memo files

#define DBI_DB_VERSION	 101  // HOST driver Version
#define DBI_RDD_VERSION  102  // RDD version (current RDD)

#define DBI_USER	1000  // Start of user definable DBI_ values


// codes for SELF_RECINFO()

#define DBRI_DELETED	  1
#define DBRI_LOCKED	  2
#define DBRI_RECSIZE	  3
#define DBRI_RECNO	  4
#define DBRI_UPDATED	  5


// codes for SELF_FIELDINFO()

#define DBS_NAME	  1
#define DBS_TYPE	  2
#define DBS_LEN 	  3
#define DBS_DEC 	  4

// codes for RawLock types

#define FILE_LOCK	  1
#define FILE_UNLOCK	  2
#define REC_LOCK	  3
#define REC_UNLOCK	  4
#define HEADER_LOCK	  5
#define HEADER_UNLOCK	  6
#define APPEND_LOCK	  7
#define APPEND_UNLOCK	  8


#define HARBOUR_MAX_FIELDNAME_SIZE	256
#define INITIAL_NUMBER_OF_WORKAREAS	256

#ifndef _RDDSYS_CH

#define _DBRELINFO	struct __DBRELINFO
#define _AREA		struct __AREA
typedef _AREA		 AREA;
typedef AREA *		 AREAP;


//
// DBFIELDINFO		Field structure
//
//
//
//	differences (vs. CA Clipper 5.3 spec)
//	ULONG	in stead of USHORT
//
//


typedef struct
{
   PBYTE		atomName;		// FIELD (symbol) name	note for non dbf files > 10 chars!
   ULONG		uiType; 		// FIELD type		note non dbf file types allowed
   ULONG		typeExtended;		// FIELD type extended
   ULONG		uiLen;			// Overall FIELD length
   ULONG		uiDec;			// Decimal places of numeric FIELD
} DBFIELDINFO;

typedef DBFIELDINFO *	  LPDBFIELDINFO;


//
// DBOPENINFO		Open info structure
//
//
//

typedef struct
{
   ULONG		uiArea; 		// Work Area number of the data store
   PBYTE		abName; 		// The qualified name of the data store
   PBYTE		atomAlias;		// The logical name of the data store
   BOOL 		fShared;		// Share mode of the data store
   BOOL 		fReadonly;		// Readonly mode of the data store
   FARP 		lpdbHeader;		// Pointer to a header of the data store
} DBOPENINFO;
typedef DBOPENINFO *	 LPDBOPENINFO;

//
// DBORDERCONDINFO		Create order for conditional info structure
//
//

typedef struct _DBORDERCONDINFO
{
   BOOL 		fActive;		//
   PBYTE		abFor;
   ITEM 		itmCobFor;
   ITEM 		itmCobWhile;
   ITEM 		itmCobEval;
   LONG 		lStep;
   LONG 		lStartRecno;
   LONG 		lNextCount;
   LONG 		lRecno;
   BOOL 		fRest;
   BOOL 		fDescending;
   BOOL 		fScoped;
   BOOL 		fAll;
   BOOL 		fAdditive;
   BOOL 		fUseCurrent;
   BOOL 		fCustom;
   BOOL 		fNoOptimize;
   FARP 		lpvCargo;
} DBORDERCONDINFO;
typedef DBORDERCONDINFO *     LPDBORDERCONDINFO;



//
// DBORDERCREATE	the create order info structure
//

typedef struct
{
   LPDBORDERCONDINFO	lpdbOrdCondInfo;	// conditional information
   PBYTE		abBagName;		// Name of the Order bag
   PBYTE		atomBagName;		//
   ITEM 		itmOrder;		//
   BOOL 		fUnique;		// Flag to deterimine if all keys are unique
   ITEM 		itmCobExpr;		// Code block containing the KEY expression
   ITEM 		abExpr; 		// String containing the KEY expression
} DBORDERCREATEINFO;
typedef DBORDERCREATEINFO *	LPDBORDERCREATEINFO;


//
// DBORDERINFO		set index info structure
// The Set Index Info structure
//
typedef struct
{
   ITEM 		atomBagName;		// Name of the Order Bag
   ITEM 		itmOrder;		// Name or Number of the Order
   ITEM 		itmCobExpr;		// Code block containing the KEY expression
   ITEM 		itmResult;		// Operation result
   BOOL 		fAllTags;		// Flag for all tags to be opened

} DBORDERINFO;

typedef DBORDERINFO *	  LPDBORDERINFO;



//
// DBSCOPEINFO
//
typedef struct
{
   ITEM 		itmCobFor;		// Code Block representation of a FOR clause
   ITEM 		lpstrFor;		// String representation of a FOR clause
   ITEM 		itmCobWhile;		// Code Block representation of a WHILE clause
   ITEM 		lpstrWhile;		// String representation of a WHILE clause
   ITEM 		lNext;
   ITEM 		itmRecID;
   ITEM 		fRest;			// TRUE if start from the current record
   BOOL 		fIgnoreFilter;
   BOOL 		fIncludeDeleted;
   BOOL 		fLast;
   BOOL 		fIgnoreDuplicates;
} DBSCOPEINFO;
typedef DBSCOPEINFO *	  LPDBSCOPEINFO;


//
// DBFILTERINFO
//

typedef struct
{
  ITEM			itmCobExpr;		// Block representation of the FILTER expression
  ITEM			abFilterText;		// String representation of FILTER expression
  BOOL			fFilter;
} DBFILTERINFO;
typedef DBFILTERINFO *	   LPDBFILTERINFO;



//
// DBRELINFO
//

typedef _DBRELINFO
{
   ITEM 		itmCobExpr;		// Block representation of the relational SEEK key
   ITEM 		abKey;			// String representation of the relational SEEK key
   AREAP		lpaParent;		// The parent of this relation
   AREAP		lpaChild;		// The parents children
   _DBRELINFO	       *lpdbriNext;		// Next child or parent
} DBRELINFO;
typedef DBRELINFO *	LPDBRELINFO;



//
// DBEVALINFO		The Evaluation Info structure
//
// Contains information necessary for a block evaluation
// on each record of the workarea
//

typedef struct
{
  ITEM			itmBlock;		// The block to be evaluated
  DBSCOPEINFO		dbsci;			// Scope info that limits the evaluation
} DBEVALINFO;
typedef DBEVALINFO *	 LPDBEVALINFO;


//
// DBTRANSITEM		the transfer item structure
//
// Defines a single transfer item (usually a field) from
// one database to another; used by DBTRANSINFO
//

typedef struct
{
  ULONG 		uiSource;		// Field index number from the source
  ULONG 		uiDest; 		// Destination field index number
} DBTRANSITEM;
typedef DBTRANSITEM *	  LPDBTRANSITEM;


//
// DBTRANSINFO		the transfer info structure
//
// Defines a global transfer of data items from on workarea
// to another
//

typedef struct
{
   AREAP	       *lpaSource;		// Pointer to source work area
   AREAP	       *lpaDest;		// Pointer to dest work area
   DBSCOPEINFO		dbsci;			// Scope to limit transfer
   ULONG		uiFlags;		// Transfer attributes
   ULONG		uiItemCount;		// Number of items below
   LPDBTRANSITEM	lpTransItems;		// Array of items.
} DBTRANSINFO;
typedef DBTRANSINFO *	  LPDBTRANSINFO;

//
// DBSORTITEM		the sort item structure
//
// An array of items that, together, indicate the key value to
// use while sorting data. The order of the array determines the
// order of the sorting.
//
//
typedef struct
{
   ULONG		uiField;		// Index into the workarea->fields structure
   ULONG		uiFlags;		// sort flags
} DBSORTITEM;
typedef DBSORTITEM *	 LPDBSORTITEM;

// Flags for DBSORTITEM
#define SF_ASCEND	1
#define SF_CASE 	2
#define SF_DESCEND	4
#define SF_NUM	       32
#define SF_DOUBLE      64
#define SF_LONG       128



/*
*  DBSORTINFO
*  ----------
*  The Sort Info Structure
*
*  Information for a physical sort on the workarea
*/

typedef struct
{
   DBTRANSINFO			dbtri;		// Destination workarea transfer information
   LPDBSORTITEM 		lpdbsItem;	// Fields which compose the key values for the sort
   ULONG			uiItemCount;	// the number of fields above

} DBSORTINFO;
typedef DBSORTINFO *	 LPDBSORTINFO;


/*
*  DBLOCKINFO
*  ----------
*  The Lock Info Structure
*
*  Information for a record or file lock
*/

typedef struct
{
  ULONG 		itmRecID;
  ULONG 		uiMethod;
  BOOL			fResult;
} DBLOCKINFO;

typedef DBLOCKINFO *	 LPDBLOCKINFO;



//
// FIELD	the field structure
//
// This is the basic unit of access for a workarea
//

#define _FIELD	struct __FIELD
typedef _FIELD
{
  ULONG 		uiType; 		// Field type
  ULONG 		uiTypeExtended; 	// Field type - extended
  ULONG 		uiLen;			// Field length
  ULONG 		uiDec;			// Decimal length
  ULONG 		uiArea; 		// Area this field resides in
  FARP			sym;			// Symbol that represents the field
  _FIELD	       *lpfNext;		// The next field in the list
} FIELD;
typedef FIELD * 	LPFIELD;

//
//	differences (vs. CA Clipper 5.3 spec)
//
//	RDD FUNCTIONS
//
//	dbstruct	extra function
//
//

typedef struct _RDDFUNCS
{
   /* Movement and positioning methods */
   union
   {
     ULONG	nFunctionCount;
     void      *FunctionPointer[1];
   } u;

   ERRCODE ( * bof	       )  ( AREAP, BOOL * );
   ERRCODE ( * eof	       )  ( AREAP, BOOL * );
   ERRCODE ( * found	       )  ( AREAP, BOOL * );
   ERRCODE ( * goBottom        )  ( AREAP );
   ERRCODE ( * go	       )  ( AREAP, ULONG );
   ERRCODE ( * goToId	       )  ( AREAP, ITEM );
   ERRCODE ( * goTop	       )  ( AREAP );
   ERRCODE ( * seek	       )  ( AREAP, BOOL, ITEM );
   ERRCODE ( * skip	       )  ( AREAP, LONG );
   ERRCODE ( * skipFilter      )  ( AREAP, LONG );
   ERRCODE ( * skipRaw	       )  ( AREAP, LONG );

   /* Data management */

   ERRCODE ( * addField        )  ( AREAP, LPDBFIELDINFO );
   ERRCODE ( * append	       )  ( AREAP, BOOL );
   ERRCODE ( * createFields    )  ( AREAP, void * );
   ERRCODE ( * deleterec       )  ( AREAP );
   ERRCODE ( * deleted	       )  ( AREAP, BOOL * );
   ERRCODE ( * fieldCount      )  ( AREAP, ULONG * );
   ERRCODE ( * fieldDisplay    )  ( AREAP, void * );
   ERRCODE ( * fieldInfo       )  ( AREAP, ULONG, ULONG, ITEM );
   ERRCODE ( * fieldName       )  ( AREAP, ULONG, PBYTE );
   ERRCODE ( * flush	       )  ( AREAP );
   ERRCODE ( * getRec	       )  ( AREAP, PBYTE * );
   ERRCODE ( * getValue        )  ( AREAP, ULONG, ITEM );
   ERRCODE ( * getVarLen       )  ( AREAP, ULONG, FIELD * );
   ERRCODE ( * goCold	       )  ( AREAP );
   ERRCODE ( * goHot	       )  ( AREAP );
   ERRCODE ( * putRec	       )  ( AREAP, PBYTE );
   ERRCODE ( * putValue        )  ( AREAP, ULONG, ITEM );
   ERRCODE ( * recall	       )  ( AREAP );
   ERRCODE ( * reccount        )  ( AREAP, ULONG * );
   ERRCODE ( * recInfo	       )  ( AREAP, ITEM, ULONG, ITEM );
   ERRCODE ( * recno	       )  ( AREAP, ITEM );
   ERRCODE ( * setFieldExtent  )  ( AREAP, ULONG );

   /* WorkArea/Database management */

   ERRCODE ( * alias	       )  ( AREAP, PBYTE );
   ERRCODE ( * close	       )  ( AREAP );
   ERRCODE ( * create	       )  ( AREAP, LPDBOPENINFO );
   ERRCODE ( * info	       )  ( AREAP, ULONG, ITEM );
   ERRCODE ( * newarea	       )  ( AREAP );
   ERRCODE ( * open	       )  ( AREAP, LPDBOPENINFO );
   ERRCODE ( * release	       )  ( AREAP );
   ERRCODE ( * structSize      )  ( AREAP, ULONG * );
   ERRCODE ( * sysName	       )  ( AREAP, PBYTE );
   ERRCODE ( * dbEval	       )  ( AREAP, LPDBEVALINFO );
   ERRCODE ( * pack	       )  ( AREAP );
   ERRCODE ( * packRec	       )  ( AREAP, LONG, BOOL * );
   ERRCODE ( * sort	       )  ( AREAP, LPDBSORTINFO );
   ERRCODE ( * trans	       )  ( AREAP, LPDBTRANSINFO );
   ERRCODE ( * transRec        )  ( AREAP, LPDBTRANSINFO );
   ERRCODE ( * zap	       )  ( AREAP );

   /* Relational Methods */

   ERRCODE ( * childEnd        )  ( AREAP, LPDBRELINFO );
   ERRCODE ( * childStart      )  ( AREAP, LPDBRELINFO );
   ERRCODE ( * childSync       )  ( AREAP, LPDBRELINFO );
   ERRCODE ( * syncChildren    )  ( AREAP );
   ERRCODE ( * clearRel        )  ( AREAP );
   ERRCODE ( * forceRel        )  ( AREAP );
   ERRCODE ( * relArea	       )  ( AREAP, ULONG, ULONG * );
   ERRCODE ( * relEval	       )  ( AREAP, LPDBRELINFO );
   ERRCODE ( * relText	       )  ( AREAP, ULONG, PBYTE );
   ERRCODE ( * setRel	       )  ( AREAP, LPDBRELINFO );

   /* Order Management */

   ERRCODE ( * orderListAdd    )  ( AREAP, LPDBORDERINFO );
   ERRCODE ( * orderListClear  )  ( AREAP );
   ERRCODE ( * orderListDelete )  ( AREAP, LPDBORDERINFO );
   ERRCODE ( * orderListFocus  )  ( AREAP, LPDBORDERINFO );
   ERRCODE ( * orderListRebuild)  ( AREAP );

   ERRCODE ( * orderCondition  )  ( AREAP, LPDBORDERCONDINFO );
   ERRCODE ( * orderCreate     )  ( AREAP, LPDBORDERCREATEINFO );
   ERRCODE ( * orderDestroy    )  ( AREAP, LPDBORDERINFO );
   ERRCODE ( * orderInfo       )  ( AREAP, ULONG, LPDBORDERINFO );

   /* Filters and Scope Settings */

   ERRCODE ( * clearFilter     )  ( AREAP );
   ERRCODE ( * clearLocate     )  ( AREAP );
   ERRCODE ( * clearScope      )  ( AREAP, void * );
   ERRCODE ( * countScope      )  ( AREAP, void *, LONG * );
   ERRCODE ( * filterText      )  ( AREAP, PBYTE );
   ERRCODE ( * scopeInfo       )  ( AREAP, ULONG, ITEM );
   ERRCODE ( * setFilter       )  ( AREAP, LPDBFILTERINFO );
   ERRCODE ( * setLocate       )  ( AREAP, LPDBFILTERINFO );
   ERRCODE ( * setScope        )  ( AREAP, LPDBSCOPEINFO, void ** );
   ERRCODE ( * skipScope       )  ( AREAP, LPDBSCOPEINFO, LONG );

   /* Miscellaneous */

   ERRCODE ( * compile	       )  ( AREAP, PBYTE );
   ERRCODE ( * error	       )  ( AREAP, ERRORP );
   ERRCODE ( * evalBlock       )  ( AREAP, ITEM );

   /* Network operations */

   ERRCODE ( * rawLock	       )  ( AREAP, ULONG, LONG );
   ERRCODE ( * lock	       )  ( AREAP, LPDBLOCKINFO );
   ERRCODE ( * unlock	       )  ( AREAP, ITEM );

   /* Memofile functions */

   ERRCODE ( * closeMemFile    )  ( AREAP );
   ERRCODE ( * createMemFile   )  ( AREAP, LPDBOPENINFO );
   ERRCODE ( * getValueFile    )  ( AREAP, ULONG, PBYTE, BOOL );
   ERRCODE ( * openMemFile     )  ( AREAP, LPDBOPENINFO );
   ERRCODE ( * putValueFile    )  ( AREAP, ULONG, PBYTE );

   /* Database file header handling */

   ERRCODE ( * readDBHeader    )  ( AREAP );
   ERRCODE ( * writeDBHeader   )  ( AREAP );
   ERRCODE ( * dbstruct        )  ( AREAP, ITEM );

   /* Special and reserved methods */

   ERRCODE ( * whoCares        )  ( AREAP, ULONG, void * );

} RDDFUNCS;

typedef RDDFUNCS       * LPRDDFUNCS;
#define RDDFUNCSCOUNT ( sizeof( RDDFUNCS ) / sizeof( void * ) )

/*--------------------* SELF Methods *------------------------*/

/* Movement and positioning methods */

#define SELF_BOF(w, sp) 	   ((*(w)->lprfsHost.bof)(w, sp))
#define SELF_EOF(w, sp) 	   ((*(w)->lprfsHost.eof)(w, sp))
#define SELF_FOUND(w, sp)	   ((*(w)->lprfsHost.found)(w, sp))
#define SELF_GOTO(w, l) 	   ((*(w)->lprfsHost.go)(w, l))
#define SELF_GOTOID(w, sp)	   ((*(w)->lprfsHost.goToId)(w, sp))
#define SELF_GOBOTTOM(w)	   ((*(w)->lprfsHost.goBottom)(w))
#define SELF_GOTOP(w)		   ((*(w)->lprfsHost.goTop)(w))
#define SELF_SEEK(w, i, v)	   ((*(w)->lprfsHost.seek)(w, i, v))
#define SELF_SKIP(w, l) 	   ((*(w)->lprfsHost.skip)(w, l))
#define SELF_SKIPFILTER(w, l)	   ((*(w)->lprfsHost.skipFilter)(w, l))
#define SELF_SKIPRAW(w, l)	   ((*(w)->lprfsHost.skipRaw)(w, l))


/* Data management */

#define SELF_ADDFIELD(w, ip)	   ((*(w)->lprfsHost.addField)(w, ip))
#define SELF_APPEND(w,l)	   ((*(w)->lprfsHost.append)(w,l))
#define SELF_CREATEFIELDS(w, v)    ((*(w)->lprfsHost.createFields)(w, v))
#define SELF_DELETE(w)		   ((*(w)->lprfsHost.deleterec)(w))
#define SELF_DELETED(w, sp)	   ((*(w)->lprfsHost.deleted)(w, sp))
#define SELF_FIELDCOUNT(w, sp)	   ((*(w)->lprfsHost.fieldCount)(w, sp))
#define SELF_FIELDDISPLAY(w, sp)   ((*(w)->lprfsHost.fieldDisplay)(w, sp))
#define SELF_FIELDINFO(w,s1,s2,v)  ((*(w)->lprfsHost.fieldInfo)(w,s1,s2,v))
#define SELF_FIELDNAME(w, i, bp)   ((*(w)->lprfsHost.fieldName)(w, i, bp))
#define SELF_FLUSH(w)		   ((*(w)->lprfsHost.flush)(w))
#define SELF_GETREC(w, bpp)	   ((*(w)->lprfsHost.getRec)(w, bpp))
#define SELF_GETVALUE(w, i, v)	   ((*(w)->lprfsHost.getValue)(w, i, v))
#define SELF_GETVARLEN(w, i, lp)   ((*(w)->lprfsHost.getVarLen)(w, i, lp))
#define SELF_GOCOLD(w)		   ((*(w)->lprfsHost.goCold)(w))
#define SELF_GOHOT(w)		   ((*(w)->lprfsHost.goHot)(w))
#define SELF_PUTVALUE(w, i, v)	   ((*(w)->lprfsHost.putValue)(w, i, v))
#define SELF_PUTREC(w, bp)	   ((*(w)->lprfsHost.putRec)(w, bp))
#define SELF_RECALL(w)		   ((*(w)->lprfsHost.recall)(w))
#define SELF_RECCOUNT(w, sp)	   ((*(w)->lprfsHost.reccount)(w, sp))
#define SELF_RECINFO(w,v1,i,v2)    ((*(w)->lprfsHost.recInfo)(w,v1,i,v2))
#define SELF_RECNO(w, i)	   ((*(w)->lprfsHost.recno)(w, i))
#define SELF_SETFIELDEXTENT(w, s)  ((*(w)->lprfsHost.setFieldExtent)(w, s))


/* WorkArea/Database management */

#define SELF_ALIAS(w, bp)	   ((*(w)->lprfsHost.alias)(w, bp))
#define SELF_CLOSE(w)		   ((*(w)->lprfsHost.close)(w))
#define SELF_CREATE(w, ip)	   ((*(w)->lprfsHost.create)(w, ip))
#define SELF_INFO(w, i, g)	   ((*(w)->lprfsHost.info)(w, i, g))
#define SELF_NEW(w)		   ((*(w)->lprfsHost.newarea)(w))
#define SELF_OPEN(w, ip)	   ((*(w)->lprfsHost.open)(w, ip))
#define SELF_RELEASE(w) 	   ((*(w)->lprfsHost.release)(w))
#define SELF_STRUCTSIZE(w, sp)	   ((*(w)->lprfsHost.structSize)(w,sp))
#define SELF_SYSNAME(w, bp)	   ((*(w)->lprfsHost.sysName)(w, bp))
#define SELF_DBEVAL(w, ip)	   ((*(w)->lprfsHost.dbEval)(w, ip))
#define SELF_PACK(w)		   ((*(w)->lprfsHost.pack)(w))
#define SELF_PACKREC(w, l, sp)	   ((*(w)->lprfsHost.packRec)(w, l, sp))
#define SELF_SORT(w, ip)	   ((*(w)->lprfsHost.sort)(w, ip))
#define SELF_TRANS(w, ip)	   ((*(w)->lprfsHost.trans)(w, ip))
#define SELF_TRANSREC(w, ip)	   ((*(w)->lprfsHost.transRec)(w, ip))
#define SELF_ZAP(w)		   ((*(w)->lprfsHost.zap)(w))


/* Relational Methods */

#define SELF_CHILDEND(w, ip)	   ((*(w)->lprfsHost.childEnd)(w, ip))
#define SELF_CHILDSTART(w, ip)	   ((*(w)->lprfsHost.childStart)(w, ip))
#define SELF_CHILDSYNC(w, ip)	   ((*(w)->lprfsHost.childSync)(w, ip))
#define SELF_SYNCCHILDREN(w)	   ((*(w)->lprfsHost.syncChildren)(w))
#define SELF_CLEARREL(w)	   ((*(w)->lprfsHost.clearRel)(w))
#define SELF_FORCEREL(w)	   ((*(w)->lprfsHost.forceRel)(w))
#define SELF_RELAREA(w, s, sp)	   ((*(w)->lprfsHost.relArea)(w, s, sp))
#define SELF_RELEVAL(w, ip)	   ((*(w)->lprfsHost.relEval)(w, ip))
#define SELF_RELTEXT(w, s, bp)	   ((*(w)->lprfsHost.relText)(w, s, bp))
#define SELF_SETREL(w, ip)	   ((*(w)->lprfsHost.setRel)(w, ip))


/* Order Management */

#define SELF_ORDLSTADD(w, lp)	   ((*(w)->lprfsHost.orderListAdd)(w, lp))
#define SELF_ORDLSTDELETE(w, lp)   ((*(w)->lprfsHost.orderListDelete)(w, lp))
#define SELF_ORDLSTFOCUS(w, lp)    ((*(w)->lprfsHost.orderListFocus)(w,lp))
#define SELF_ORDLSTREBUILD(w)	   ((*(w)->lprfsHost.orderListRebuild)(w))
#define SELF_ORDLSTCLEAR(w)	   ((*(w)->lprfsHost.orderListClear)(w))

#define SELF_ORDSETCOND(w, ip)	   ((*(w)->lprfsHost.orderCondition)(w, ip))
#define SELF_ORDCREATE(w, ip)	   ((*(w)->lprfsHost.orderCreate)(w, ip))
#define SELF_ORDDESTROY(w, p)	   ((*(w)->lprfsHost.orderDestroy)(w, p))
#define SELF_ORDINFO(w, i, p)	   ((*(w)->lprfsHost.orderInfo)(w, i, p))
#define SELF_ORDEXPR(w, p)	   ((*(w)->lprfsHost.orderInfo)(w, DBOI_EXPRESSION, p))
#define SELF_ORDCOND(w, p)	   ((*(w)->lprfsHost.orderInfo)(w, DBOI_CONDITION,  p))
#define SELF_ORDRECNO(w, p)	   ((*(w)->lprfsHost.orderInfo)(w, DBOI_RECNO,	    p))
#define SELF_ORDPOS(w, p)	   ((*(w)->lprfsHost.orderInfo)(w, DBOI_POSITION,   p))
#define SELF_ORDNUMBER(w, p)	   ((*(w)->lprfsHost.orderInfo)(w, DBOI_NUMBER,     p))
#define SELF_ORDNAME(w, p)	   ((*(w)->lprfsHost.orderInfo)(w, DBOI_NAME,	    p))
#define SELF_ORDBAGNAME(w, p)	   ((*(w)->lprfsHost.orderInfo)(w, DBOI_BAGNAME,    p))
#define SELF_ORDBAGEXT(w,  p)	   ((*(w)->lprfsHost.orderInfo)(w, DBOI_BAGEXT,     p))


/* Filters and Scope Settings */

#define SELF_CLEARFILTER(w)	   ((*(w)->lprfsHost.clearFilter)(w))
#define SELF_CLEARLOCATE(w)	   ((*(w)->lprfsHost.clearLocate)(w))
#define SELF_CLEARSCOPE(w)	   ((*(w)->lprfsHost.clearScope)(w))
#define SELF_COUNTSCOPE(w,ip,lp)   ((*(w)->lprfsHost.countScope)(w,ip,lp))
#define SELF_FILTERTEXT(w, bp)	   ((*(w)->lprfsHost.filterText)(w, bp))
#define SELF_SCOPEINFO(w,i,v)	   ((*(w)->lprfsHost.scopeInfo)(w,i,v))
#define SELF_SETFILTER(w, ip)	   ((*(w)->lprfsHost.setFilter)(w, ip))
#define SELF_SETLOCATE(w, ip)	   ((*(w)->lprfsHost.setLocate)(w, ip))
#define SELF_SETSCOPE(w, ip)	   ((*(w)->lprfsHost.setScope)(w, ip))
#define SELF_SKIPSCOPE(w, bp, l)   ((*(w)->lprfsHost.skipScope)(w, bp, l))


/* Miscellaneous */

#define SELF_COMPILE(w, bp)	   ((*(w)->lprfsHost.compile)(w, bp))
#define SELF_ERROR(w, ip)	   ((*(w)->lprfsHost.error)(w, ip))
#define SELF_EVALBLOCK(w, v)	   ((*(w)->lprfsHost.evalBlock)(w, v))


/* Network operations */

#define SELF_GETLOCKS(w, g)	   ((*(w)->lprfsHost.info)(w, DBI_GETLOCKARRAY, g))
#define SELF_RAWLOCK(w, i, l)	   ((*(w)->lprfsHost.rawLock)(w, i, l))
#define SELF_LOCK(w, sp)	   ((*(w)->lprfsHost.lock)(w, sp))
#define SELF_UNLOCK(w, l)	   ((*(w)->lprfsHost.unlock)(w, l))


/* Memofile functions */

#define SELF_CLOSEMEMFILE(w)	   ((*(w)->lprfsHost.closeMemFile)(w))
#define SELF_CREATEMEMFILE(w,bp)   ((*(w)->lprfsHost.createMemFile)(w,bp))
#define SELF_GETVALUEFILE(w,i,bp,b) ((*(w)->lprfsHos.>getValueFile)(w,i,bp,b))
#define SELF_OPENMEMFILE(w,bp)	   ((*(w)->lprfsHost.openMemFile)(w,bp))
#define SELF_PUTVALUEFILE(w,i,bp)  ((*(w)->lprfsHost.putValueFile)(w,i,bp))


/* Database file header handling */

#define SELF_READDBHEADER(w)	   ((*(w)->lprfsHost.readDBHeader)(w))
#define SELF_WRITEDBHEADER(w)	   ((*(w)->lprfsHost.writeDBHeader)(w))


/* Info operations */

#define SELF_RECSIZE(w, lp)	   ((*(w)->lprfsHost.info)(w, DBI_GETRECSIZE, lp))
#define SELF_HEADERSIZE(w, fp)	   ((*(w)->lprfsHost.info)(w, DBI_GETHEADERSIZE, fp))
#define SELF_LUPDATE(w, fp)	   ((*(w)->lprfsHost.info)(w, DBI_LASTUPDATE, fp ))
#define SELF_SETDELIM(w, fp)	   ((*(w)->lprfsHost.info)(w, DBI_SETDELIMITER, fp))
#define SELF_GETDELIM(w, fp)	   ((*(w)->lprfsHost.info)(w, DBI_GETDELIMITER, fp))
#define SELF_TABLEEXT(w, fp)	   ((*(w)->lprfsHost.info)(w, DBI_TABLEEXT, fp))

#define SELF_DBSTRUCT(w, fp)	   ((*(w)->lprfsHost.dbstruct)(w, fp))


/*--------------------* SUPER Methods *------------------------*/

/* Movement and positioning methods */


#define SUPER_BOF(w, sp)	    ((*(SUPERTABLE)->bof)(w, sp))
#define SUPER_EOF(w, sp)	    ((*(SUPERTABLE)->eof)(w, sp))
#define SUPER_FOUND(w, sp)	    ((*(SUPERTABLE)->found)(w, sp))
#define SUPER_GOTO(w, l)	    ((*(SUPERTABLE)->go)(w, l))
#define SUPER_GOTOID(w, sp)	    ((*(SUPERTABLE)->goToId)(w, sp))
#define SUPER_GOBOTTOM(w)	    ((*(SUPERTABLE)->goBottom)(w))
#define SUPER_GOTOP(w)		    ((*(SUPERTABLE)->goTop)(w))
#define SUPER_SEEK(w, i, v)	    ((*(SUPERTABLE)->seek)(w, i, v))
#define SUPER_SKIP(w, l)	    ((*(SUPERTABLE)->skip)(w, l))
#define SUPER_SKIPFILTER(w, l)	    ((*(SUPERTABLE)->skipFilter)(w, l))
#define SUPER_SKIPRAW(w, l)	    ((*(SUPERTABLE)->skipRaw)(w, l))


/* Data management */

#define SUPER_ADDFIELD(w, ip)	    ((*(SUPERTABLE)->addField)(w, ip))
#define SUPER_APPEND(w,l)	    ((*(SUPERTABLE)->append)(w,l))
#define SUPER_CREATEFIELDS(w, v)    ((*(SUPERTABLE)->createFields)(w, v))
#define SUPER_DELETE(w) 	    ((*(SUPERTABLE)->deleterec)(w))
#define SUPER_DELETED(w, sp)	    ((*(SUPERTABLE)->deleted)(w, sp))
#define SUPER_FIELDCOUNT(w, sp)     ((*(SUPERTABLE)->fieldCount)(w, sp))
#define SUPER_FIELDDISPLAY(w, sp)   ((*(SUPERTABLE)->fieldDisplay)(w, sp))
#define SUPER_FIELDINFO(w,s1,s2,v)  ((*(SUPERTABLE)->fieldInfo)(w,s1,s2,v))
#define SUPER_FIELDNAME(w, i, bp)   ((*(SUPERTABLE)->fieldName)(w, i, bp))
#define SUPER_FLUSH(w)		    ((*(SUPERTABLE)->flush)(w))
#define SUPER_GETREC(w, bpp)	    ((*(SUPERTABLE)->getRec)(w, bpp))
#define SUPER_GETVALUE(w, i, v)     ((*(SUPERTABLE)->getValue)(w, i, v))
#define SUPER_GETVARLEN(w, i, lp)   ((*(SUPERTABLE)->getVarLen)(w, i, lp))
#define SUPER_GOCOLD(w) 	    ((*(SUPERTABLE)->goCold)(w))
#define SUPER_GOHOT(w)		    ((*(SUPERTABLE)->goHot)(w))
#define SUPER_PUTVALUE(w, i, v)     ((*(SUPERTABLE)->putValue)(w, i, v))
#define SUPER_PUTREC(w, bp)	    ((*(SUPERTABLE)->putRec)(w, bp))
#define SUPER_RECALL(w) 	    ((*(SUPERTABLE)->recall)(w))
#define SUPER_RECCOUNT(w, sp)	    ((*(SUPERTABLE)->reccount)(w, sp))
#define SUPER_RECINFO(w,v1,i,v2)    ((*(SUPERTABLE)->recInfo)(w,v1,i,v2))
#define SUPER_RECNO(w, sp)	    ((*(SUPERTABLE)->recno)(w, sp))
#define SUPER_SETFIELDEXTENT(w, s)  ((*(SUPERTABLE)->setFieldExtent)(w, s))


/* WorkArea/Database management */

#define SUPER_ALIAS(w, bp)	  ((*(SUPERTABLE)->alias)(w, bp))
#define SUPER_CLOSE(w)		  ((*(SUPERTABLE)->close)(w))
#define SUPER_CREATE(w, ip)	  ((*(SUPERTABLE)->create)(w, ip))
#define SUPER_INFO(w, i, g)	  ((*(SUPERTABLE)->info)(w, i, g))
#define SUPER_NEW(w)		  ((*(SUPERTABLE)->newarea)(w))
//#define SUPER_OPEN(w, ip)	    ((*(SUPERTABLE)->open)(w, ip))
#define SUPER_OPEN(w, ip)	  ((*(w)->superArea->lprfsHost.open)(w, ip))


#define SUPER_RELEASE(w)	  ((*(SUPERTABLE)->release)(w))
#define SUPER_STRUCTSIZE(w, sp)   ((*(SUPERTABLE)->structSize)(w, sp))
#define SUPER_SYSNAME(w, bp)	  ((*(SUPERTABLE)->sysName)(w, bp))
#define SUPER_DBEVAL(w, ip)	  ((*(SUPERTABLE)->dbEval)(w, ip))
#define SUPER_PACK(w)		  ((*(SUPERTABLE)->pack)(w))
#define SUPER_PACKREC(w, l, sp)   ((*(SUPERTABLE)->packRec)(w, l, sp))
#define SUPER_SORT(w, ip)	  ((*(SUPERTABLE)->sort)(w, ip))
#define SUPER_TRANS(w, ip)	  ((*(SUPERTABLE)->trans)(w, ip))
#define SUPER_TRANSREC(w, ip)	  ((*(SUPERTABLE)->transRec)(w, ip))
#define SUPER_ZAP(w)		  ((*(SUPERTABLE)->zap)(w))


/* Relational Methods */

#define SUPER_CHILDEND(w, ip)	  ((*(SUPERTABLE)->childEnd)(w, ip))
#define SUPER_CHILDSTART(w, ip)   ((*(SUPERTABLE)->childStart)(w, ip))
#define SUPER_CHILDSYNC(w, ip)	  ((*(SUPERTABLE)->childSync)(w, ip))
#define SUPER_SYNCCHILDREN(w)	  ((*(SUPERTABLE)->syncChildren)(w))
#define SUPER_CLEARREL(w)	  ((*(SUPERTABLE)->clearRel)(w))
#define SUPER_FORCEREL(w)	  ((*(SUPERTABLE)->forceRel)(w))
#define SUPER_RELAREA(w, s, sp)   ((*(SUPERTABLE)->relArea)(w, s, sp))
#define SUPER_RELEVAL(w, ip)	  ((*(SUPERTABLE)->relEval)(w, ip))
#define SUPER_RELTEXT(w, s, bp)   ((*(SUPERTABLE)->relText)(w, s, bp))
#define SUPER_SETREL(w, ip)	  ((*(SUPERTABLE)->setRel)(w, ip))


/* Order Management */

#define SUPER_ORDLSTADD(w, lp)	  ((*(SUPERTABLE)->orderListAdd)(w, lp))
#define SUPER_ORDLSTDELETE(w, lp) ((*(SUPERTABLE)->orderListDelete)(w, lp))
#define SUPER_ORDLSTFOCUS(w, lp)  ((*(SUPERTABLE)->orderListFocus)(w, lp))
#define SUPER_ORDLSTREBUILD(w)	  ((*(SUPERTABLE)->orderListRebuild)(w))
#define SUPER_ORDLSTCLEAR(w)	  ((*(SUPERTABLE)->orderListClear)(w))

#define SUPER_ORDSETCOND(w,ip) ((*(SUPERTABLE)->orderCondition)(w, ip))
#define SUPER_ORDCREATE(w, ip) ((*(SUPERTABLE)->orderCreate)(w, ip))
#define SUPER_ORDDELETE(w, ip) ((*(SUPERTABLE)->orderDelete)(w, ip))
#define SUPER_ORDINFO(w, i, p) ((*(SUPERTABLE)->orderInfo)(w, i, p))
#define SUPER_ORDEXPR(w, p)    ((*(SUPERTABLE)->orderInfo)(w, DBOI_EXPRESSION, p))
#define SUPER_ORDCOND(w, p)    ((*(SUPERTABLE)->orderInfo)(w, DBOI_CONDITION,  p))
#define SUPER_ORDRECNO(w, p)   ((*(SUPERTABLE)->orderInfo)(w, DBOI_RECNO,      p))
#define SUPER_ORDPOS(w, p)     ((*(SUPERTABLE)->orderInfo)(w, DBOI_POSITION,   p))
#define SUPER_ORDNUMBER(w, p)  ((*(SUPERTABLE)->orderInfo)(w, DBOI_NUMBER,     p))
#define SUPER_ORDNAME(w, p)    ((*(SUPERTABLE)->orderInfo)(w, DBOI_NAME,       p))
#define SUPER_ORDBAGNAME(w, p) ((*(SUPERTABLE)->orderInfo)(w, DBOI_BAGNAME,    p))
#define SUPER_ORDBAGEXT(w,  p) ((*(SUPERTABLE)->orderInfo)(w, DBOI_BAGEXT,     p))


/* Filters and Scope Settings */

#define SUPER_CLEARFILTER(w)	  ((*(SUPERTABLE)->clearFilter)(w))
#define SUPER_CLEARLOCATE(w)	  ((*(SUPERTABLE)->clearLocate)(w))
#define SUPER_CLEARSCOPE(w)	  ((*(SUPERTABLE)->clearScope)(w))
#define SUPER_COUNTSCOPE(w,ip,lp) ((*(SUPERTABLE)->countScope)(w,ip,lp))
#define SUPER_FILTERTEXT(w, bp)   ((*(SUPERTABLE)->filterText)(w, bp))
#define SUPER_SCOPEINFO(w,i,v)	  ((*(SUPERTABLE)->scopeInfo)(w,i,v))
#define SUPER_SETFILTER(w, ip)	  ((*(SUPERTABLE)->setFilter)(w, ip))
#define SUPER_SETLOCATE(w, ip)	  ((*(SUPERTABLE)->setLocate)(w, ip))
#define SUPER_SETSCOPE(w, ip)	  ((*(SUPERTABLE)->setScope)(w, ip))
#define SUPER_SKIPSCOPE(w, bp, l) ((*(SUPERTABLE)->skipScope)(w, bp, l))


/* Miscellaneous */

#define SUPER_COMPILE(w, bp)	  ((*(SUPERTABLE)->compile)(w, bp))
#define SUPER_ERROR(w, ip)	  ((*(SUPERTABLE)->error)(w, ip))
#define SUPER_EVALBLOCK(w, v)	  ((*(SUPERTABLE)->evalBlock)(w, v))


/* Network operations */

#define SUPER_GETLOCKS(w, g)	  ((*(SUPERTABLE)->info)(w, DBI_GETLOCKARRAY, g))
#define SUPER_RAWLOCK(w, i, l)	  ((*(SUPERTABLE)->rawlock)(w, i, l))
#define SUPER_LOCK(w, sp)	  ((*(SUPERTABLE)->lock)(w, sp))
#define SUPER_UNLOCK(w) 	  ((*(SUPERTABLE)->unlock)(w))


/* Memofile functions */

#define SUPER_CLOSEMEMFILE(w)	    ((*(SUPERTABLE)->closeMemFile)(w))
#define SUPER_CREATEMEMFILE(w,bp)   ((*(SUPERTABLE)->createMemFile)(w,bp))
#define SUPER_GETVALUEFILE(w,i,bp,b) ((*(SUPERTABLE)->getValueFile)(w,i,bp,b))
#define SUPER_OPENMEMFILE(w,bp)     ((*(SUPERTABLE)->openMemFile)(w,bp))
#define SUPER_PUTVALUEFILE(w,i,bp)  ((*(SUPERTABLE)->putValueFile)(w,i,bp))


/* Database file header handling */

#define SUPER_READDBHEADER(w)	    ((*(SUPERTABLE)->readDBHeader)(w))
#define SUPER_WRITEDBHEADER(w)	    ((*(SUPERTABLE)->writeDBHeader)(w))


/* Info operations */

#define SUPER_RECSIZE(w, lp)	  ((*(SUPERTABLE)->info)(w, DBI_GETRECSIZE, lp))
#define SUPER_HEADERSIZE(w, fp)   ((*(SUPERTABLE)->info)(w, DBI_GETHEADERSIZE, fp))
#define SUPER_LUPDATE(w, fp)	  ((*(SUPERTABLE)->info)(w, DBI_LASTUPDATE, fp ))
#define SUPER_SETDELIM(w, fp)	  ((*(SUPERTABLE)->info)(w, DBI_SETDELIMITER, fp))
#define SUPER_GETDELIM(w, fp)	  ((*(SUPERTABLE)->info)(w, DBI_GETDELIMITER, fp))
#define SUPER_TABLEEXT(w, fp)	  ((*(SUPERTABLE)->info)(w, DBI_TABLEEXT, fp))



//	differences (vs. CA Clipper 5.3 spec)
//
//	AREA:
//
//	uiSize		the struct carries a uiSize item which must be filled with a correct value
//	RDDMETHODS	equals the previous struct RDDFUNCS far *
//	uiArea		now a ULONG
//	uiFieldExtent	now a ULONG
//	uiFieldCount	now a ULONG
//	uiParents	now a ULONG
//
//



_AREA
{
   ULONG		uiSize; 		// size of this struct
   ULONG		uiSizeRDDmethods;	// size of the RDD methods
   RDDFUNCS		lprfsHost;		// Virtual method table for this workarea
   ULONG		uiArea; 		// The number assigned to this workarea
   FARP 		atomAlias;		// Pointer to the alias symbol for this workarea
   ULONG		uiFieldExtent;		// Total number of fields allocated
   ULONG		uiFieldCount;		// Total number of fields used
   LPFIELD		lpFields;		// Pointer to an array of fields
   FARP 		lpFieldExtents; 	// Void ptr for additional field properties
   ITEM 		valResult;		// All purpose result holder
   BOOL 		fTop;			// TRUE if "top"
   BOOL 		fBottom;		// TRUE if "bottom"
   BOOL 		fBof;			// TRUE if "bof"
   BOOL 		fEof;			// TRUE if "eof"
   BOOL 		fFound; 		// TRUE if "found"

   DBSCOPEINFO		dbsi;			// Info regarding last LOCATE
   DBFILTERINFO 	dbfi;			// Filter in effect

   LPDBORDERCONDINFO	lpdbOrdCondInfo;

   LPDBRELINFO		lpdbRelations;		// Parent/Child relationships used
   ULONG		uiParents;		// Number of parents for this area

   HANDLE		heap;
   ULONG		heapSize;

   ULONG		rddID;			// the area number

//HARBOUR defined new variables. for internal use only
   AREAP		next;
   AREAP		prev;
   BOOL 		inUse;
   FHANDLE		fileHandle;
   ULONG		uiFlags;
   UCHAR *		abName;
   AREAP		superArea;		// from which this one inherits
};

typedef void (*RDDENTRY)( ULONG *nCount, RDDFUNCS *p);

typedef void (*WORKAREA_FUNCTION)( AREAP workarea );


#define RDD_REGISTER	struct _rddRegister
RDD_REGISTER
{
  RDD_REGISTER	*next;
  RDD_REGISTER	*prev;
  RDDENTRY	 rddEntry;
  char		 RDDdriver[ HARBOUR_MAX_RDD_DRIVERNAME_LENGTH ];
};
char		*hb_default_rdd( void );
ULONG		 max_workarea( void );
ULONG		 SetWorkAreaNumber( ULONG n );
AREAP		 getCurrentWorkArea( void );
RDD_REGISTER	*findRDD( char *cRDD );
void		 all_workareas( WORKAREA_FUNCTION func );
AREAP		 createNewWorkArea( void );
BOOL		 is_inUse( AREAP p);
void		 AttachRDDtoThisWorkarea( AREAP workarea, char *cRDD);
ULONG		 LookupAliasName( char *cAlias );


#endif
#endif
